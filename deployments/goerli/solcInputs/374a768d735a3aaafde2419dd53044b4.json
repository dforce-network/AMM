{
  "language": "Solidity",
  "sources": {
    "contracts/interface/IPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\ninterface IPair {\r\n    function getAmountOut(address from, address to, uint256 amount) external view returns (uint256);\r\n\r\n    function tokens() external returns (address[] memory);\r\n\r\n    function initialize(address[] memory _tokens, bytes memory _data) external;\r\n\r\n    function PAIR_TYPE() external view returns (uint8);\r\n\r\n    function AUTH() external view returns (bool);\r\n}\r\n\r\ninterface IVolatilePair is IPair {\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\r\n\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\ninterface IStablePair is IPair {\r\n    function calculateTokenAmount(address[] calldata _tokens, uint256[] calldata _amounts, bool _deposit) external view returns (uint256);\r\n\r\n    function calculateRemoveLiquidityOneToken(address _token, uint256 _liquidity) external view returns (uint256);\r\n\r\n    function calculateRemoveLiquidity(address[] calldata _tokens, uint256 _amount) external view returns (uint256[] memory);\r\n\r\n    function addLiquidity(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts,\r\n        uint256 _minToMint,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external payable returns (uint256);\r\n\r\n    function removeLiquidity(\r\n        uint256 _amount,\r\n        uint256[] calldata _minAmounts,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external payable returns (uint256[] memory);\r\n\r\n    function removeLiquidityOneToken(\r\n        uint256 _tokenAmount,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external returns (uint256);\r\n\r\n    function removeLiquidityImbalance(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external returns (uint256);\r\n\r\n    function lpToken() external view returns (address);\r\n\r\n    function swap(\r\n        address _tokenFrom,\r\n        address _tokenTo,\r\n        uint256 _dx,\r\n        uint256 _minDy,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external returns (uint256);\r\n}\r\n"
    },
    "contracts/interface/IPairERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\ninterface IPairERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}"
    },
    "contracts/interface/IPairFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\ninterface IPairFactory {\r\n    //1: volatile pair, 2: stable pair, 3: yeild pair\r\n    struct PairParams {\r\n        address _impl;\r\n        bool _auth;\r\n    }\r\n\r\n    function allPairsLength() external view returns (uint256);\r\n\r\n    function isPair(address pair) external view returns (bool);\r\n\r\n    function createPair(\r\n        address[] memory _tokens,\r\n        uint8 _pairType,\r\n        bytes memory data\r\n    ) external returns (address pair);\r\n\r\n    function manager() external view returns (address);\r\n\r\n    function getPairAddress(address[] memory _tokens, uint8 _type) external view returns (address);\r\n\r\n    function pairTypeValues() external view returns (address[] memory);\r\n\r\n    function atPairType(uint256 _index) external view returns (address);\r\n\r\n}\r\n"
    },
    "contracts/interface/IPairRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\ninterface IPairRouter {\r\n    struct Route {\r\n        address from;\r\n        address to;\r\n        address pair;\r\n    }\r\n\r\n    function quoteAddLiquidity(address[] memory _tokens, uint256[] memory _amountDesireds)\r\n        external\r\n        view\r\n        returns (uint256[] memory _amountIn, uint256 liquidity);\r\n\r\n    function quoteRemoveLiquidity(address[] memory _tokens, uint256 _liquidity) external view returns (uint256[] memory _amounts);\r\n\r\n    function addLiquidity(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory _amountsMin,\r\n        uint256 _minLiquidity,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256[] memory _amounts, uint256 _liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory _amountMins,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable returns (uint256[] memory _amounts, uint256 _liquidity);\r\n\r\n    function removeLiquidity(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256[] memory _amounts);\r\n\r\n    function removeLiquidityETH(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256[] memory _returns);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256[] memory _amounts);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256[] memory);\r\n\r\n    function swap(\r\n        Route memory _route,\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 _amountOut);\r\n}\r\n\r\ninterface IStablPairRouter is IPairRouter {\r\n    function quoteRemoveLiquidityOneToken(\r\n        address[] calldata _tokens,\r\n        address _token,\r\n        uint256 _liquidity\r\n    ) external view returns (uint256 _amount);\r\n\r\n    function quoteRemoveLiquidityImbalance(address[] calldata _tokens, uint256[] calldata _amounts) external view returns (uint256 _liquidity);\r\n\r\n    function removeLiquidityOneToken(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 _amount);\r\n\r\n    function removeLiquidityImbalance(\r\n        address[] memory _tokens,\r\n        uint256[] calldata _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 _amount);\r\n}\r\n"
    },
    "contracts/interface/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\n/// @title Interface for WETH9\r\ninterface IWETH {\r\n    /// @notice Deposit ether to get wrapped ether\r\n    function deposit() external payable;\r\n\r\n    /// @notice Withdraw wrapped ether to get ether\r\n    function withdraw(uint256) external;\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n}\r\n"
    },
    "contracts/routers/StableRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\nimport \"../interface/IPair.sol\";\r\nimport \"../interface/IWETH.sol\";\r\nimport \"../interface/IPairRouter.sol\";\r\nimport \"../interface/IPairFactory.sol\";\r\nimport \"../interface/IPairERC20.sol\";\r\nimport \"../utils/Arrays.sol\";\r\n\r\ncontract StableRouter is IStablPairRouter {\r\n    using Arrays for address[];\r\n\r\n    uint8 public constant PAIR_TYPE = 2;\r\n\r\n    address public immutable factory;\r\n    IWETH public immutable weth;\r\n\r\n    modifier ensure(uint256 _deadline) {\r\n        require(_deadline >= block.timestamp, \"StableRouter: EXPIRED\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _factory, address _weth) {\r\n        factory = _factory;\r\n        weth = IWETH(_weth);\r\n    }\r\n\r\n    function quoteAddLiquidity(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds\r\n    ) external view override returns (uint256[] memory _amountIn, uint256 _liquidity) {\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        bool _isPair = IPairFactory(factory).isPair(_pair);\r\n        if (_isPair) {\r\n            _amountIn = _amountDesireds;\r\n            _liquidity = IStablePair(_pair).calculateTokenAmount(_tokens, _amountDesireds, true);\r\n        }\r\n    }\r\n\r\n    function quoteRemoveLiquidity(address[] memory _tokens, uint256 _liquidity) external view override returns (uint256[] memory _amounts) {\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        if (IPairFactory(factory).isPair(_pair)) _amounts = IStablePair(_pair).calculateRemoveLiquidity(_tokens, _liquidity);\r\n    }\r\n\r\n    function quoteRemoveLiquidityOneToken(\r\n        address[] calldata _tokens,\r\n        address _token,\r\n        uint256 _liquidity\r\n    ) external view override returns (uint256 _amount) {\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        if (IPairFactory(factory).isPair(_pair)) _amount = IStablePair(_pair).calculateRemoveLiquidityOneToken(_token, _liquidity);\r\n    }\r\n\r\n    function quoteRemoveLiquidityImbalance(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts\r\n    ) external view override returns (uint256 _liquidity) {\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        if (IPairFactory(factory).isPair(_pair)) _liquidity = IStablePair(_pair).calculateTokenAmount(_tokens, _amounts, false) + 1;\r\n    }\r\n\r\n    function addLiquidity(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory,\r\n        uint256 _minLiquidity,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external override ensure(_deadline) returns (uint256[] memory _amounts, uint256 _liquidity) {\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        require(IPairFactory(factory).isPair(_pair), \"StableRouter: is not pair\");\r\n        _amounts = _amountDesireds;\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            _safeTransferFrom(_tokens[i], msg.sender, address(this), _amounts[i]);\r\n            _safeApprove(_tokens[i], _pair, _amounts[i]);\r\n        }\r\n        _liquidity = IStablePair(_pair).addLiquidity(_tokens, _amounts, _minLiquidity, _to, _deadline);\r\n    }\r\n\r\n    /// @param _tokens The last one is the token of weth\r\n    /// @param _amountDesireds The last one is the amount of weth, And the array length is one bit longer than _tokens\r\n    /// @param _amountsMins only minLiquidity\r\n    function addLiquidityETH(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory _amountsMins,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable override returns (uint256[] memory _amounts, uint256 _liquidity) {\r\n        _amounts = new uint256[](2);\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        require(IPairFactory(factory).isPair(_pair), \"StableRouter: is not pair\");\r\n        _amounts = _amountDesireds;\r\n        weth.deposit{ value: _amounts[_amounts.length - 1] }();\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            _safeTransferFrom(_tokens[i], msg.sender, address(this), _amounts[i]);\r\n            _safeApprove(_tokens[i], _pair, _amounts[i]);\r\n        }\r\n        _liquidity = IStablePair(_pair).addLiquidity(_tokens, _amounts, _amountsMins[0], _to, _deadline);\r\n        if (msg.value > _amounts[_amounts.length - 1]) _safeTransferETH(msg.sender, msg.value - _amounts[_amounts.length - 1]);\r\n    }\r\n\r\n    function removeLiquidity(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public override returns (uint256[] memory _amounts) {\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        require(IPairFactory(factory).isPair(_pair), \"StableRouter: pair doesn't exist\"); // send liquidity to pair\r\n\r\n        address _lpToken = IStablePair(_pair).lpToken();\r\n        _safeTransferFrom(_lpToken, msg.sender, address(this), _liquidity);\r\n        _safeApprove(_lpToken, _pair, _liquidity);\r\n\r\n        _amounts = IStablePair(_pair).removeLiquidity(_liquidity, _amountsMin, _to, _deadline);\r\n    }\r\n\r\n    /// @param _tokens The last one is the token of weth\r\n    /// @param _amountsMin Minimum return value of each token\r\n    function removeLiquidityETH(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public override returns (uint256[] memory _amounts) {\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        require(IPairFactory(factory).isPair(_pair), \"StableRouter: pair doesn't exist\"); // send liquidity to pair\r\n\r\n        _amounts = removeLiquidity(_tokens, _liquidity, _amountsMin, _to, _deadline);\r\n\r\n        uint256 _ethAmount = _amounts[_amounts.length - 1];\r\n        weth.withdraw(_ethAmount);\r\n        _safeTransferETH(msg.sender, _ethAmount);\r\n    }\r\n\r\n    function removeLiquidityWithPermit(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external override returns (uint256[] memory _amounts) {\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        {\r\n            uint256 _value = _approveMax ? type(uint256).max : _liquidity;\r\n            address _lpToken = IStablePair(_pair).lpToken();\r\n            IPairERC20(_lpToken).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s);\r\n        }\r\n\r\n        _amounts = removeLiquidity(_tokens, _liquidity, _amountsMin, _to, _deadline);\r\n    }\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external override returns (uint256[] memory _amounts) {\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        {\r\n            uint256 _value = _approveMax ? type(uint256).max : _liquidity;\r\n            address _lpToken = IStablePair(_pair).lpToken();\r\n            IPairERC20(_lpToken).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s);\r\n        }\r\n\r\n        _amounts = removeLiquidityETH(_tokens, _liquidity, _amountsMin, _to, _deadline);\r\n    }\r\n\r\n    function removeLiquidityOneToken(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external override returns (uint256 _amount) {\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        _amount = IStablePair(_pair).removeLiquidityOneToken(_liquidity, _token, _minAmount, _to, _deadline);\r\n    }\r\n\r\n    function removeLiquidityImbalance(\r\n        address[] memory _tokens,\r\n        uint256[] calldata _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external override returns (uint256 _amount) {\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        _amount = IStablePair(_pair).removeLiquidityImbalance(_tokens, _amounts, _maxBurnAmount, _to, _deadline);\r\n    }\r\n\r\n    function swap(\r\n        Route memory _route,\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external override returns (uint256 _amountOut) {\r\n        require(IPairFactory(factory).isPair(_route.pair), \"StableRouter: is not pair\");\r\n\r\n        _safeTransferFrom(_route.from, msg.sender, address(this), _amountIn);\r\n        _safeApprove(_route.from, _route.pair, _amountIn);\r\n\r\n        return IStablePair(_route.pair).swap(_route.from, _route.to, _amountIn, _amountOutMin, _to, _deadline);\r\n    }\r\n\r\n    function _safeTransferFrom(address _token, address _from, address _to, uint256 _value) internal {\r\n        require(_token.code.length > 0);\r\n        (bool _success, bytes memory _data) = _token.call(abi.encodeWithSelector(IPairERC20.transferFrom.selector, _from, _to, _value));\r\n        require(_success && (_data.length == 0 || abi.decode(_data, (bool))));\r\n    }\r\n\r\n    function _safeApprove(address token, address to, uint256 amount) internal {\r\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(IPairERC20(token).approve.selector, to, amount));\r\n\r\n        if (!success || (returndata.length > 0 && !abi.decode(returndata, (bool)))) {\r\n            _callOptionalReturn(token, abi.encodeWithSelector(IPairERC20(token).approve.selector, to, 0));\r\n            _callOptionalReturn(token, abi.encodeWithSelector(IPairERC20(token).approve.selector, to, amount));\r\n        }\r\n    }\r\n\r\n    function _callOptionalReturn(address token, bytes memory data) private {\r\n        (bool success, bytes memory result) = token.call(data);\r\n        require(success, \"StablePair: Low-level call failed\");\r\n\r\n        if (result.length > 0) {\r\n            require(abi.decode(result, (bool)), \"StablePair: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n\r\n    function _safeTransferETH(address _to, uint256 _value) internal {\r\n        (bool _success, ) = _to.call{ value: _value }(new bytes(0));\r\n        require(_success, \"TransferHelper: ETH_TRANSFER_FAILED\");\r\n    }\r\n}\r\n"
    },
    "contracts/utils/Arrays.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\nlibrary Arrays {\r\n    function sortArray(address[] memory arr) internal pure returns (address[] memory) {\r\n        uint256 l = arr.length;\r\n        for (uint256 i = 0; i < l; i++) {\r\n            for (uint256 j = i + 1; j < l; j++) {\r\n                if (arr[i] > arr[j]) {\r\n                    address temp = arr[i];\r\n                    arr[i] = arr[j];\r\n                    arr[j] = temp;\r\n                }\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function copyAndAddOne(address[] memory arr, address _add) internal pure returns (address[] memory _result) {\r\n        _result = new address[](arr.length + 1);\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            _result[i] = arr[i];\r\n        }\r\n        _result[arr.length] = _add;\r\n    }\r\n\r\n    function removeEmpty(address[] memory arr) internal pure returns (address[] memory _new) {\r\n        uint256 count;\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            if (arr[i] != address(0)) {\r\n                count++;\r\n            }\r\n        }\r\n        _new = new address[](count);\r\n        uint256 j;\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            if (arr[i] == address(0)) {\r\n                continue;\r\n            }\r\n            _new[j] = arr[i];\r\n            j++;\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}