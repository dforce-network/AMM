{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // 鈫?`sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // 鈫?`2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/interface/IPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\ninterface IPair {\n    function getAmountOut(address from, address to, uint256 amount) external view returns (uint256);\n\n    function tokens() external returns (address[] memory);\n\n    function initialize(address[] memory _tokens, bytes memory _data) external;\n\n    function PAIR_TYPE() external view returns (uint8);\n\n    function AUTH() external view returns (bool);\n}\n\ninterface IVolatilePair is IPair {\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\n\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\n\ninterface IStablePair is IPair {\n    function calculateTokenAmount(address[] calldata _tokens, uint256[] calldata _amounts, bool _deposit) external view returns (uint256);\n\n    function calculateRemoveLiquidityOneToken(address _token, uint256 _liquidity) external view returns (uint256);\n\n    function calculateRemoveLiquidity(address[] calldata _tokens, uint256 _amount) external view returns (uint256[] memory);\n\n    function addLiquidity(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts,\n        uint256 _minToMint,\n        address _receiver,\n        uint256 _deadline\n    ) external payable returns (uint256);\n\n    function removeLiquidity(\n        uint256 _amount,\n        uint256[] calldata _minAmounts,\n        address _receiver,\n        uint256 _deadline\n    ) external payable returns (uint256[] memory);\n\n    function removeLiquidityOneToken(\n        uint256 _tokenAmount,\n        address _token,\n        uint256 _minAmount,\n        address _receiver,\n        uint256 _deadline\n    ) external returns (uint256);\n\n    function removeLiquidityImbalance(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts,\n        uint256 _maxBurnAmount,\n        address _receiver,\n        uint256 _deadline\n    ) external returns (uint256);\n\n    function lpToken() external view returns (address);\n\n    function swap(\n        address _tokenFrom,\n        address _tokenTo,\n        uint256 _dx,\n        uint256 _minDy,\n        address _receiver,\n        uint256 _deadline\n    ) external returns (uint256);\n}\n"
    },
    "contracts/interface/IPairCallee.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\ninterface IPairCallee {\n    function hook(\n        address sender,\n        uint256 amountOut0,\n        uint256 amountOut1,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interface/IPairERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\ninterface IPairERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}"
    },
    "contracts/interface/IPairFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\ninterface IPairFactory {\n    //1: volatile pair, 2: stable pair, 3: yeild pair\n    struct PairParams {\n        address _impl;\n        bool _auth;\n    }\n\n    function allPairsLength() external view returns (uint256);\n\n    function isPair(address pair) external view returns (bool);\n\n    function createPair(\n        address[] memory _tokens,\n        uint8 _pairType,\n        bytes memory data\n    ) external returns (address pair);\n\n    function manager() external view returns (address);\n\n    function getPairAddress(address[] memory _tokens, uint8 _type) external view returns (address);\n\n    function pairTypeValues() external view returns (address[] memory);\n\n    function atPairType(uint256 _index) external view returns (address);\n\n}\n"
    },
    "contracts/interface/IPairRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\ninterface IPairRouter {\n    struct Route {\n        address from;\n        address to;\n        address pair;\n    }\n\n    function quoteAddLiquidity(address[] memory _tokens, uint256[] memory _amountDesireds)\n        external\n        view\n        returns (uint256[] memory _amountIn, uint256 liquidity);\n\n    function quoteRemoveLiquidity(address[] memory _tokens, uint256 _liquidity) external view returns (uint256[] memory _amounts);\n\n    function addLiquidity(\n        address[] memory _tokens,\n        uint256[] memory _amountDesireds,\n        uint256[] memory _amountsMin,\n        uint256 _minLiquidity,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256[] memory _amounts, uint256 _liquidity);\n\n    function addLiquidityETH(\n        address[] memory _tokens,\n        uint256[] memory _amountDesireds,\n        uint256[] memory _amountMins,\n        address _to,\n        uint256 _deadline\n    ) external payable returns (uint256[] memory _amounts, uint256 _liquidity);\n\n    function removeLiquidity(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256[] memory _amounts);\n\n    function removeLiquidityETH(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256[] memory _returns);\n\n    function removeLiquidityWithPermit(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256[] memory _amounts);\n\n    function removeLiquidityETHWithPermit(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256[] memory);\n\n    function swap(\n        Route memory _route,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 _amountOut);\n}\n\ninterface IStablPairRouter is IPairRouter {\n    function quoteRemoveLiquidityOneToken(\n        address[] calldata _tokens,\n        address _token,\n        uint256 _liquidity\n    ) external view returns (uint256 _amount);\n\n    function quoteRemoveLiquidityImbalance(address[] calldata _tokens, uint256[] calldata _amounts) external view returns (uint256 _liquidity);\n\n    function removeLiquidityOneToken(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        address _token,\n        uint256 _minAmount,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 _amount);\n\n    function removeLiquidityImbalance(\n        address[] memory _tokens,\n        uint256[] calldata _amounts,\n        uint256 _maxBurnAmount,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 _amount);\n}\n"
    },
    "contracts/interface/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/// @title Interface for WETH9\ninterface IWETH {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n\n    function transfer(address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/lib/PairERC20.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"../interface/IPairERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nabstract contract PairERC20 is IPairERC20 {\n    using SafeMath for uint256;\n\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public nonces;\n\n    constructor() {\n        uint256 chainId = block.chainid;\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"), keccak256(bytes(name)), keccak256(bytes(\"1\")), chainId, address(this))\n        );\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal virtual {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"PairERC20: EXPIRED\");\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))));\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"PairERC20: INVALID_SIGNATURE\");\n        _approve(owner, spender, value);\n    }\n\n    function _setNameAndSymbol(string memory _name, string memory _symbol) internal {\n        name = _name;\n        symbol = _symbol;\n    }\n}\n"
    },
    "contracts/Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./interface/IWETH.sol\";\nimport \"./interface/IPair.sol\";\nimport \"./interface/IPairRouter.sol\";\nimport \"./interface/IPairERC20.sol\";\nimport \"./interface/IPairFactory.sol\";\n\nimport \"./utils/Arrays.sol\";\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract Router is Initializable {\n    using Arrays for address[];\n    using Address for address;\n\n    struct Route {\n        address from;\n        address to;\n        address pair;\n    }\n\n    address public factory;\n    IWETH public weth;\n    mapping(uint8 => address) public pairTypes;\n\n    event SetPairTypes(uint8 pairType, address router);\n\n    modifier onlyManager() {\n        require(msg.sender == IPairFactory(factory).manager(), \"not manager\");\n        _;\n    }\n\n    function initialize(address _factory, address _weth) public initializer {\n        factory = _factory;\n        weth = IWETH(_weth);\n    }\n\n    constructor(address _factory, address _weth) {\n        initialize(_factory, _weth);\n    }\n\n    function setPairTypes(uint8 _pairType, address _router) external onlyManager {\n        pairTypes[_pairType] = _router;\n        emit SetPairTypes(_pairType, _router);\n    }\n\n    function quoteAddLiquidity(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256[] memory _amountDesireds\n    ) external view returns (uint256[] memory _amountIn, uint256 liquidity) {\n        address _router = pairTypes[_pairType];\n        bytes memory _returns = _router.functionStaticCall(\n            abi.encodeWithSelector(IPairRouter.quoteAddLiquidity.selector, _tokens, _amountDesireds)\n        );\n        (_amountIn, liquidity) = abi.decode(_returns, (uint256[], uint256));\n    }\n\n    function quoteRemoveLiquidity(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256 _liquidity\n    ) external view returns (uint256[] memory _amounts) {\n        address _router = pairTypes[_pairType];\n        bytes memory _returns = _router.functionStaticCall(\n            abi.encodeWithSelector(IPairRouter.quoteRemoveLiquidity.selector, _tokens, _liquidity)\n        );\n        _amounts = abi.decode(_returns, (uint256[]));\n    }\n\n    function addLiquidity(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256[] memory _amountDesireds,\n        uint256[] memory _amountsMin,\n        uint256 _minLiquidity,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256[] memory _amounts, uint256 _liquidity) {\n        address _router = pairTypes[_pairType];\n        bytes memory _returns = _router.functionDelegateCall(\n            abi.encodeWithSelector(IPairRouter.addLiquidity.selector, _tokens, _amountDesireds, _amountsMin, _minLiquidity, _to, _deadline)\n        );\n        (_amounts, _liquidity) = abi.decode(_returns, (uint256[], uint256));\n    }\n\n    function removeLiquidity(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256[] memory _amounts) {\n        address _router = pairTypes[_pairType];\n        bytes memory _returns = _router.functionDelegateCall(\n            abi.encodeWithSelector(IPairRouter.removeLiquidity.selector, _tokens, _liquidity, _amountsMin, _to, _deadline)\n        );\n        _amounts = abi.decode(_returns, (uint256[]));\n    }\n\n    function removeLiquidityETH(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256[] memory _amounts) {\n        address _router = pairTypes[_pairType];\n        bytes memory _returns = _router.functionDelegateCall(\n            abi.encodeWithSelector(IPairRouter.removeLiquidityETH.selector, _tokens, _liquidity, _amountsMin, _to, _deadline)\n        );\n        _amounts = abi.decode(_returns, (uint256[]));\n    }\n\n    function removeLiquidityWithPermit(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256[] memory _amounts) {\n        address _router = pairTypes[_pairType];\n        bytes memory _returns = _router.functionDelegateCall(\n            abi.encodeWithSelector(\n                IPairRouter.removeLiquidityWithPermit.selector,\n                _tokens,\n                _liquidity,\n                _amountsMin,\n                _to,\n                _deadline,\n                _approveMax,\n                _v,\n                _r,\n                _s\n            )\n        );\n        _amounts = abi.decode(_returns, (uint256[]));\n    }\n\n    function removeLiquidityETHWithPermit(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256[] memory _amounts) {\n        address _router = pairTypes[_pairType];\n        bytes memory _returns = _router.functionDelegateCall(\n            abi.encodeWithSelector(\n                IPairRouter.removeLiquidityETHWithPermit.selector,\n                _tokens,\n                _liquidity,\n                _amountsMin,\n                _to,\n                _deadline,\n                _approveMax,\n                _v,\n                _r,\n                _s\n            )\n        );\n        _amounts = abi.decode(_returns, (uint256[]));\n    }\n\n    function quoteRemoveLiquidityOneToken(\n        uint8 _pairType,\n        address[] calldata _tokens,\n        address _token,\n        uint256 _liquidity\n    ) external view returns (uint256 _amount) {\n        address _router = pairTypes[_pairType];\n        bytes memory _returns = _router.functionStaticCall(\n            abi.encodeWithSelector(IStablPairRouter.quoteRemoveLiquidityOneToken.selector, _tokens, _token, _liquidity)\n        );\n        _amount = abi.decode(_returns, (uint256));\n    }\n\n    function quoteRemoveLiquidityImbalance(\n        uint8 _pairType,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external view returns (uint256 _amount) {\n        address _router = pairTypes[_pairType];\n        bytes memory _returns = _router.functionStaticCall(\n            abi.encodeWithSelector(IStablPairRouter.quoteRemoveLiquidityImbalance.selector, _tokens, _amounts)\n        );\n        _amount = abi.decode(_returns, (uint256));\n    }\n\n    function removeLiquidityOneToken(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256 _liquidity,\n        address _token,\n        uint256 _minAmount,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 _amount) {\n        address _router = pairTypes[_pairType];\n        bytes memory _returns = _router.functionDelegateCall(\n            abi.encodeWithSelector(\n                IStablPairRouter.removeLiquidityOneToken.selector,\n                _tokens,\n                _liquidity,\n                _token,\n                _minAmount,\n                _to,\n                _deadline\n            )\n        );\n        _amount = abi.decode(_returns, (uint256));\n    }\n\n    function removeLiquidityImbalance(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256[] calldata _amounts,\n        uint256 _maxBurnAmount,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 _amount) {\n        address _router = pairTypes[_pairType];\n        bytes memory _returns = _router.functionDelegateCall(\n            abi.encodeWithSelector(IStablPairRouter.removeLiquidityImbalance.selector, _tokens, _amounts, _maxBurnAmount, _to, _deadline)\n        );\n        _amount = abi.decode(_returns, (uint256));\n    }\n\n    function swap(\n        Route[] memory _routes,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 _amountOut) {\n        for (uint i = 0; i < _routes.length; i++) {\n            uint8 _pairType = IPair(_routes[i].pair).PAIR_TYPE();\n            address _router = pairTypes[_pairType];\n            bytes memory _returns = _router.functionDelegateCall(\n                abi.encodeWithSelector(IPairRouter.swap.selector, _routes[i], _amountIn, _amountOutMin, _to, _deadline)\n            );\n            _amountIn = abi.decode(_returns, (uint256));\n        }\n        _amountOut = _amountIn;\n    }\n\n    function getAmountsOut(uint256 _amountIn, Route[] memory _routes) public view returns (uint256 _amountsOut) {\n        require(_routes.length >= 1, \"Router: INVALID_PATH\");\n        _amountsOut = _amountIn;\n        for (uint256 i = 0; i < _routes.length; i++) {\n            _amountsOut = IPair(_routes[i].pair).getAmountOut(_routes[i].from, _routes[i].to, _amountsOut);\n        }\n    }\n\n    function pairFor(address[] memory _tokens, uint8 _type) external view returns (address _pair, bool _has) {\n        _pair = IPairFactory(factory).getPairAddress(_tokens, _type);\n        _has = IPairFactory(factory).isPair(_pair);\n    }\n\n    receive() external payable {\n        assert(msg.sender == address(weth)); // only accept ETH via fallback from the WETH contract\n    }\n}\n"
    },
    "contracts/routers/VolatileRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"../interface/IPair.sol\";\nimport \"../interface/IWETH.sol\";\nimport \"../interface/IPairRouter.sol\";\nimport \"../interface/IPairFactory.sol\";\nimport \"../interface/IPairERC20.sol\";\nimport \"../utils/Arrays.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\ncontract VolatileRouter is IPairRouter {\n    using Arrays for address[];\n\n    uint8 public constant PAIR_TYPE = 1;\n    uint256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n\n    address public immutable factory;\n    IWETH public immutable weth;\n\n    modifier ensure(uint256 _deadline) {\n        require(_deadline >= block.timestamp, \"Router: EXPIRED\");\n        _;\n    }\n\n    constructor(address _factory, address _weth) {\n        factory = _factory;\n        weth = IWETH(_weth);\n    }\n\n    function quoteAddLiquidity(\n        address[] memory _tokens,\n        uint256[] memory _amountDesireds\n    ) external view override returns (uint256[] memory _amountIn, uint256 liquidity) {\n        // create the pair if it doesn't exist yet\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\n        if (!IPairFactory(factory).isPair(_pair)) {\n            return (_amountIn, liquidity);\n        }\n        (uint256 reserveA, uint256 reserveB) = (0, 0);\n        uint256 _totalSupply = 0;\n        if (_pair != address(0)) {\n            _totalSupply = IPairERC20(_pair).totalSupply();\n            (reserveA, reserveB) = getReserves(_pair, _tokens[0], _tokens[1]);\n        }\n        (uint256 amountA, uint256 amountB) = (0, 0);\n        (uint256 amountADesired, uint256 amountBDesired) = (_amountDesireds[0], _amountDesireds[1]);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n            liquidity = Math.sqrt(amountA * amountB) - MINIMUM_LIQUIDITY;\n        } else {\n            uint256 amountBOptimal = _quoteLiquidity(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n                liquidity = Math.min((amountA * _totalSupply) / reserveA, (amountB * _totalSupply) / reserveB);\n            } else {\n                uint256 amountAOptimal = _quoteLiquidity(amountBDesired, reserveB, reserveA);\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n                liquidity = Math.min((amountA * _totalSupply) / reserveA, (amountB * _totalSupply) / reserveB);\n            }\n        }\n        _amountIn = new uint256[](2);\n        (_amountIn[0], _amountIn[1]) = (amountA, amountB);\n    }\n\n    function quoteRemoveLiquidity(address[] memory _tokens, uint256 _liquidity) external view override returns (uint256[] memory _amounts) {\n        // create the pair if it doesn't exist yet\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\n\n        if (!IPairFactory(factory).isPair(_pair)) {\n            return _amounts;\n        }\n\n        (uint256 _reserveA, uint256 _reserveB) = getReserves(_pair, _tokens[0], _tokens[1]);\n        uint256 _totalSupply = IPairERC20(_pair).totalSupply();\n\n        _amounts = new uint256[](2);\n\n        _amounts[0] = (_liquidity * _reserveA) / _totalSupply; // using balances ensures pro-rata distribution\n        _amounts[1] = (_liquidity * _reserveB) / _totalSupply; // using balances ensures pro-rata distribution\n    }\n\n    function addLiquidity(\n        address[] memory _tokens,\n        uint256[] memory _amountDesireds,\n        uint256[] memory _amountsMin,\n        uint256 _minLiquidity,\n        address _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) returns (uint256[] memory _amounts, uint256 _liquidity) {\n        _amounts = _amountDesireds;\n        (_amounts[0], _amounts[1]) = _addLiquidity(\n            _tokens[0],\n            _tokens[1],\n            _amountDesireds[0],\n            _amountDesireds[1],\n            _amountsMin[0],\n            _amountsMin[1]\n        );\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _safeTransferFrom(_tokens[i], msg.sender, _pair, _amounts[i]);\n        }\n        _liquidity = IVolatilePair(_pair).mint(_to);\n        require(_liquidity >= _minLiquidity, \"Couldn't mint min requested\");\n    }\n\n    function _addLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin\n    ) internal returns (uint256 _amountA, uint256 _amountB) {\n        require(_amountADesired >= _amountAMin);\n        require(_amountBDesired >= _amountBMin);\n        // create the pair if it doesn't exist yet\n        (uint256 _reserveA, uint256 _reserveB) = (0, 0);\n        address _pair = getPair(_tokenA, _tokenB);\n        if (!IPairFactory(factory).isPair(_pair)) {\n            address[] memory _tokens = new address[](2);\n            _tokens[0] = _tokenA;\n            _tokens[1] = _tokenB;\n            _pair = IPairFactory(factory).createPair(_tokens, PAIR_TYPE, new bytes(0));\n        } else {\n            (_reserveA, _reserveB) = getReserves(_pair, _tokenA, _tokenB);\n        }\n\n        require(_pair != address(0), \"Router: not have this pair\");\n        if (_reserveA == 0 && _reserveB == 0) {\n            (_amountA, _amountB) = (_amountADesired, _amountBDesired);\n        } else {\n            uint256 _amountBOptimal = _quoteLiquidity(_amountADesired, _reserveA, _reserveB);\n            if (_amountBOptimal <= _amountBDesired) {\n                require(_amountBOptimal >= _amountBMin, \"Router: INSUFFICIENT_B_AMOUNT\");\n                (_amountA, _amountB) = (_amountADesired, _amountBOptimal);\n            } else {\n                uint256 _amountAOptimal = _quoteLiquidity(_amountBDesired, _reserveB, _reserveA);\n                assert(_amountAOptimal <= _amountADesired);\n                require(_amountAOptimal >= _amountAMin, \"Router: INSUFFICIENT_A_AMOUNT\");\n                (_amountA, _amountB) = (_amountAOptimal, _amountBDesired);\n            }\n        }\n    }\n\n    /// @param _tokens only other token\n    /// @param _amountDesireds only other token\n    /// @param _amountMins 0: other token, 1: weth\n    /// @return _amounts 0: other token, 1: weth\n    function addLiquidityETH(\n        address[] memory _tokens,\n        uint256[] memory _amountDesireds,\n        uint256[] memory _amountMins,\n        address _to,\n        uint256 _deadline\n    ) external payable override ensure(_deadline) returns (uint256[] memory _amounts, uint256 _liquidity) {\n        _amounts = new uint256[](2);\n        (_amounts[0], _amounts[1]) = _addLiquidity(\n            _tokens[0],\n            address(weth),\n            _amountDesireds[0],\n            msg.value,\n            _amountMins[0],\n            _amountMins[1]\n        );\n        address _pair = getPair(_tokens[0], address(weth));\n        _safeTransferFrom(_tokens[0], msg.sender, _pair, _amounts[0]);\n        weth.deposit{ value: _amounts[1] }();\n        assert(weth.transfer(_pair, _amounts[1]));\n        _liquidity = IVolatilePair(_pair).mint(_to);\n        // refund dust eth, if any\n        if (msg.value > _amounts[1]) _safeTransferETH(msg.sender, msg.value - _amounts[1]);\n    }\n\n    function removeLiquidity(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline\n    ) public override ensure(_deadline) returns (uint256[] memory _amounts) {\n        return _removeLiquidity(_tokens[0], _tokens[1], _liquidity, _amountsMin, _to);\n    }\n\n    function _removeLiquidity(\n        address _token0,\n        address _token1,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to\n    ) internal returns (uint256[] memory _amounts) {\n        address _pair = getPair(_token0, _token1);\n        require(IPairFactory(factory).isPair(_pair), \"Router: pair doesn't exist\"); // send liquidity to pair\n        IPairERC20(_pair).transferFrom(msg.sender, _pair, _liquidity);\n        (uint256 _amount0, uint256 _amount1) = IVolatilePair(_pair).burn(_to);\n        _amounts = new uint256[](2);\n        (_amounts[0], _amounts[1]) = (_amount0, _amount1);\n\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            require(_amounts[i] >= _amountsMin[i], \"Router: INSUFFICIENT_A_AMOUNT\");\n        }\n    }\n\n    /// @param _tokens only other token\n    /// @param _amountsMin 0: other token amount, 1: eth amount\n    function removeLiquidityETH(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline\n    ) public override ensure(_deadline) returns (uint256[] memory _amounts) {\n        _amounts = _removeLiquidity(_tokens[0], address(weth), _liquidity, _amountsMin, address(this));\n        _safeTransfer(_tokens[0], _to, _amounts[0]);\n        weth.withdraw(_amounts[1]);\n        _safeTransferETH(_to, _amounts[1]);\n    }\n\n    function removeLiquidityWithPermit(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external override returns (uint256[] memory _amounts) {\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\n        {\n            uint256 _value = _approveMax ? type(uint256).max : _liquidity;\n            IPairERC20(_pair).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s);\n        }\n        _amounts = removeLiquidity(_tokens, _liquidity, _amountMin, _to, _deadline);\n    }\n\n    function removeLiquidityETHWithPermit(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external override returns (uint256[] memory) {\n        address _pair = getPair(_tokens[0], address(weth));\n        uint256 _value = _approveMax ? type(uint256).max : _liquidity;\n        IPairERC20(_pair).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s);\n        return removeLiquidityETH(_tokens, _liquidity, _amountsMin, _to, _deadline);\n    }\n\n    function swap(\n        Route memory _route,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address _to,\n        uint256 _deadline\n    ) external ensure(_deadline) returns (uint256 _amountOut) {\n        address[] memory _tokens = IVolatilePair(_route.pair).tokens();\n        _amountOut = IVolatilePair(_route.pair).getAmountOut(_route.from, _route.to, _amountIn);\n        require(_amountOut >= _amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n        (uint256 amount0Out, uint256 amount1Out) = _route.pair == _tokens[0] ? (uint256(0), _amountOut) : (_amountOut, uint256(0));\n\n        ///@dev The delegatecall function of the super router\n        _safeTransfer(_route.from, _route.pair, _amountIn);\n        IVolatilePair(_route.pair).swap(amount0Out, amount1Out, _to, new bytes(0));\n    }\n\n    function _swap(uint256[] memory amounts, address[] memory path, address _to) internal virtual {\n        for (uint256 i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0, ) = sortTokens(input, output);\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out) = input == token0 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n            address to = i < path.length - 2 ? getPair(output, path[i + 2]) : _to;\n            IVolatilePair(getPair(input, output)).swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    function getReserves(address _pair, address tokenA, address tokenB) public view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IVolatilePair(_pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    function sortTokens(address tokenA, address tokenB) public pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \"Router: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"Router: ZERO_ADDRESS\");\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function _quoteLiquidity(uint256 amountA, uint256 reserveA, uint256 reserveB) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"Router: INSUFFICIENT_AMOUNT\");\n        require(reserveA > 0 && reserveB > 0, \"Router: INSUFFICIENT_LIQUIDITY\");\n        amountB = (amountA * reserveB) / reserveA;\n    }\n\n    function _safeTransferFrom(address _token, address _from, address _to, uint256 _value) internal {\n        require(_token.code.length > 0);\n        (bool _success, bytes memory _data) = _token.call(abi.encodeWithSelector(IPairERC20.transferFrom.selector, _from, _to, _value));\n        require(_success && (_data.length == 0 || abi.decode(_data, (bool))));\n    }\n\n    function _safeTransferETH(address _to, uint256 _value) internal {\n        (bool _success, ) = _to.call{ value: _value }(new bytes(0));\n        require(_success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n    }\n\n    function _safeTransfer(address _token, address _to, uint256 _value) internal {\n        require(_token.code.length > 0);\n        (bool _success, bytes memory _data) = _token.call(abi.encodeWithSelector(IPairERC20.transfer.selector, _to, _value));\n        require(_success && (_data.length == 0 || abi.decode(_data, (bool))));\n    }\n\n    function getPair(address _tokenA, address _tokenB) internal view returns (address _pair) {\n        address[] memory _tokens = new address[](2);\n        _tokens[0] = _tokenA;\n        _tokens[1] = _tokenB;\n        _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\n    }\n\n    function getAmountsOut(uint256 _amountIn, Route[] memory _routes) public view returns (uint256[] memory _amounts) {\n        require(_routes.length >= 1, \"Router: INVALID_PATH\");\n        _amounts = new uint256[](_routes.length + 1);\n        _amounts[0] = _amountIn;\n        for (uint256 i = 0; i < _routes.length; i++) {\n            if (IPairFactory(factory).isPair(_routes[i].pair)) {\n                _amounts[i + 1] = IPair(_routes[i].pair).getAmountOut(_routes[i].from, _routes[i].to, _amounts[i]);\n            }\n        }\n    }\n}\n"
    },
    "contracts/StablePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./utils/SwapUtils.sol\";\nimport \"./utils/AmplificationUtils.sol\";\nimport \"./utils/ERC20Call.sol\";\nimport \"./interface/IPairERC20.sol\";\nimport \"./interface/IPairFactory.sol\";\n\n/**\n * @title Swap - A StableSwap implementation in solidity.\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\n * Users can burn pool tokens and withdraw their share of token(s).\n *\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\n * distributed to the LPs.\n *\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\n * stops the ratio of the tokens in the pool from changing.\n * Users can always withdraw their tokens via multi-asset withdraws.\n *\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\n * deployment size.\n */\ncontract StablePair is Initializable {\n    using SwapUtils for SwapUtils.Swap;\n    using AmplificationUtils for SwapUtils.Swap;\n    using ERC20Call for address;\n\n    uint8 public constant PAIR_TYPE = 2;\n    bool public constant AUTH = true;\n\n    address public factory;\n\n    uint256 private unlocked_;\n\n    // Struct storing data responsible for automatic market maker functionalities. In order to\n    // access this data, this contract uses SwapUtils library. For more details, see SwapUtils.sol\n    SwapUtils.Swap public swapStorage;\n\n    // Maps token address to an index in the pool. Used to prevent duplicate tokens in the pool.\n    // getTokenIndex function also relies on this mapping to retrieve token index.\n    mapping(address => uint8) internal tokenIndexes_;\n\n    /*** EVENTS ***/\n\n    // events replicated from SwapUtils to make the ABI easier for dumb\n    // clients\n    event TokenSwap(address indexed buyer, uint256 tokensSold, uint256 tokensBought, uint128 soldId, uint128 boughtId);\n    event AddLiquidity(address indexed provider, uint256[] tokenAmounts, uint256[] fees, uint256 invariant, uint256 lpTokenSupply);\n    event RemoveLiquidity(address indexed provider, uint256[] tokenAmounts, uint256 lpTokenSupply);\n    event RemoveLiquidityOne(\n        address indexed provider,\n        uint256 lpTokenAmount,\n        uint256 lpTokenSupply,\n        uint256 boughtId,\n        uint256 tokensBought\n    );\n    event RemoveLiquidityImbalance(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event SwapFee(address[] tokens, uint256[] swapFees);\n    event NewAdminFee(uint256 newAdminFee);\n    event NewSwapFee(uint256 newSwapFee);\n    event NewWithdrawFee(uint256 newWithdrawFee);\n    event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\n    event StopRampA(uint256 currentA, uint256 time);\n\n    function initialize(address[] calldata _tokens, bytes calldata _data) external initializer {\n        factory = msg.sender;\n        unlocked_ = 1;\n        string memory _lpTokenName = \"DForce Stable AMM - \";\n        string memory _lpTokenSymbol = \"dAMM-Stable-\";\n        string memory _separator = \"-\";\n        uint8[] memory _decimals = new uint8[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _decimals[i] = IPairERC20(_tokens[i]).decimals();\n            string memory _tokenSymbol = _tokens[i].callSymbol();\n            if (i == _tokens.length - 1) _separator = \"\";\n            _lpTokenName = string(abi.encodePacked(_lpTokenName, _tokenSymbol, _separator));\n            _lpTokenSymbol = string(abi.encodePacked(_lpTokenSymbol, _tokenSymbol, _separator));\n        }\n\n        (uint256 _swapFee, uint256 _adminFeeRate, uint256 _a, address _lpTokenTargetAddress) = abi.decode(\n            _data,\n            (uint256, uint256, uint256, address)\n        );\n        __SwapV2_init(_tokens, _decimals, _lpTokenName, _lpTokenSymbol, _a, _swapFee, _adminFeeRate, _lpTokenTargetAddress);\n    }\n\n    /**\n     * @notice Initializes this Swap contract with the given parameters.\n     * This will also clone a LPToken contract that represents users'\n     * LP positions. The owner of LPToken will be this contract - which means\n     * only this contract is allowed to mint/burn tokens.\n     *\n     * @param _pooledTokens an array of ERC20s this pool will accept\n     * @param _decimals the decimals to use for each pooled token,\n     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\n     * @param _lpTokenName the long-form name of the token to be deployed\n     * @param _lpTokenSymbol the short symbol for the token to be deployed\n     * @param _a the amplification coefficient * n * (n - 1). See the\n     * StableSwap paper for details\n     * @param _fee default swap fee to be initialized with\n     * @param _adminFee default adminFee to be initialized with\n     * @param _lpTokenTargetAddress the address of an existing LPToken contract to use as a target\n     */\n    function __SwapV2_init(\n        address[] memory _pooledTokens,\n        uint8[] memory _decimals,\n        string memory _lpTokenName,\n        string memory _lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address _lpTokenTargetAddress\n    ) internal virtual {\n        // Check _pooledTokens and precisions parameter\n        require(_pooledTokens.length > 1, \"_pooledTokens.length <= 1\");\n        require(_pooledTokens.length <= 32, \"_pooledTokens.length > 32\");\n        require(_pooledTokens.length == _decimals.length, \"_pooledTokens decimals mismatch\");\n\n        uint256[] memory _precisionMultipliers = new uint256[](_decimals.length);\n        IERC20[] memory _poolTokens = new IERC20[](_decimals.length);\n\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\n            if (i > 0) {\n                // Check if index is already used. Check if 0th element is a duplicate.\n                require(tokenIndexes_[_pooledTokens[i]] == 0 && _pooledTokens[0] != _pooledTokens[i], \"Duplicate tokens\");\n            }\n            require(_pooledTokens[i] != address(0) && _pooledTokens[i] != address(this), \"The 0 address isn't an ERC-20\");\n            require(_decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS, \"Token decimals exceeds max\");\n            _precisionMultipliers[i] = 10 ** (uint256(SwapUtils.POOL_PRECISION_DECIMALS) - uint256(_decimals[i]));\n            _poolTokens[i] = IERC20(_pooledTokens[i]);\n            tokenIndexes_[_pooledTokens[i]] = i;\n        }\n\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\n        require(_a < AmplificationUtils.MAX_A, \"_a exceeds maximum\");\n        require(_fee < SwapUtils.MAX_SWAP_FEE, \"_fee exceeds maximum\");\n        require(_adminFee < SwapUtils.MAX_ADMIN_FEE, \"_adminFee exceeds maximum\");\n\n        // Clone and initialize a LPToken contract\n        LPToken _lpToken = LPToken(Clones.clone(_lpTokenTargetAddress));\n        require(_lpToken.initialize(_lpTokenName, _lpTokenSymbol), \"could not init lpToken clone\");\n\n        // Initialize swapStorage struct\n        swapStorage.lpToken = _lpToken;\n        swapStorage.pooledTokens = _poolTokens;\n        swapStorage.tokenPrecisionMultipliers = _precisionMultipliers;\n        swapStorage.balances = new uint256[](_pooledTokens.length);\n        swapStorage.initialA = _a * AmplificationUtils.A_PRECISION;\n        swapStorage.futureA = _a * AmplificationUtils.A_PRECISION;\n        // swapStorage.initialATime = 0;\n        // swapStorage.futureATime = 0;\n        swapStorage.swapFee = _fee;\n        swapStorage.adminFee = _adminFee;\n    }\n\n    /*** MODIFIERS ***/\n\n    /**\n     * @notice Modifier to check sender against factory manager.\n     */\n    modifier onlyManager() {\n        require(factory == msg.sender || IPairFactory(factory).manager() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @notice contract function lock modifier.\n     */\n    modifier lock() {\n        require(unlocked_ == 1, \"Pair: LOCKED\");\n        unlocked_ = 0;\n        _;\n        unlocked_ = 1;\n    }\n\n    /**\n     * @notice Modifier to check _deadline against current timestamp\n     * @param _deadline latest timestamp to accept this transaction\n     */\n    modifier deadlineCheck(uint256 _deadline) {\n        require(block.timestamp <= _deadline, \"Deadline not met\");\n        _;\n    }\n\n    /*** VIEW FUNCTIONS ***/\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @return A parameter\n     */\n    function getA() external view virtual returns (uint256) {\n        return swapStorage.getA();\n    }\n\n    /**\n     * @notice Return A in its raw precision form\n     * @dev See the StableSwap paper for details\n     * @return A parameter in its raw precision form\n     */\n    function getAPrecise() external view virtual returns (uint256) {\n        return swapStorage.getAPrecise();\n    }\n\n    /**\n     * @notice Return address of the pooled token at given index. Reverts if _tokenIndex is out of range.\n     * @param _index the index of the token\n     * @return address of the token at given index\n     */\n    function getToken(uint8 _index) public view virtual returns (address) {\n        require(_index < swapStorage.pooledTokens.length, \"Out of range\");\n        return address(swapStorage.pooledTokens[_index]);\n    }\n\n    /**\n     * @notice Query all token addresses in pair.\n     * @return all token addresses\n     */\n    function tokens() external view returns (IERC20[] memory) {\n        return swapStorage.pooledTokens;\n    }\n\n    /**\n     * @notice Query lpToken addresse.\n     * @return lpToken addresse\n     */\n    function lpToken() external view returns (address) {\n        return address(swapStorage.lpToken);\n    }\n\n    /**\n     * @notice Return the index of the given token address. Reverts if no matching\n     * token is found.\n     * @param _tokenAddress address of the token\n     * @return the index of the given token address\n     */\n    function getTokenIndex(address _tokenAddress) external view virtual returns (uint8) {\n        uint8 _index = tokenIndexes_[_tokenAddress];\n        require(getToken(_index) == _tokenAddress, \"Token does not exist\");\n        return _index;\n    }\n\n    /**\n     * @notice Return current balance of the pooled token at given index\n     * @param _index the index of the token\n     * @return current balance of the pooled token at given index with token's native precision\n     */\n    function getTokenBalance(uint8 _index) external view virtual returns (uint256) {\n        require(_index < swapStorage.pooledTokens.length, \"Index out of range\");\n        return swapStorage.balances[_index];\n    }\n\n    /**\n     * @notice Return current balances of the pooled tokens\n     * @return current balances of the pooled tokens\n     */\n    function getTokenBalances() external view virtual returns (uint256[] memory) {\n        return swapStorage.balances;\n    }\n\n    /**\n     * @notice Get the virtual price, to help calculate profit\n     * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\n     */\n    function getVirtualPrice() external view virtual returns (uint256) {\n        return swapStorage.getVirtualPrice();\n    }\n\n    /**\n     * @notice Calculate amount of tokens you receive on swap\n     * @param _tokenFrom the token address the user wants to sell\n     * @param _tokenTo the token address the user wants to buy\n     * @param _dx the amount of tokens the user wants to sell. If the token charges\n     * a fee on transfers, use the amount that gets transferred after the fee.\n     * @return amount of tokens the user will receive\n     */\n    function getAmountOut(address _tokenFrom, address _tokenTo, uint256 _dx) external view returns (uint256) {\n        return swapStorage.calculateSwap(tokenIndexes_[_tokenFrom], tokenIndexes_[_tokenTo], _dx);\n    }\n\n    /**\n     * @notice Convert the array index, according to tokenIndexes_.\n     * @param _tokens an array of all token addresses for the pair,\n     * @param _amounts an array of token amounts, corresponding to param _tokens.\n     * @return _newAmounts amount of tokens after conversion\n     */\n    function _convertIndex(address[] calldata _tokens, uint256[] calldata _amounts) internal view returns (uint256[] memory _newAmounts) {\n        _newAmounts = _amounts;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _newAmounts[tokenIndexes_[_tokens[i]]] = _amounts[i];\n        }\n    }\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param _tokens an array of all token addresses for the pair,\n     * @param _amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to param _tokens. The amount should be in each\n     * pooled token's native precision. If a token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @param _deposit whether this is a deposit or a withdrawal\n     * @return token amount the user will receive\n     */\n    function calculateTokenAmount(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts,\n        bool _deposit\n    ) external view virtual returns (uint256) {\n        return swapStorage.calculateTokenAmount(_convertIndex(_tokens, _amounts), _deposit);\n    }\n\n    /**\n     * @notice A simple method to calculate amount of each underlying\n     * tokens that is returned upon burning given amount of LP tokens\n     * @param _tokens token address list\n     * @param _amount the amount of LP tokens that would be burned on withdrawal\n     * @return array of token balances that the user will receive\n     */\n    function calculateRemoveLiquidity(address[] calldata _tokens, uint256 _amount) external view virtual returns (uint256[] memory) {\n        uint256[] memory _amounts = swapStorage.calculateRemoveLiquidity(_amount);\n        uint256[] memory _actualAmounts = _amounts;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _actualAmounts[i] = _amounts[tokenIndexes_[_tokens[i]]];\n        }\n        return _actualAmounts;\n    }\n\n    /**\n     * @notice Calculate the amount of underlying token available to withdraw\n     * when withdrawing via only single token\n     * @param _token address of tokens that will be withdrawn\n     * @param _tokenAmount the amount of LP token to burn\n     * @return calculated amount of underlying token\n     * available to withdraw\n     */\n    function calculateRemoveLiquidityOneToken(address _token, uint256 _tokenAmount) external view virtual returns (uint256) {\n        return swapStorage.calculateWithdrawOneToken(_tokenAmount, tokenIndexes_[_token]);\n    }\n\n    /**\n     * @notice This function reads the accumulated amount of admin fees of the token with given index\n     * @param _index Index of the pooled token\n     * @return admin's token balance in the token's precision\n     */\n    function getAdminBalance(uint256 _index) external view virtual returns (uint256) {\n        return swapStorage.getAdminBalance(_index);\n    }\n\n    /*** STATE MODIFYING FUNCTIONS ***/\n\n    /**\n     * @notice Calculate amount of tokens you receive on swap\n     * @param _tokenFrom the token address the user wants to sell\n     * @param _tokenTo the token address the user wants to buy\n     * @param _dx the amount of tokens the user wants to swap from\n     * @param _minDy the min amount the user would like to receive, or revert.\n     * @param _receiver recipient address\n     * @param _deadline latest timestamp to accept this transaction\n     */\n    function swap(\n        address _tokenFrom,\n        address _tokenTo,\n        uint256 _dx,\n        uint256 _minDy,\n        address _receiver,\n        uint256 _deadline\n    ) external lock deadlineCheck(_deadline) returns (uint256) {\n        return swapStorage.swap(tokenIndexes_[_tokenFrom], tokenIndexes_[_tokenTo], _dx, _minDy, _receiver);\n    }\n\n    /**\n     * @notice Add liquidity to the pool with the given amounts of tokens\n     * @param _tokens token address list\n     * @param _amounts the amounts of each token to add, in their native precision,corresponding to param _tokens\n     * @param _minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * @param _receiver recipient address\n     * @param _deadline latest timestamp to accept this transaction\n     * @return amount of LP token user minted and received\n     */\n    function addLiquidity(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts,\n        uint256 _minToMint,\n        address _receiver,\n        uint256 _deadline\n    ) external lock deadlineCheck(_deadline) returns (uint256) {\n        return swapStorage.addLiquidity(_convertIndex(_tokens, _amounts), _minToMint, _receiver);\n    }\n\n    /**\n     * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @dev Liquidity can always be removed, even when the pool is paused.\n     * @param _amount the amount of LP tokens to burn\n     * @param _tokens token address list\n     * @param _minAmounts the minimum amounts of each token in the pool\n     *        acceptable for this burn. Useful as a front-running mitigation\n     * @param _receiver recipient address\n     * @param _deadline latest timestamp to accept this transaction\n     * @return amounts of tokens user received\n     */\n    function removeLiquidity(\n        uint256 _amount,\n        address[] calldata _tokens,\n        uint256[] calldata _minAmounts,\n        address _receiver,\n        uint256 _deadline\n    ) external payable virtual lock deadlineCheck(_deadline) returns (uint256[] memory) {\n        return swapStorage.removeLiquidity(_amount, _convertIndex(_tokens, _minAmounts), _receiver);\n    }\n\n    /**\n     * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param _tokenAmount the amount of the token you want to receive\n     * @param _token address of the token you want to receive\n     * @param _minAmount the minimum amount to withdraw, otherwise revert\n     * @param _receiver recipient address\n     * @param _deadline latest timestamp to accept this transaction\n     * @return amount of chosen token user received\n     */\n    function removeLiquidityOneToken(\n        uint256 _tokenAmount,\n        address _token,\n        uint256 _minAmount,\n        address _receiver,\n        uint256 _deadline\n    ) external lock deadlineCheck(_deadline) returns (uint256) {\n        return swapStorage.removeLiquidityOneToken(_tokenAmount, tokenIndexes_[_token], _minAmount, _receiver);\n    }\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param _tokens token address list\n     * @param _amounts how much of each token to withdraw\n     * @param _maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     * @param _receiver recipient address\n     * @param _deadline latest timestamp to accept this transaction\n     * @return amount of LP tokens burned\n     */\n    function removeLiquidityImbalance(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts,\n        uint256 _maxBurnAmount,\n        address _receiver,\n        uint256 _deadline\n    ) external lock deadlineCheck(_deadline) returns (uint256) {\n        return swapStorage.removeLiquidityImbalance(_convertIndex(_tokens, _amounts), _maxBurnAmount, _receiver);\n    }\n\n    /*** ADMIN FUNCTIONS ***/\n\n    /**\n     * @notice Withdraw all admin fees to the contract factory manager\n     */\n    function claimFees() external returns (uint256[] memory) {\n        return swapStorage.withdrawAdminFees(IPairFactory(factory).manager());\n    }\n\n    /**\n     * @notice Update the admin fee. Admin fee takes portion of the swap fee.\n     * @param _newAdminFee new admin fee to be applied on future transactions\n     */\n    function setAdminFeeRate(uint256 _newAdminFee) external onlyManager {\n        swapStorage.setAdminFee(_newAdminFee);\n    }\n\n    /**\n     * @notice Update the swap fee to be applied on swaps\n     * @param _newSwapFee new swap fee to be applied on future transactions\n     */\n    function setSwapFee(uint256 _newSwapFee) external payable onlyManager {\n        swapStorage.setSwapFee(_newSwapFee);\n    }\n\n    /**\n     * @notice Start ramping up or down A parameter towards given futureA and futureTime\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\n     * the limit range.\n     * @param _futureA the new A to ramp towards\n     * @param _futureTime timestamp when the new A should be reached\n     */\n    function rampA(uint256 _futureA, uint256 _futureTime) external payable onlyManager {\n        swapStorage.rampA(_futureA, _futureTime);\n    }\n\n    /**\n     * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\n     */\n    function stopRampA() external payable onlyManager {\n        swapStorage.stopRampA();\n    }\n}\n"
    },
    "contracts/test/Create2Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"../VolatilePair.sol\";\n\ncontract Create2Test {\n    function getCreate2Address(\n        address _factory,\n        address[] memory _tokens,\n        bool _stable,\n        uint256 _fee\n    ) public pure returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(_tokens, _stable, _fee));\n\n        return address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), _factory, salt, keccak256(abi.encodePacked(type(VolatilePair).creationCode)))))));\n    }\n}\n"
    },
    "contracts/utils/AmplificationUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./SwapUtils.sol\";\n\n/**\n * @title AmplificationUtils library\n * @notice A library to calculate and ramp the A parameter of a given `SwapUtils.Swap` struct.\n * This library assumes the struct is fully validated.\n */\nlibrary AmplificationUtils {\n    event RampA(\n        uint256 oldA,\n        uint256 newA,\n        uint256 initialTime,\n        uint256 futureTime\n    );\n    event StopRampA(uint256 currentA, uint256 time);\n\n    // Constant values used in ramping A calculations\n    uint256 internal constant A_PRECISION = 100;\n    uint256 internal constant MAX_A = 10**6;\n    uint256 private constant MAX_A_CHANGE = 2;\n    uint256 private constant MIN_RAMP_TIME = 14 days;\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter\n     */\n    function getA(SwapUtils.Swap storage self)\n        internal\n        view\n        returns (uint256)\n    {\n        return (_getAPrecise(self) / A_PRECISION);\n    }\n\n    /**\n     * @notice Return A in its raw precision\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter in its raw precision form\n     */\n    function getAPrecise(SwapUtils.Swap storage self)\n        internal\n        view\n        returns (uint256)\n    {\n        return _getAPrecise(self);\n    }\n\n    /**\n     * @notice Return A in its raw precision\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter in its raw precision form\n     */\n    function _getAPrecise(SwapUtils.Swap storage self)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 t1 = self.futureATime; // time when ramp is finished\n        uint256 a1 = self.futureA; // final A value when ramp is finished\n\n        if (block.timestamp < t1) {\n            uint256 t0 = self.initialATime; // time when ramp is started\n            uint256 a0 = self.initialA; // initial A value when ramp is started\n            if (a1 > a0) {\n                // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\n                return a0 + (((a1 - a0) * (block.timestamp - t0)) / (t1 - t0));\n            } else {\n                // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\n                return a0 - (((a0 - a1) * (block.timestamp - t0)) / (t1 - t0));\n            }\n        } else {\n            return a1;\n        }\n    }\n\n    /**\n     * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\n     * the limit range.\n     * @param self Swap struct to update\n     * @param futureA_ the new A to ramp towards\n     * @param futureTime_ timestamp when the new A should be reached\n     */\n    function rampA(\n        SwapUtils.Swap storage self,\n        uint256 futureA_,\n        uint256 futureTime_\n    ) internal {\n        require(\n            block.timestamp >= (self.initialATime + (1 days)),\n            \"Wait 1 day before starting ramp\"\n        );\n        require(\n            futureTime_ >= (block.timestamp + MIN_RAMP_TIME),\n            \"Insufficient ramp time\"\n        );\n        require(\n            futureA_ > 0 && futureA_ < MAX_A,\n            \"futureA_ must be > 0 and < MAX_A\"\n        );\n\n        uint256 initialAPrecise = _getAPrecise(self);\n        uint256 futureAPrecise = futureA_ * A_PRECISION;\n\n        if (futureAPrecise < initialAPrecise) {\n            require(\n                (futureAPrecise * MAX_A_CHANGE) >= initialAPrecise,\n                \"futureA_ is too small\"\n            );\n        } else {\n            require(\n                futureAPrecise <= (initialAPrecise * MAX_A_CHANGE),\n                \"futureA_ is too large\"\n            );\n        }\n\n        self.initialA = initialAPrecise;\n        self.futureA = futureAPrecise;\n        self.initialATime = block.timestamp;\n        self.futureATime = futureTime_;\n\n        emit RampA(\n            initialAPrecise,\n            futureAPrecise,\n            block.timestamp,\n            futureTime_\n        );\n    }\n\n    /**\n     * @notice Stops ramping A immediately. Once this function is called, rampA()\n     * cannot be called for another 24 hours\n     * @param self Swap struct to update\n     */\n    function stopRampA(SwapUtils.Swap storage self) internal {\n        require(self.futureATime > block.timestamp, \"Ramp is already stopped\");\n\n        uint256 currentA = _getAPrecise(self);\n        self.initialA = currentA;\n        self.futureA = currentA;\n        self.initialATime = block.timestamp;\n        self.futureATime = block.timestamp;\n\n        emit StopRampA(currentA, block.timestamp);\n    }\n}\n"
    },
    "contracts/utils/Arrays.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nlibrary Arrays {\n    function sortArray(address[] memory arr) internal pure returns (address[] memory) {\n        uint256 l = arr.length;\n        for (uint256 i = 0; i < l; i++) {\n            for (uint256 j = i + 1; j < l; j++) {\n                if (arr[i] > arr[j]) {\n                    address temp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n        return arr;\n    }\n\n    function copyAndAddOne(address[] memory arr, address _add) internal pure returns (address[] memory _result) {\n        _result = new address[](arr.length + 1);\n        for (uint256 i = 0; i < arr.length; i++) {\n            _result[i] = arr[i];\n        }\n        _result[arr.length] = _add;\n    }\n\n    function removeEmpty(address[] memory arr) internal pure returns (address[] memory _new) {\n        uint256 count;\n        for (uint256 i = 0; i < arr.length; i++) {\n            if (arr[i] != address(0)) {\n                count++;\n            }\n        }\n        _new = new address[](count);\n        uint256 j;\n        for (uint256 i = 0; i < arr.length; i++) {\n            if (arr[i] == address(0)) {\n                continue;\n            }\n            _new[j] = arr[i];\n            j++;\n        }\n    }\n}\n"
    },
    "contracts/utils/ERC20Call.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nlibrary ERC20Call {\n    function callSymbol(\n        address _token\n    ) internal view returns (string memory _symbol) {\n        if (_token != address(0)) {\n            (bool _success, bytes memory _res) = _token.staticcall(\n                abi.encodeWithSignature(\"symbol()\")\n            );\n            if (_success)\n                _symbol = _res.length == 32\n                    ? bytes32ToString(abi.decode(_res, (bytes32)))\n                    : abi.decode(_res, (string));\n        }\n    }\n\n    function bytes32ToString(\n        bytes32 _bytes32\n    ) internal pure returns (string memory _result) {\n        uint8 _length = 0;\n        while (_bytes32[_length] != 0 && _length < 32) {\n            _length++;\n        }\n        assembly {\n            _result := mload(0x40)\n            // new \"memory end\" including padding (the string isn't larger than 32 bytes)\n            mstore(0x40, add(_result, 0x40))\n            // store length in memory\n            mstore(_result, _length)\n            // write actual data\n            mstore(add(_result, 0x20), _bytes32)\n        }\n    }\n}\n"
    },
    "contracts/utils/LPToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// import \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../lib/PairERC20.sol\";\n\n/**\n * @title Liquidity Provider Token\n * @notice This token is an ERC20 detailed token with added capability to be minted by the owner.\n * It is used to represent user's shares when providing liquidity to swap contracts.\n * @dev Only Swap contracts should initialize and own LPToken contracts.\n */\ncontract LPToken is OwnableUpgradeable, PairERC20 {\n    /**\n     * @notice Initializes this LPToken contract with the given name and symbol\n     * @dev The caller of this function will become the owner. A Swap contract should call this\n     * in its initializer function.\n     * @param name name of this token\n     * @param symbol symbol of this token\n     */\n    function initialize(string memory name, string memory symbol)\n        external\n        initializer\n        returns (bool)\n    {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        _setNameAndSymbol(name, symbol);\n        return true;\n    }\n\n    modifier addressCheck(address recipient) {\n        require(recipient != address(this), \"LPToken: cannot send to itself\");\n        _;\n    }\n\n    /**\n     * @notice Mints the given amount of LPToken to the recipient.\n     * @dev only owner can call this mint function\n     * @param recipient address of account to receive the tokens\n     * @param amount amount of tokens to mint\n     */\n    function mint(address recipient, uint256 amount) external onlyOwner addressCheck(recipient) {\n        require(amount != 0, \"LPToken: cannot mint 0\");\n        _mint(recipient, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal override addressCheck(to) {\n        super._transfer(from, to, value);\n    }\n\n    function burnFrom(address from, uint256 value) external {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] = allowance[from][msg.sender] - value;\n        }\n        _burn(from, value);\n    }\n}\n"
    },
    "contracts/utils/MathUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title MathUtils library\n * @notice A library to be used in conjunction with SafeMath. Contains functions for calculating\n * differences between two uint256.\n */\nlibrary MathUtils {\n    /**\n     * @notice Compares a and b and returns true if the difference between a and b\n     *         is less than 1 or equal to each other.\n     * @param a uint256 to compare with\n     * @param b uint256 to compare with\n     * @return True if the difference between a and b is less than 1 or equal,\n     *         otherwise return false\n     */\n    function within1(uint256 a, uint256 b) internal pure returns (bool) {\n        return (difference(a, b) <= 1);\n    }\n\n    /**\n     * @notice Calculates absolute difference between a and b\n     * @param a uint256 to compare with\n     * @param b uint256 to compare with\n     * @return Difference between a and b\n     */\n    function difference(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a > b) {\n            return a - b;\n        }\n        return b - a;\n    }\n}\n"
    },
    "contracts/utils/SwapUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./AmplificationUtils.sol\";\nimport \"./LPToken.sol\";\nimport \"./MathUtils.sol\";\n\n/**\n * @title SwapUtils library\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\n * Admin functions should be protected within contracts using this library.\n */\nlibrary SwapUtils {\n    using SafeERC20 for IERC20;\n    using MathUtils for uint256;\n\n    /*** EVENTS ***/\n\n    event TokenSwap(\n        address indexed buyer,\n        uint256 tokensSold,\n        uint256 tokensBought,\n        uint128 soldId,\n        uint128 boughtId\n    );\n    event AddLiquidity(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidity(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidityOne(\n        address indexed provider,\n        uint256 lpTokenAmount,\n        uint256 lpTokenSupply,\n        uint256 boughtId,\n        uint256 tokensBought\n    );\n    event RemoveLiquidityImbalance(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n\n    event SwapFee(address[] tokens, uint256[] swapFees);\n    event NewAdminFee(uint256 newAdminFee);\n    event NewSwapFee(uint256 newSwapFee);\n\n    struct Swap {\n        // variables around the ramp management of A,\n        // the amplification coefficient * n * (n - 1)\n        // see https://www.curve.fi/stableswap-paper.pdf for details\n        uint256 initialA;\n        uint256 futureA;\n        uint256 initialATime;\n        uint256 futureATime;\n        // fee calculation\n        uint256 swapFee;\n        uint256 adminFee;\n        LPToken lpToken;\n        // contract references for all tokens being pooled\n        IERC20[] pooledTokens;\n        // multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS\n        // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\n        // has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10\n        uint256[] tokenPrecisionMultipliers;\n        // the pool balance of each token, in the token's precision\n        // the contract's actual token balance might differ\n        uint256[] balances;\n    }\n\n    // Struct storing variables used in calculations in the\n    // calculateWithdrawOneTokenDY function to avoid stack too deep errors\n    struct CalculateWithdrawOneTokenDYInfo {\n        uint256 d0;\n        uint256 d1;\n        uint256 newY;\n        uint256 feePerToken;\n        uint256 preciseA;\n    }\n\n    // Struct storing variables used in calculations in the\n    // {add,remove}Liquidity functions to avoid stack too deep errors\n    struct ManageLiquidityInfo {\n        uint256 d0;\n        uint256 d1;\n        uint256 d2;\n        uint256 preciseA;\n        LPToken lpToken;\n        uint256 totalSupply;\n        uint256[] balances;\n        uint256[] multipliers;\n    }\n\n    struct SwapFeeInfo {\n        uint256 adminFee;\n        address[] tokens;\n        uint256[] swapFees;\n    }\n\n    // the precision all pools tokens will be converted to\n    uint8 public constant POOL_PRECISION_DECIMALS = 18;\n\n    // the denominator used to calculate admin and LP fees. For example, an\n    // LP fee might be something like tradeAmount * (fee) / (FEE_DENOMINATOR)\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n\n    // Max swap fee is 1% or 100bps of each swap\n    uint256 public constant MAX_SWAP_FEE = 10**8;\n\n    // Max adminFee is 100% of the swapFee\n    // adminFee does not add additional fee on top of swapFee\n    // Instead it takes a certain % of the swapFee. Therefore it has no impact on the\n    // users but only on the earnings of LPs\n    uint256 public constant MAX_ADMIN_FEE = 10**10;\n\n    // Constant value used as max loop limit\n    uint256 private constant MAX_LOOP_LIMIT = 256;\n\n    /*** VIEW & PURE FUNCTIONS ***/\n\n    function _getAPrecise(Swap storage self) internal view returns (uint256) {\n        return AmplificationUtils._getAPrecise(self);\n    }\n\n    /**\n     * @notice Calculate the dy, the amount of selected token that user receives and\n     * the fee of withdrawing in one token\n     * @param tokenAmount the amount to withdraw in the pool's precision\n     * @param tokenIndex which token will be withdrawn\n     * @param self Swap struct to read from\n     * @return the amount of token user will receive\n     */\n    function calculateWithdrawOneToken(\n        Swap storage self,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256) {\n        (uint256 availableTokenAmount, ) = _calculateWithdrawOneToken(\n            self,\n            tokenAmount,\n            tokenIndex,\n            self.lpToken.totalSupply()\n        );\n        return availableTokenAmount;\n    }\n\n    function _calculateWithdrawOneToken(\n        Swap storage self,\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 totalSupply\n    ) internal view returns (uint256, uint256) {\n        uint256 dy;\n        uint256 newY;\n        uint256 currentY;\n\n        (dy, newY, currentY) = calculateWithdrawOneTokenDY(\n            self,\n            tokenIndex,\n            tokenAmount,\n            totalSupply\n        );\n\n        // dy_0 (without fees)\n        // dy, dy_0 - dy\n\n        uint256 dySwapFee = ((currentY - newY) /\n            self.tokenPrecisionMultipliers[tokenIndex]) - dy;\n\n        return (dy, dySwapFee);\n    }\n\n    /**\n     * @notice Calculate the dy of withdrawing in one token\n     * @param self Swap struct to read from\n     * @param tokenIndex which token will be withdrawn\n     * @param tokenAmount the amount to withdraw in the pools precision\n     * @return the d and the new y after withdrawing one token\n     */\n    function calculateWithdrawOneTokenDY(\n        Swap storage self,\n        uint8 tokenIndex,\n        uint256 tokenAmount,\n        uint256 totalSupply\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        // Get the current D, then solve the stableswap invariant\n        // y_i for D - tokenAmount\n        uint256[] memory xp = _xp(self);\n\n        require(tokenIndex < xp.length, \"Token index out of range\");\n\n        CalculateWithdrawOneTokenDYInfo\n            memory v = CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\n        v.preciseA = _getAPrecise(self);\n        v.d0 = getD(xp, v.preciseA);\n        v.d1 = v.d0 - ((tokenAmount * v.d0) / totalSupply);\n\n        require(tokenAmount <= xp[tokenIndex], \"Withdraw exceeds available\");\n\n        v.newY = getYD(v.preciseA, tokenIndex, xp, v.d1);\n\n        uint256[] memory xpReduced = new uint256[](xp.length);\n\n        v.feePerToken = _feePerToken(self.swapFee, xp.length);\n        for (uint256 i = 0; i < xp.length; i++) {\n            uint256 xpi = xp[i];\n            // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\n            // else dxExpected = xp[i] - (xp[i] * d1 / d0)\n            // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\n            xpReduced[i] =\n                xpi -\n                (((\n                    (i == tokenIndex)\n                        ? ((xpi * v.d1) / v.d0) - v.newY\n                        : xpi - ((xpi * v.d1) / v.d0)\n                ) * v.feePerToken) / FEE_DENOMINATOR);\n        }\n\n        uint256 dy = xpReduced[tokenIndex] -\n            (getYD(v.preciseA, tokenIndex, xpReduced, v.d1));\n        dy = (dy - 1) / self.tokenPrecisionMultipliers[tokenIndex];\n\n        return (dy, v.newY, xp[tokenIndex]);\n    }\n\n    /**\n     * @notice Calculate the price of a token in the pool with given\n     * precision-adjusted balances and a particular D.\n     *\n     * @dev This is accomplished via solving the invariant iteratively.\n     * See the StableSwap paper and Curve.fi implementation for further details.\n     *\n     * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n     * x_1**2 + b*x_1 = c\n     * x_1 = (x_1**2 + c) / (2*x_1 + b)\n     *\n     * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\n     * @param tokenIndex Index of token we are calculating for.\n     * @param xp a precision-adjusted set of pool balances. Array should be\n     * the same cardinality as the pool.\n     * @param d the stableswap invariant\n     * @return the price of the token, in the same precision as in xp\n     */\n    function getYD(\n        uint256 a,\n        uint8 tokenIndex,\n        uint256[] memory xp,\n        uint256 d\n    ) internal pure returns (uint256) {\n        uint256 numTokens = xp.length;\n        require(tokenIndex < numTokens, \"Token not found\");\n\n        uint256 c = d;\n        uint256 s;\n        uint256 nA = a * (numTokens);\n\n        for (uint256 i = 0; i < numTokens; i++) {\n            if (i != tokenIndex) {\n                s = s + xp[i];\n                c = (c * d) / (xp[i] * (numTokens));\n                // If we were to protect the division loss we would have to keep the denominator separate\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\n                // c = c * D * D * D * ... overflow!\n            }\n        }\n        c = (c * d * AmplificationUtils.A_PRECISION) / (nA * numTokens);\n\n        uint256 b = s + ((d * AmplificationUtils.A_PRECISION) / nA);\n        uint256 yPrev;\n        uint256 y = d;\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            yPrev = y;\n            y = ((y * y) + c) / ((y * 2) + b - d);\n            if (y.within1(yPrev)) {\n                return y;\n            }\n        }\n        revert(\"Approximation did not converge\");\n    }\n\n    /**\n     * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\n     * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\n     * as the pool.\n     * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\n     * See the StableSwap paper for details\n     * @return the invariant, at the precision of the pool\n     */\n    function getD(uint256[] memory xp, uint256 a)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 numTokens = xp.length;\n        uint256 s;\n        for (uint256 i = 0; i < numTokens; i++) {\n            s = s + xp[i];\n        }\n        if (s == 0) {\n            return 0;\n        }\n\n        uint256 prevD;\n        uint256 d = s;\n        uint256 nA = a * numTokens;\n\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            uint256 dP = d;\n            for (uint256 j = 0; j < numTokens; j++) {\n                dP = (dP * d) / (xp[j] * numTokens);\n                // If we were to protect the division loss we would have to keep the denominator separate\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\n                // dP = dP * D * D * D * ... overflow!\n            }\n            prevD = d;\n            d =\n                ((((nA * s) / AmplificationUtils.A_PRECISION) +\n                    (dP * numTokens)) * d) /\n                ((((nA - AmplificationUtils.A_PRECISION) * d) /\n                    AmplificationUtils.A_PRECISION) + ((numTokens + 1) * dP));\n            if (d.within1(prevD)) {\n                return d;\n            }\n        }\n\n        // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\n        // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\n        // function which does not rely on D.\n        revert(\"D does not converge\");\n    }\n\n    /**\n     * @notice Given a set of balances and precision multipliers, return the\n     * precision-adjusted balances.\n     *\n     * @param balances an array of token balances, in their native precisions.\n     * These should generally correspond with pooled tokens.\n     *\n     * @param precisionMultipliers an array of multipliers, corresponding to\n     * the amounts in the balances array. When multiplied together they\n     * should yield amounts at the pool's precision.\n     *\n     * @return an array of amounts \"scaled\" to the pool's precision\n     */\n    function _xp(\n        uint256[] memory balances,\n        uint256[] memory precisionMultipliers\n    ) internal pure returns (uint256[] memory) {\n        uint256 numTokens = balances.length;\n        require(\n            numTokens == precisionMultipliers.length,\n            \"Balances must match multipliers\"\n        );\n        uint256[] memory xp = new uint256[](numTokens);\n        for (uint256 i = 0; i < numTokens; i++) {\n            xp[i] = balances[i] * precisionMultipliers[i];\n        }\n        return xp;\n    }\n\n    /**\n     * @notice Return the precision-adjusted balances of all tokens in the pool\n     * @param self Swap struct to read from\n     * @return the pool balances \"scaled\" to the pool's precision, allowing\n     * them to be more easily compared.\n     */\n    function _xp(Swap storage self) internal view returns (uint256[] memory) {\n        return _xp(self.balances, self.tokenPrecisionMultipliers);\n    }\n\n    /**\n     * @notice Get the virtual price, to help calculate profit\n     * @param self Swap struct to read from\n     * @return the virtual price, scaled to precision of POOL_PRECISION_DECIMALS\n     */\n    function getVirtualPrice(Swap storage self)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 d = getD(_xp(self), _getAPrecise(self));\n        LPToken lpToken = self.lpToken;\n        uint256 supply = lpToken.totalSupply();\n        if (supply > 0) {\n            return (d * (10**uint256(POOL_PRECISION_DECIMALS))) / supply;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Calculate the new balances of the tokens given the indexes of the token\n     * that is swapped from (FROM) and the token that is swapped to (TO).\n     * This function is used as a helper function to calculate how much TO token\n     * the user should receive on swap.\n     *\n     * @param preciseA precise form of amplification coefficient\n     * @param tokenIndexFrom index of FROM token\n     * @param tokenIndexTo index of TO token\n     * @param x the new total amount of FROM token\n     * @param xp balances of the tokens in the pool\n     * @return the amount of TO token that should remain in the pool\n     */\n    function getY(\n        uint256 preciseA,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 x,\n        uint256[] memory xp\n    ) internal pure returns (uint256) {\n        uint256 numTokens = xp.length;\n        require(\n            tokenIndexFrom != tokenIndexTo,\n            \"Can't compare token to itself\"\n        );\n        require(\n            tokenIndexFrom < numTokens && tokenIndexTo < numTokens,\n            \"Tokens must be in pool\"\n        );\n\n        uint256 d = getD(xp, preciseA);\n        uint256 c = d;\n        uint256 s;\n        uint256 nA = numTokens * preciseA;\n\n        uint256 _x;\n        for (uint256 i = 0; i < numTokens; i++) {\n            if (i == tokenIndexFrom) {\n                _x = x;\n            } else if (i != tokenIndexTo) {\n                _x = xp[i];\n            } else {\n                continue;\n            }\n            s = s + _x;\n            c = (c * d) / (_x * numTokens);\n            // If we were to protect the division loss we would have to keep the denominator separate\n            // and divide at the end. However this leads to overflow with large numTokens or/and D.\n            // c = c * D * D * D * ... overflow!\n        }\n        c = (c * d * AmplificationUtils.A_PRECISION) / (nA * numTokens);\n        uint256 b = s + ((d * AmplificationUtils.A_PRECISION) / nA);\n        uint256 yPrev;\n        uint256 y = d;\n\n        // iterative approximation\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            yPrev = y;\n            y = (y * y + c) / (y * 2 + b - d);\n            if (y.within1(yPrev)) {\n                return y;\n            }\n        }\n        revert(\"Approximation did not converge\");\n    }\n\n    /**\n     * @notice Externally calculates a swap between two tokens.\n     * @param self Swap struct to read from\n     * @param tokenIndexFrom the token to sell\n     * @param tokenIndexTo the token to buy\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @return dy the number of tokens the user will get\n     */\n    function calculateSwap(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 dy) {\n        (dy, ) = _calculateSwap(\n            self,\n            tokenIndexFrom,\n            tokenIndexTo,\n            dx,\n            self.balances\n        );\n    }\n\n    /**\n     * @notice Internally calculates a swap between two tokens.\n     *\n     * @dev The caller is expected to transfer the actual amounts (dx and dy)\n     * using the token contracts.\n     *\n     * @param self Swap struct to read from\n     * @param tokenIndexFrom the token to sell\n     * @param tokenIndexTo the token to buy\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @return dy the number of tokens the user will get\n     * @return dyFee the associated fee\n     */\n    function _calculateSwap(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256[] memory balances\n    ) internal view returns (uint256 dy, uint256 dyFee) {\n        uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n        uint256[] memory xp = _xp(balances, multipliers);\n        require(\n            tokenIndexFrom < xp.length && tokenIndexTo < xp.length,\n            \"Token index out of range\"\n        );\n        uint256 x = dx * multipliers[tokenIndexFrom] + xp[tokenIndexFrom];\n        uint256 y = getY(\n            _getAPrecise(self),\n            tokenIndexFrom,\n            tokenIndexTo,\n            x,\n            xp\n        );\n        dy = xp[tokenIndexTo] - y - 1;\n        dyFee = (dy * self.swapFee) / FEE_DENOMINATOR;\n        dy = (dy - dyFee) / multipliers[tokenIndexTo];\n    }\n\n    /**\n     * @notice A simple method to calculate amount of each underlying\n     * tokens that is returned upon burning given amount of\n     * LP tokens\n     *\n     * @param amount the amount of LP tokens that would to be burned on\n     * withdrawal\n     * @return array of amounts of tokens user will receive\n     */\n    function calculateRemoveLiquidity(Swap storage self, uint256 amount)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return\n            _calculateRemoveLiquidity(\n                self.balances,\n                amount,\n                self.lpToken.totalSupply()\n            );\n    }\n\n    function _calculateRemoveLiquidity(\n        uint256[] memory balances,\n        uint256 amount,\n        uint256 totalSupply\n    ) internal pure returns (uint256[] memory) {\n        require(amount <= totalSupply, \"Cannot exceed total supply\");\n\n        uint256[] memory amounts = new uint256[](balances.length);\n\n        for (uint256 i = 0; i < balances.length; i++) {\n            amounts[i] = (balances[i] * amount) / totalSupply;\n        }\n        return amounts;\n    }\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param self Swap struct to read from\n     * @param amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to pooledTokens. The amount should be in each\n     * pooled token's native precision. If a token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @param deposit whether this is a deposit or a withdrawal\n     * @return if deposit was true, total amount of lp token that will be minted and if\n     * deposit was false, total amount of lp token that will be burned\n     */\n    function calculateTokenAmount(\n        Swap storage self,\n        uint256[] calldata amounts,\n        bool deposit\n    ) external view returns (uint256) {\n        uint256 a = _getAPrecise(self);\n        uint256[] memory balances = self.balances;\n        uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n\n        uint256 d0 = getD(_xp(balances, multipliers), a);\n        for (uint256 i = 0; i < balances.length; i++) {\n            if (deposit) {\n                balances[i] = balances[i] + amounts[i];\n            } else {\n                if (amounts[i] > balances[i]) {\n                    revert(\"Cannot withdraw more than available\");\n                } else {\n                    unchecked {\n                        balances[i] = balances[i] - amounts[i];\n                    }\n                }\n            }\n        }\n        uint256 d1 = getD(_xp(balances, multipliers), a);\n        uint256 totalSupply = self.lpToken.totalSupply();\n\n        if (deposit) {\n            return (((d1 - d0) * totalSupply) / d0);\n        } else {\n            return (((d0 - d1) * totalSupply) / d0);\n        }\n    }\n\n    /**\n     * @notice return accumulated amount of admin fees of the token with given index\n     * @param self Swap struct to read from\n     * @param index Index of the pooled token\n     * @return admin balance in the token's precision\n     */\n    function getAdminBalance(Swap storage self, uint256 index)\n        external\n        view\n        returns (uint256)\n    {\n        require(index < self.pooledTokens.length, \"Token index out of range\");\n        return\n            self.pooledTokens[index].balanceOf(address(this)) -\n            self.balances[index];\n    }\n\n    /**\n     * @notice internal helper function to calculate fee per token multiplier used in\n     * swap fee calculations\n     * @param swapFee swap fee for the tokens\n     * @param numTokens number of tokens pooled\n     */\n    function _feePerToken(uint256 swapFee, uint256 numTokens)\n        internal\n        pure\n        returns (uint256)\n    {\n        return ((swapFee * numTokens) / ((numTokens - 1) * 4));\n    }\n\n    /*** STATE MODIFYING FUNCTIONS ***/\n\n    /**\n     * @notice swap two tokens in the pool\n     * @param self Swap struct to read from and write to\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell\n     * @param minDy the min amount the user would like to receive, or revert.\n     * @param receiver recipient address\n     * @return amount of token user received on swap\n     */\n    function swap(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        address receiver\n    ) external returns (uint256) {\n        {\n            IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n            require(\n                dx <= tokenFrom.balanceOf(msg.sender),\n                \"Cannot swap more than you own\"\n            );\n            // Transfer tokens first to see if a fee was charged on transfer\n            uint256 beforeBalance = tokenFrom.balanceOf(address(this));\n            tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\n\n            // Use the actual transferred amount for AMM math\n            dx = tokenFrom.balanceOf(address(this)) - beforeBalance;\n        }\n\n        uint256 dy;\n        uint256 dyFee;\n        uint256[] memory balances = self.balances;\n        (dy, dyFee) = _calculateSwap(\n            self,\n            tokenIndexFrom,\n            tokenIndexTo,\n            dx,\n            balances\n        );\n        require(dy >= minDy, \"Swap didn't result in min tokens\");\n\n        uint256 dyAdminFee = (((dyFee * self.adminFee) / FEE_DENOMINATOR) /\n            self.tokenPrecisionMultipliers[tokenIndexTo]);\n\n        self.balances[tokenIndexFrom] = balances[tokenIndexFrom] + dx;\n        self.balances[tokenIndexTo] = balances[tokenIndexTo] - dy - dyAdminFee;\n\n        self.pooledTokens[tokenIndexTo].safeTransfer(receiver, dy);\n\n        emit TokenSwap(receiver, dx, dy, tokenIndexFrom, tokenIndexTo);\n        SwapFeeInfo memory swapFeeInfo;\n        swapFeeInfo.tokens = new address[](1);\n        swapFeeInfo.swapFees = new uint256[](1);\n        swapFeeInfo.tokens[0] = address(self.pooledTokens[tokenIndexTo]);\n        swapFeeInfo.swapFees[0] = dyFee - dyAdminFee;\n        emit SwapFee(swapFeeInfo.tokens, swapFeeInfo.swapFees);\n\n        return dy;\n    }\n\n    /**\n     * @notice Add liquidity to the pool\n     * @param self Swap struct to read from and write to\n     * @param amounts the amounts of each token to add, in their native precision\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\n     * @param receiver recipient address\n     * @return amount of LP token user received\n     */\n    function addLiquidity(\n        Swap storage self,\n        uint256[] memory amounts,\n        uint256 minToMint,\n        address receiver\n    ) external returns (uint256) {\n        IERC20[] memory pooledTokens = self.pooledTokens;\n        require(\n            amounts.length == pooledTokens.length,\n            \"Amounts must match pooled tokens\"\n        );\n\n        // current state\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\n            0,\n            0,\n            0,\n            _getAPrecise(self),\n            self.lpToken,\n            0,\n            self.balances,\n            self.tokenPrecisionMultipliers\n        );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        if (v.totalSupply != 0) {\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n        }\n\n        uint256[] memory newBalances = new uint256[](pooledTokens.length);\n\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\n            require(\n                v.totalSupply != 0 || amounts[i] > 0,\n                \"Must supply all tokens in pool\"\n            );\n\n            // Transfer tokens first to see if a fee was charged on transfer\n            if (amounts[i] != 0) {\n                uint256 beforeBalance = pooledTokens[i].balanceOf(\n                    address(this)\n                );\n                pooledTokens[i].safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amounts[i]\n                );\n\n                // Update the amounts[] with actual transfer amount\n                amounts[i] =\n                    pooledTokens[i].balanceOf(address(this)) -\n                    beforeBalance;\n            }\n\n            newBalances[i] = v.balances[i] + amounts[i];\n        }\n        // invariant after change\n        v.d1 = getD(_xp(newBalances, v.multipliers), v.preciseA);\n        require(v.d1 > v.d0, \"D should increase\");\n        // updated to reflect fees and calculate the user's LP tokens\n        v.d2 = v.d1;\n        uint256[] memory fees = new uint256[](pooledTokens.length);\n\n        if (v.totalSupply != 0) {\n            uint256 feePerToken = _feePerToken(\n                self.swapFee,\n                pooledTokens.length\n            );\n            SwapFeeInfo memory swapFeeInfo;\n            swapFeeInfo.tokens = new address[](fees.length);\n            swapFeeInfo.swapFees = new uint256[](fees.length);\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                uint256 idealBalance = (v.d1 * v.balances[i]) / v.d0;\n                fees[i] =\n                    (feePerToken * idealBalance.difference(newBalances[i])) /\n                    FEE_DENOMINATOR;\n                swapFeeInfo.adminFee = (fees[i] * self.adminFee) / FEE_DENOMINATOR;\n                self.balances[i] =\n                    newBalances[i] - swapFeeInfo.adminFee;\n                    // newBalances[i] -\n                    // ((fees[i] * self.adminFee) / FEE_DENOMINATOR);\n                newBalances[i] = newBalances[i] - fees[i];\n                swapFeeInfo.tokens[i] = address(pooledTokens[i]);\n                swapFeeInfo.swapFees[i] = fees[i] - swapFeeInfo.adminFee;\n            }\n            emit SwapFee(swapFeeInfo.tokens, swapFeeInfo.swapFees);\n            v.d2 = getD(_xp(newBalances, v.multipliers), v.preciseA);\n        } else {\n            // the initial depositor doesn't pay fees\n            self.balances = newBalances;\n        }\n\n        uint256 toMint;\n        if (v.totalSupply == 0) {\n            toMint = v.d1;\n        } else {\n            toMint = ((v.d2 - v.d0) * v.totalSupply) / v.d0;\n        }\n\n        require(toMint >= minToMint, \"Couldn't mint min requested\");\n\n        // mint the user's LP tokens\n        v.lpToken.mint(receiver, toMint);\n\n        emit AddLiquidity(\n            receiver,\n            amounts,\n            fees,\n            v.d1,\n            v.totalSupply + toMint\n        );\n\n        return toMint;\n    }\n\n    /**\n     * @notice Burn LP tokens to remove liquidity from the pool.\n     * @dev Liquidity can always be removed, even when the pool is paused.\n     * @param self Swap struct to read from and write to\n     * @param amount the amount of LP tokens to burn\n     * @param minAmounts the minimum amounts of each token in the pool\n     * acceptable for this burn. Useful as a front-running mitigation\n     * @param receiver recipient address\n     * @return amounts of tokens the user received\n     */\n    function removeLiquidity(\n        Swap storage self,\n        uint256 amount,\n        uint256[] calldata minAmounts,\n        address receiver\n    ) external returns (uint256[] memory) {\n        LPToken lpToken = self.lpToken;\n        IERC20[] memory pooledTokens = self.pooledTokens;\n        require(amount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n        require(\n            minAmounts.length == pooledTokens.length,\n            \"minAmounts must match poolTokens\"\n        );\n\n        uint256[] memory balances = self.balances;\n        uint256 totalSupply = lpToken.totalSupply();\n\n        uint256[] memory amounts = _calculateRemoveLiquidity(\n            balances,\n            amount,\n            totalSupply\n        );\n\n        for (uint256 i = 0; i < amounts.length; i++) {\n            require(amounts[i] >= minAmounts[i], \"amounts[i] < minAmounts[i]\");\n            self.balances[i] = balances[i] - amounts[i];\n            pooledTokens[i].safeTransfer(receiver, amounts[i]);\n        }\n\n        lpToken.burnFrom(msg.sender, amount);\n\n        emit RemoveLiquidity(receiver, amounts, totalSupply - amount);\n\n        return amounts;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool all in one token.\n     * @param self Swap struct to read from and write to\n     * @param tokenAmount the amount of the lp tokens to burn\n     * @param tokenIndex the index of the token you want to receive\n     * @param minAmount the minimum amount to withdraw, otherwise revert\n     * @param receiver recipient address\n     * @return amount chosen token that user received\n     */\n    function removeLiquidityOneToken(\n        Swap storage self,\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        address receiver\n    ) external returns (uint256) {\n        LPToken lpToken = self.lpToken;\n        IERC20[] memory pooledTokens = self.pooledTokens;\n\n        require(tokenAmount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n        require(tokenIndex < pooledTokens.length, \"Token not found\");\n\n        uint256 totalSupply = lpToken.totalSupply();\n\n        (uint256 dy, uint256 dyFee) = _calculateWithdrawOneToken(\n            self,\n            tokenAmount,\n            tokenIndex,\n            totalSupply\n        );\n\n        require(dy >= minAmount, \"dy < minAmount\");\n\n        uint256 dyAdminFee = (dyFee * self.adminFee) / FEE_DENOMINATOR;\n        self.balances[tokenIndex] =\n            self.balances[tokenIndex] -\n            (dy + dyAdminFee);\n            // (dy + ((dyFee * self.adminFee) / FEE_DENOMINATOR));\n        lpToken.burnFrom(msg.sender, tokenAmount);\n        pooledTokens[tokenIndex].safeTransfer(receiver, dy);\n\n        emit RemoveLiquidityOne(\n            receiver,\n            tokenAmount,\n            totalSupply,\n            tokenIndex,\n            dy\n        );\n\n        SwapFeeInfo memory swapFeeInfo;\n        swapFeeInfo.tokens = new address[](1);\n        swapFeeInfo.swapFees = new uint256[](1);\n        swapFeeInfo.tokens[0] = address(pooledTokens[tokenIndex]);\n        swapFeeInfo.swapFees[0] = dyFee - dyAdminFee;\n        emit SwapFee(swapFeeInfo.tokens, swapFeeInfo.swapFees);\n\n        return dy;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances.\n     *\n     * @param self Swap struct to read from and write to\n     * @param amounts how much of each token to withdraw\n     * @param maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     * @param receiver recipient address\n     * @return actual amount of LP tokens burned in the withdrawal\n     */\n    function removeLiquidityImbalance(\n        Swap storage self,\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount,\n        address receiver\n    ) external returns (uint256) {\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\n            0,\n            0,\n            0,\n            _getAPrecise(self),\n            self.lpToken,\n            0,\n            self.balances,\n            self.tokenPrecisionMultipliers\n        );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        IERC20[] memory pooledTokens = self.pooledTokens;\n\n        require(\n            amounts.length == pooledTokens.length,\n            \"Amounts should match pool tokens\"\n        );\n\n        require(\n            maxBurnAmount <= v.lpToken.balanceOf(msg.sender) &&\n                maxBurnAmount != 0,\n            \">LP.balanceOf\"\n        );\n\n        uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\n        uint256[] memory fees = new uint256[](pooledTokens.length);\n        {\n            uint256[] memory balances1 = new uint256[](pooledTokens.length);\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                if (amounts[i] > v.balances[i]) {\n                    revert(\"Cannot withdraw more than available\");\n                } else {\n                    unchecked {\n                        balances1[i] = v.balances[i] - amounts[i];\n                    }\n                }\n            }\n            v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\n\n            SwapFeeInfo memory swapFeeInfo;\n            swapFeeInfo.tokens = new address[](fees.length);\n            swapFeeInfo.swapFees = new uint256[](fees.length);\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                uint256 idealBalance = (v.d1 * v.balances[i]) / v.d0;\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = (feePerToken * difference) / FEE_DENOMINATOR;\n                swapFeeInfo.adminFee = (fees[i] * self.adminFee) / FEE_DENOMINATOR;\n                self.balances[i] =\n                    balances1[i] - swapFeeInfo.adminFee;\n                    // balances1[i] -\n                    // ((fees[i] * self.adminFee) / FEE_DENOMINATOR);\n                balances1[i] = balances1[i] - fees[i];\n                swapFeeInfo.tokens[i] = address(pooledTokens[i]);\n                swapFeeInfo.swapFees[i] = fees[i] - swapFeeInfo.adminFee;\n            }\n            emit SwapFee(swapFeeInfo.tokens, swapFeeInfo.swapFees);\n\n            v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\n        }\n        uint256 tokenAmount = ((v.d0 - v.d2) * v.totalSupply) / v.d0;\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n        tokenAmount = tokenAmount + 1;\n\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\n\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\n            pooledTokens[i].safeTransfer(receiver, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            receiver,\n            amounts,\n            fees,\n            v.d1,\n            v.totalSupply - tokenAmount\n        );\n\n        return tokenAmount;\n    }\n\n    /**\n     * @notice withdraw all admin fees to a given address\n     * @param self Swap struct to withdraw fees from\n     * @param to Address to send the fees to\n     */\n    function withdrawAdminFees(\n        Swap storage self,\n        address to\n    ) external returns (uint256[] memory) {\n        IERC20[] memory pooledTokens = self.pooledTokens;\n        uint256[] memory amounts = new uint256[](pooledTokens.length);\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\n            IERC20 token = pooledTokens[i];\n            uint256 balance = token.balanceOf(address(this)) - self.balances[i];\n            amounts[i] = balance;\n            if (balance != 0) {\n                token.safeTransfer(to, balance);\n            }\n        }\n        return amounts;\n    }\n\n    /**\n     * @notice Sets the admin fee\n     * @dev adminFee cannot be higher than 100% of the swap fee\n     * @param self Swap struct to update\n     * @param newAdminFee new admin fee to be applied on future transactions\n     */\n    function setAdminFee(Swap storage self, uint256 newAdminFee) external {\n        require(newAdminFee <= MAX_ADMIN_FEE, \"Fee is too high\");\n        self.adminFee = newAdminFee;\n\n        emit NewAdminFee(newAdminFee);\n    }\n\n    /**\n     * @notice update the swap fee\n     * @dev fee cannot be higher than 1% of each swap\n     * @param self Swap struct to update\n     * @param newSwapFee new swap fee to be applied on future transactions\n     */\n    function setSwapFee(Swap storage self, uint256 newSwapFee) external {\n        require(newSwapFee <= MAX_SWAP_FEE, \"Fee is too high\");\n        self.swapFee = newSwapFee;\n\n        emit NewSwapFee(newSwapFee);\n    }\n}\n"
    },
    "contracts/utils/UQ112x112.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}"
    },
    "contracts/VolatilePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { IVolatilePair } from \"./interface/IPair.sol\";\nimport \"./lib/PairERC20.sol\";\nimport \"./utils/UQ112x112.sol\";\nimport \"./utils/ERC20Call.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"./interface/IPairCallee.sol\";\nimport \"./interface/IPairFactory.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract VolatilePair is PairERC20, IVolatilePair, Initializable {\n    using SafeMath for uint256;\n    using UQ112x112 for uint224;\n    using ERC20Call for address;\n\n    uint256 public constant MINIMUM_LIQUIDITY = 10 ** 3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint256 public price0CumulativeLast;\n    uint256 public price1CumulativeLast;\n    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint256 private unlocked;\n\n    uint8 public constant PAIR_TYPE = 1;\n    bool public constant AUTH = false;\n    uint256 public constant FEE_DENOMINATOR = 10 ** 10;\n    uint256 public constant MAX_SWAP_FEE = 10 ** 8;\n    uint256 public constant MAX_ADMIN_FEE = 10 ** 10;\n\n    uint256 public swapFeeRate;\n    uint256 public adminFeeRate;\n\n    uint256 public totalAdminFee0;\n    uint256 public totalAdminFee1;\n\n    modifier lock() {\n        require(unlocked == 1, \"Pair: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == IPairFactory(factory).manager(), \"Pair: not manager\");\n        _;\n    }\n\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"Pair: TRANSFER_FAILED\");\n    }\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\n    event Sync(uint112 reserve0, uint112 reserve1);\n    event ClaimFees(address token0, address token1, uint256 amount0, uint256 amount1);\n    event SetAdminFeeRate(uint256 _old, uint256 _new);\n    event SetSwapFeeRate(uint256 _old, uint256 _new);\n    event SwapFee(address[] tokens, uint256[] swapFees);\n\n    function initialize(address[] memory _tokens, bytes memory _data) external initializer {\n        factory = msg.sender;\n        unlocked = 1;\n        require(_tokens[0] != _tokens[1], \"Pair: Token cannot be the same\");\n        (token0, token1) = (_tokens[0], _tokens[1]);\n        (uint256 _swapfeeRate, uint256 _adminFeeRate) = abi.decode(_data, (uint256, uint256));\n\n        require(_swapfeeRate <= MAX_SWAP_FEE, \"Pair: SwapFee is greater than the maximum value\");\n        require(_adminFeeRate <= MAX_ADMIN_FEE, \"Pair: AdminFee is greater than the maximum value\");\n        (swapFeeRate, adminFeeRate) = (_swapfeeRate, _adminFeeRate);\n\n        _setNameAndSymbol(\n            string(abi.encodePacked(\"DForce Volatile AMM - \", _tokens[0].callSymbol(), \"-\", _tokens[1].callSymbol())),\n            string(abi.encodePacked(\"dAMM-Volatile-\", _tokens[0].callSymbol(), \"-\", _tokens[1].callSymbol()))\n        );\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(uint256 balance0, uint256 balance1, uint112 _reserve0, uint112 _reserve1) private {\n        require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, \"Pair: OVERFLOW\");\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n            price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external lock returns (uint256 liquidity) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        (uint256 balance0, uint256 balance1) = getRealBalanceOf();\n        uint256 amount0 = balance0.sub(_reserve0);\n        uint256 amount1 = balance1.sub(_reserve1);\n\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        }\n        require(liquidity > 0, \"Pair: INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to) external lock returns (uint256 amount0, uint256 amount1) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        (uint256 balance0, uint256 balance1) = getRealBalanceOf();\n        uint256 liquidity = balanceOf[address(this)];\n\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, \"Pair: INSUFFICIENT_LIQUIDITY_BURNED\");\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external lock {\n        require(amount0Out > 0 || amount1Out > 0, \"Pair: INSUFFICIENT_OUTPUT_AMOUNT\");\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, \"Pair: INSUFFICIENT_LIQUIDITY\");\n\n        uint256 balance0;\n        uint256 balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(to != _token0 && to != _token1, \"Pair: INVALID_TO\");\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n            if (data.length > 0) IPairCallee(to).hook(msg.sender, amount0Out, amount1Out, data);\n            (balance0, balance1) = getRealBalanceOf();\n        }\n        uint256 amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint256 amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, \"Pair: INSUFFICIENT_INPUT_AMOUNT\");\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            uint256 balance0Adjusted = balance0.mul(FEE_DENOMINATOR).sub(amount0In.mul(swapFeeRate));\n            uint256 balance1Adjusted = balance1.mul(FEE_DENOMINATOR).sub(amount1In.mul(swapFeeRate));\n            require(balance0Adjusted.mul(balance1Adjusted) >= uint256(_reserve0).mul(_reserve1).mul(FEE_DENOMINATOR ** 2), \"Pair: K\");\n\n            //update totalAdminFee and balance\n            (uint256 _swapFee0, uint256 _swapFee1) = _updateAdminFee(amount0In, amount1In);\n            (balance0 += _swapFee0, balance1 += _swapFee1);\n\n            uint256[] memory _swapFees = new uint256[](2);\n            (_swapFees[0], _swapFees[1]) = (_swapFee0, _swapFee1);\n            emit SwapFee(tokens(), _swapFees);\n        }\n        _update(balance0, balance1, _reserve0, _reserve1);\n\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        (uint256 balance0, uint256 balance1) = getRealBalanceOf();\n        _safeTransfer(_token0, to, balance0.sub(reserve0));\n        _safeTransfer(_token1, to, balance1.sub(reserve1));\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        (uint256 balance0, uint256 balance1) = getRealBalanceOf();\n        _update(balance0, balance1, reserve0, reserve1);\n    }\n\n    function claimFees() external returns (uint256[] memory _adminFees) {\n        address _manager = IPairFactory(factory).manager();\n        _adminFees = new uint256[](2);\n\n        (_adminFees[0], _adminFees[1]) = (totalAdminFee0, totalAdminFee1);\n        (totalAdminFee0, totalAdminFee1) = (0, 0);\n\n        _safeTransfer(token0, _manager, _adminFees[0]);\n        _safeTransfer(token1, _manager, _adminFees[1]);\n        emit ClaimFees(token0, token1, _adminFees[0], _adminFees[1]);\n    }\n\n    function setAdminFeeRate(uint256 _adminFeeRate) external onlyManager {\n        require(_adminFeeRate <= MAX_ADMIN_FEE, \"Pair: AdminFee is greater than the maximum value\");\n        uint256 _old = adminFeeRate;\n        adminFeeRate = _adminFeeRate;\n        emit SetAdminFeeRate(_old, _adminFeeRate);\n    }\n\n    function setSwapFeeRate(uint256 _swapFeeRate) external onlyManager {\n        require(_swapFeeRate <= MAX_SWAP_FEE, \"Pair: SwapFee is greater than the maximum value\");\n        uint256 _old = swapFeeRate;\n        swapFeeRate = _swapFeeRate;\n        emit SetSwapFeeRate(_old, _swapFeeRate);\n    }\n\n    function getAmountOut(address _from, address, uint256 _amount) external view override returns (uint256) {\n        (uint256 reserveA, uint256 reserveB) = _from == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n        return _getAmountOut(_amount, reserveA, reserveB);\n    }\n\n    function tokens() public view override returns (address[] memory _tokens) {\n        _tokens = new address[](2);\n        _tokens[0] = token0;\n        _tokens[1] = token1;\n    }\n\n    function sortTokens(address _tokenA, address _tokenB) public pure returns (address _token0, address _token1) {\n        require(_tokenA != _tokenB, \"Pair: IDENTICAL_ADDRESSES\");\n        (_token0, _token1) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\n        require(_token0 != address(0), \"Pair: ZERO_ADDRESS\");\n    }\n\n    function getRealBalanceOf() public view returns (uint256, uint256) {\n        return (IERC20(token0).balanceOf(address(this)).sub(totalAdminFee0), IERC20(token1).balanceOf(address(this)).sub(totalAdminFee1));\n    }\n\n    function _getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) internal view returns (uint256 amountOut) {\n        require(amountIn > 0, \"Pair: INSUFFICIENT_INPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"Pair: INSUFFICIENT_LIQUIDITY\");\n        uint256 amountInWithFee = amountIn.mul(FEE_DENOMINATOR - swapFeeRate);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(FEE_DENOMINATOR).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    function _updateAdminFee(uint256 _amountIn0, uint256 _amountIn1) internal returns (uint256 _swapFee0, uint256 _swapFee1) {\n        uint256 _totalFee0 = _amountIn0.mul(swapFeeRate).div(FEE_DENOMINATOR);\n        uint256 _totalFee1 = _amountIn1.mul(swapFeeRate).div(FEE_DENOMINATOR);\n\n        {\n            uint256 _adminFee0 = _totalFee0.mul(adminFeeRate).div(FEE_DENOMINATOR);\n            uint256 _adminFee1 = _totalFee1.mul(adminFeeRate).div(FEE_DENOMINATOR);\n\n            _swapFee0 = _totalFee0 - _adminFee0;\n            _swapFee1 = _totalFee0 - _adminFee1;\n\n            totalAdminFee0 += _adminFee0;\n            totalAdminFee1 += _adminFee1;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}