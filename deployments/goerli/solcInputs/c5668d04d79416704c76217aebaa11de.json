{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // ?`sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // ?`2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/interface/IPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\ninterface IPair {\r\n    function getAmountOut(address from, address to, uint256 amount) external view returns (uint256);\r\n\r\n    function tokens() external returns (address[] memory);\r\n\r\n    function initialize(address[] memory _tokens, bytes memory _data) external;\r\n\r\n    function PAIR_TYPE() external view returns (uint8);\r\n}\r\n\r\ninterface IVolatilePair is IPair {\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\r\n\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\ninterface IStablePair is IPair {\r\n    function calculateTokenAmount(address[] calldata _tokens, uint256[] calldata _amounts, bool _deposit) external view returns (uint256);\r\n\r\n    function calculateRemoveLiquidityOneToken(address _token, uint256 _liquidity) external view returns (uint256);\r\n\r\n    function calculateRemoveLiquidity(address[] calldata _tokens, uint256 _amount) external view returns (uint256[] memory);\r\n\r\n    function addLiquidity(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts,\r\n        uint256 _minToMint,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external payable returns (uint256);\r\n\r\n    function removeLiquidity(\r\n        uint256 _amount,\r\n        uint256[] calldata _minAmounts,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external payable returns (uint256[] memory);\r\n\r\n    function removeLiquidityOneToken(\r\n        address _token,\r\n        // uint256 _minAmount,\r\n        address _receiver\r\n    ) external returns (uint256);\r\n\r\n    function removeLiquidityImbalance(\r\n        address[] memory _tokens,\r\n        uint256[] calldata _amounts,\r\n        // uint256 _maxBurnAmount,\r\n        address _receiver\r\n    ) external returns (uint256);\r\n\r\n    function lpToken() external view returns (address);\r\n\r\n    function swap(\r\n        address _tokenFrom,\r\n        address _tokenTo,\r\n        uint256 _dx,\r\n        uint256 _minDy,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external returns (uint256);\r\n}\r\n"
    },
    "contracts/interface/IPairCallee.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\ninterface IPairCallee {\r\n    function hook(\r\n        address sender,\r\n        uint256 amountOut0,\r\n        uint256 amountOut1,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n"
    },
    "contracts/interface/IPairERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\ninterface IPairERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}"
    },
    "contracts/interface/IPairFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\ninterface IPairFactory {\r\n    //1: volatile pair, 2: stable pair, 3: yeild pair\r\n    struct PairParams {\r\n        uint8 _type;\r\n        bool _auth;\r\n    }\r\n\r\n    function allPairsLength() external view returns (uint256);\r\n\r\n    function isPair(address pair) external view returns (bool);\r\n\r\n    function createPair(\r\n        address[] memory _tokens,\r\n        uint8 _pairType,\r\n        bytes memory data\r\n    ) external returns (address pair);\r\n\r\n    function manager() external view returns (address);\r\n\r\n    function getPair(\r\n        address,\r\n        address,\r\n        uint8\r\n    ) external view returns (address[] memory);\r\n\r\n    function getPairAddress(address[] memory _tokens, uint8 _tpye) external view returns (address);\r\n\r\n    function pairTypeValues() external view returns (address[] memory);\r\n\r\n    function atPairType(uint256 _index) external view returns (address);\r\n\r\n    function pairParams(address) external view returns (PairParams memory);\r\n}\r\n"
    },
    "contracts/interface/IPairRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\ninterface IPairRouter {\r\n    struct Route {\r\n        address from;\r\n        address to;\r\n        address pair;\r\n    }\r\n\r\n    function quoteAddLiquidity(address[] memory _tokens, uint256[] memory _amountDesireds)\r\n        external\r\n        view\r\n        returns (uint256[] memory _amountIn, uint256 liquidity);\r\n\r\n    function quoteRemoveLiquidity(address[] memory _tokens, uint256 _liquidity) external view returns (uint256[] memory _amounts);\r\n\r\n    function addLiquidity(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory _amountsMin,\r\n        uint256 _minLiquidity,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256[] memory _amounts, uint256 _liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory _amountMins,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable returns (uint256[] memory _amounts, uint256 _liquidity);\r\n\r\n    function removeLiquidity(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256[] memory _amounts);\r\n\r\n    function removeLiquidityETH(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256[] memory _returns);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256[] memory _amounts);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256[] memory);\r\n\r\n    function swap(\r\n        Route memory _route,\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 _amountOut);\r\n}\r\n\r\ninterface IStablPairRouter is IPairRouter {\r\n    function quoteRemoveLiquidityOneToken(\r\n        address[] calldata _tokens,\r\n        address _token,\r\n        uint256 _liquidity\r\n    ) external view returns (uint256 _amount);\r\n\r\n    function quoteRemoveLiquidityImbalance(address[] calldata _tokens, uint256[] calldata _amounts) external view returns (uint256 _liquidity);\r\n\r\n    function removeLiquidityOneToken(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 _amount);\r\n\r\n    function removeLiquidityImbalance(\r\n        address[] memory _tokens,\r\n        uint256[] calldata _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 _amount);\r\n}\r\n"
    },
    "contracts/interface/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\n/// @title Interface for WETH9\r\ninterface IWETH {\r\n    /// @notice Deposit ether to get wrapped ether\r\n    function deposit() external payable;\r\n\r\n    /// @notice Withdraw wrapped ether to get ether\r\n    function withdraw(uint256) external;\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n}\r\n"
    },
    "contracts/lib/PairERC20.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\nimport \"../interface/IPairERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nabstract contract PairERC20 is IPairERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public constant decimals = 18;\r\n    uint256 public totalSupply;\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address => uint256) public nonces;\r\n\r\n    constructor() {\r\n        uint256 chainId = block.chainid;\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"), keccak256(bytes(name)), keccak256(bytes(\"1\")), chainId, address(this))\r\n        );\r\n    }\r\n\r\n    function _mint(address to, uint256 value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint256 value) internal {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 value\r\n    ) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal virtual {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint256 value) external returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 value) external returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool) {\r\n        if (allowance[from][msg.sender] != type(uint256).max) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external {\r\n        require(deadline >= block.timestamp, \"PairERC20: EXPIRED\");\r\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))));\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"PairERC20: INVALID_SIGNATURE\");\r\n        _approve(owner, spender, value);\r\n    }\r\n\r\n    function _setNameAndSymbol(string memory _name, string memory _symbol) internal {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n}\r\n"
    },
    "contracts/PairFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\nimport \"./utils/Arrays.sol\";\r\nimport \"./interface/IPairFactory.sol\";\r\nimport { IPair } from \"./interface/IPair.sol\";\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\n\r\ncontract PairFactory is IPairFactory, Initializable {\r\n    using Arrays for address[];\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    address public manager;\r\n    address public pendingManager;\r\n\r\n    uint256 public defSwapFeeRate;\r\n    uint256 public defAdminFeeRate;\r\n\r\n    mapping(address => bool) public isPair;\r\n    address[] public allPairs;\r\n    mapping(address => mapping(address => mapping(uint8 => address[]))) public pair;\r\n\r\n    EnumerableSet.AddressSet internal pairImpls;\r\n    mapping(address => PairParams) internal _pairParams;\r\n    mapping(uint8 => address) public pairType;\r\n\r\n    event PairCreated(address[] tokens, uint8 _type, address pair, uint256 pairsAmount);\r\n    event SetDefAdminFeeRate(uint256 _old, uint256 _new);\r\n    event SetDefSwapFeeRate(uint256 _old, uint256 _new);\r\n    event SetPairAdminFeeRate(uint256 _old, uint256 _new);\r\n    event AddPairType(address _impl, uint8 _type, bool _auth);\r\n    event RemovePairType(address _impl, uint8 _type, bool _auth);\r\n\r\n    struct PairTokens {\r\n        address _tokenA;\r\n        address _tokenB;\r\n    }\r\n\r\n    modifier onlyManager() {\r\n        require(msg.sender == manager, \"not manager\");\r\n        _;\r\n    }\r\n\r\n    function initialize(uint256 _defSwapFeeRate, uint256 _defAdminFeeRate) public initializer {\r\n        manager = msg.sender;\r\n        defSwapFeeRate = _defSwapFeeRate;\r\n        defAdminFeeRate = _defAdminFeeRate;\r\n    }\r\n\r\n    constructor(uint256 _defSwapFeeRate, uint256 _defAdminFeeRate) {\r\n        initialize(_defSwapFeeRate, _defAdminFeeRate);\r\n    }\r\n\r\n    function allPairsLength() external view returns (uint256) {\r\n        return allPairs.length;\r\n    }\r\n\r\n    function setManager(address _manager) external onlyManager {\r\n        pendingManager = _manager;\r\n    }\r\n\r\n    function acceptManager() external {\r\n        require(msg.sender == pendingManager, \"not pending fee manager\");\r\n        manager = pendingManager;\r\n    }\r\n\r\n    function setDefAdminFeeRate(uint256 _defAdminFeeRate) external onlyManager {\r\n        uint256 _old = defAdminFeeRate;\r\n        defAdminFeeRate = _defAdminFeeRate;\r\n        emit SetDefAdminFeeRate(_old, _defAdminFeeRate);\r\n    }\r\n\r\n    function setDefSwapFeeRate(uint256 _defSwapFeeRate) external onlyManager {\r\n        uint256 _old = defSwapFeeRate;\r\n        defSwapFeeRate = _defSwapFeeRate;\r\n        emit SetDefSwapFeeRate(_old, _defSwapFeeRate);\r\n    }\r\n\r\n    function containsPair(address value) external view returns (bool) {\r\n        return pairImpls.contains(value);\r\n    }\r\n\r\n    function addPairType(address _impl, uint8 _type, bool _auth) external onlyManager {\r\n        require(!pairImpls.contains(_impl), \"Factory: This pair already exists\");\r\n        pairImpls.add(_impl);\r\n        _pairParams[_impl] = PairParams({ _type: _type, _auth: _auth });\r\n\r\n        ///@dev It can also be done to override the old impl\r\n        pairType[_type] = _impl;\r\n        emit AddPairType(_impl, _type, _auth);\r\n    }\r\n\r\n    function removePairType(address _impl) external onlyManager {\r\n        require(pairImpls.contains(_impl), \"Factory: This pair does not exist\");\r\n        pairImpls.remove(_impl);\r\n        PairParams memory _old = _pairParams[_impl];\r\n        _pairParams[_impl] = PairParams({ _type: 0, _auth: false });\r\n        pairType[_old._type] = address(0);\r\n        emit RemovePairType(_impl, _old._type, _old._auth);\r\n    }\r\n\r\n    function pairTypeValues() external view returns (address[] memory) {\r\n        return pairImpls.values();\r\n    }\r\n\r\n    function pairTypeAmount() external view returns (uint256) {\r\n        return pairImpls.length();\r\n    }\r\n\r\n    function atPairType(uint256 _index) external view returns (address) {\r\n        return pairImpls.at(_index);\r\n    }\r\n\r\n    function getPairAddress(address[] memory _tokens, uint8 _pairType) public view returns (address) {\r\n        bytes32 salt = keccak256(abi.encodePacked(_tokens.sortArray(), _pairType));\r\n        return Clones.predictDeterministicAddress(pairType[_pairType], salt);\r\n    }\r\n\r\n    function getPair(address _tokenA, address _tokenB, uint8 _pairType) external view override returns (address[] memory) {\r\n        return pair[_tokenA][_tokenB][_pairType];\r\n    }\r\n\r\n    function createPair(address[] memory _tokens, uint8 _pairType, bytes memory _data) external returns (address _pair) {\r\n        _tokens = _tokens.sortArray();\r\n        checkTokens(_tokens);\r\n\r\n        require(!isPair[getPairAddress(_tokens, _pairType)], \"Factory: Pair already exists\");\r\n\r\n        bytes32 salt = keccak256(abi.encodePacked(_tokens, _pairType));\r\n\r\n        address _pairImpl = pairType[_pairType];\r\n        if (_pairType == 1) {\r\n            _data = abi.encode(defSwapFeeRate, defAdminFeeRate);\r\n        }\r\n        if (_pairParams[_pairImpl]._auth) {\r\n            require(manager == msg.sender, \"Factory: this pair type can only be created by manager\");\r\n        }\r\n        _pair = Clones.cloneDeterministic(_pairImpl, salt);\r\n\r\n        IPair(_pair).initialize(_tokens, _data);\r\n\r\n        _setPair(_tokens, _pairType, _pair);\r\n\r\n        isPair[getPairAddress(_tokens, _pairType)] = true;\r\n        allPairs.push(_pair);\r\n        isPair[_pair] = true;\r\n\r\n        emit PairCreated(_tokens, _pairType, _pair, allPairs.length);\r\n    }\r\n\r\n    function getEveryPair(address[] memory _tokens) public pure returns (PairTokens[] memory) {\r\n        PairTokens[] memory _pairs = new PairTokens[]((_tokens.length - 1) * _tokens.length);\r\n        uint256 _lastIndex = 0;\r\n        for (uint256 _i = 0; _i < _tokens.length - 1; _i++) {\r\n            for (uint256 _j = _i + 1; _j < _tokens.length; _j++) {\r\n                _pairs[_lastIndex++] = PairTokens({ _tokenA: _tokens[_i], _tokenB: _tokens[_j] });\r\n                _pairs[_lastIndex++] = PairTokens({ _tokenA: _tokens[_j], _tokenB: _tokens[_i] });\r\n            }\r\n        }\r\n        return _pairs;\r\n    }\r\n\r\n    function checkTokens(address[] memory _tokens) public pure {\r\n        require(_tokens[0] != address(0), \"ZA\"); // ZERO_ADDRESS\r\n        for (uint256 _i = 0; _i < _tokens.length - 1; _i++) {\r\n            for (uint256 _j = _i + 1; _j < _tokens.length; _j++) {\r\n                require(_tokens[_j] != address(0), \"ZA\"); // ZERO_ADDRESS\r\n                require(_tokens[_j] != _tokens[_i], \"Factory: IA\"); //IDENTICAL_ADDRESSES\r\n            }\r\n        }\r\n    }\r\n\r\n    function _setPair(address[] memory _tokens, uint8 _type, address _pair) internal {\r\n        PairTokens[] memory _pairs = getEveryPair(_tokens);\r\n        for (uint256 _i = 0; _i < _pairs.length; _i++) {\r\n            pair[_pairs[_i]._tokenA][_pairs[_i]._tokenB][_type].push(_pair);\r\n        }\r\n    }\r\n\r\n    function pairParams(address _pair) external view returns (PairParams memory) {\r\n        return _pairParams[_pair];\r\n    }\r\n}\r\n"
    },
    "contracts/Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.13;\r\n\r\nimport \"./interface/IWETH.sol\";\r\nimport \"./interface/IPair.sol\";\r\nimport \"./interface/IPairRouter.sol\";\r\nimport \"./interface/IPairERC20.sol\";\r\nimport \"./interface/IPairFactory.sol\";\r\n\r\nimport \"./utils/Arrays.sol\";\r\n\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\n\r\ncontract Router is Initializable {\r\n    using Arrays for address[];\r\n    using Address for address;\r\n\r\n    struct Route {\r\n        address from;\r\n        address to;\r\n        address pair;\r\n    }\r\n\r\n    address public factory;\r\n    IWETH public weth;\r\n    mapping(uint8 => address) public pairTypes;\r\n\r\n    event SetPairTypes(uint8 pairType, address router);\r\n\r\n    modifier onlyManager() {\r\n        require(msg.sender == IPairFactory(factory).manager(), \"not manager\");\r\n        _;\r\n    }\r\n\r\n    function initialize(address _factory, address _weth) public initializer {\r\n        factory = _factory;\r\n        weth = IWETH(_weth);\r\n    }\r\n\r\n    constructor(address _factory, address _weth) {\r\n        initialize(_factory, _weth);\r\n    }\r\n\r\n    function setPairTypes(uint8 _pairType, address _router) external onlyManager {\r\n        pairTypes[_pairType] = _router;\r\n        emit SetPairTypes(_pairType, _router);\r\n    }\r\n\r\n    function quoteAddLiquidity(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds\r\n    ) external view returns (uint256[] memory _amountIn, uint256 liquidity) {\r\n        address _router = pairTypes[_pairType];\r\n        bytes memory _returns = _router.functionStaticCall(\r\n            abi.encodeWithSelector(IPairRouter.quoteAddLiquidity.selector, _tokens, _amountDesireds)\r\n        );\r\n        (_amountIn, liquidity) = abi.decode(_returns, (uint256[], uint256));\r\n    }\r\n\r\n    function quoteRemoveLiquidity(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256 _liquidity\r\n    ) external view returns (uint256[] memory _amounts) {\r\n        address _router = pairTypes[_pairType];\r\n        bytes memory _returns = _router.functionStaticCall(\r\n            abi.encodeWithSelector(IPairRouter.quoteRemoveLiquidity.selector, _tokens, _liquidity)\r\n        );\r\n        _amounts = abi.decode(_returns, (uint256[]));\r\n    }\r\n\r\n    function addLiquidity(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory _amountsMin,\r\n        uint256 _minLiquidity,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256[] memory _amounts, uint256 _liquidity) {\r\n        address _router = pairTypes[_pairType];\r\n        bytes memory _returns = _router.functionDelegateCall(\r\n            abi.encodeWithSelector(IPairRouter.addLiquidity.selector, _tokens, _amountDesireds, _amountsMin, _minLiquidity, _to, _deadline)\r\n        );\r\n        (_amounts, _liquidity) = abi.decode(_returns, (uint256[], uint256));\r\n    }\r\n\r\n    function removeLiquidity(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256[] memory _amounts) {\r\n        address _router = pairTypes[_pairType];\r\n        bytes memory _returns = _router.functionDelegateCall(\r\n            abi.encodeWithSelector(IPairRouter.removeLiquidity.selector, _tokens, _liquidity, _amountsMin, _to, _deadline)\r\n        );\r\n        _amounts = abi.decode(_returns, (uint256[]));\r\n    }\r\n\r\n    function swap(\r\n        Route[] memory _routes,\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 _amountOut) {\r\n        for (uint i = 0; i < _routes.length; i++) {\r\n            uint8 _pairType = IPair(_routes[i].pair).PAIR_TYPE();\r\n            address _router = pairTypes[_pairType];\r\n            bytes memory _returns = _router.functionDelegateCall(\r\n                abi.encodeWithSelector(IPairRouter.swap.selector, _routes[i], _amountIn, _amountOutMin, _to, _deadline)\r\n            );\r\n            _amountIn = abi.decode(_returns, (uint256));\r\n        }\r\n        _amountOut = _amountIn;\r\n    }\r\n\r\n    function getAmountsOut(uint256 _amountIn, Route[] memory _routes) public view returns (uint256 _amountsOut) {\r\n        require(_routes.length >= 1, \"Router: INVALID_PATH\");\r\n        _amountsOut = _amountIn;\r\n        for (uint256 i = 0; i < _routes.length; i++) {\r\n            _amountsOut = IPair(_routes[i].pair).getAmountOut(_routes[i].from, _routes[i].to, _amountsOut);\r\n        }\r\n    }\r\n\r\n    receive() external payable {\r\n        assert(msg.sender == address(weth)); // only accept ETH via fallback from the WETH contract\r\n    }\r\n}\r\n"
    },
    "contracts/routers/StableRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\nimport \"../interface/IPair.sol\";\r\nimport \"../interface/IWETH.sol\";\r\nimport \"../interface/IPairRouter.sol\";\r\nimport \"../interface/IPairFactory.sol\";\r\nimport \"../interface/IPairERC20.sol\";\r\nimport \"../utils/Arrays.sol\";\r\n\r\ncontract StableRouter is IStablPairRouter {\r\n    using Arrays for address[];\r\n\r\n    uint8 public constant PAIR_TYPE = 1;\r\n\r\n    address public immutable factory;\r\n    IWETH public immutable weth;\r\n\r\n    modifier ensure(uint256 _deadline) {\r\n        require(_deadline >= block.timestamp, \"StableRouter: EXPIRED\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _factory, address _weth) {\r\n        factory = _factory;\r\n        weth = IWETH(_weth);\r\n    }\r\n\r\n    function quoteAddLiquidity(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds\r\n    ) external view override returns (uint256[] memory _amountIn, uint256 _liquidity) {\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        bool _isPair = IPairFactory(factory).isPair(_pair);\r\n        if (_isPair) {\r\n            _amountIn = _amountDesireds;\r\n            _liquidity = IStablePair(_pair).calculateTokenAmount(_tokens, _amountDesireds, true);\r\n        }\r\n    }\r\n\r\n    function quoteRemoveLiquidity(address[] memory _tokens, uint256 _liquidity) external view override returns (uint256[] memory _amounts) {\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        _amounts = IStablePair(_pair).calculateRemoveLiquidity(_tokens, _liquidity);\r\n    }\r\n\r\n    function quoteRemoveLiquidityOneToken(\r\n        address[] calldata _tokens,\r\n        address _token,\r\n        uint256 _liquidity\r\n    ) external view override returns (uint256 _amount) {\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        if (IPairFactory(factory).isPair(_pair)) _amount = IStablePair(_pair).calculateRemoveLiquidityOneToken(_token, _liquidity);\r\n    }\r\n\r\n    function quoteRemoveLiquidityImbalance(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts\r\n    ) external view override returns (uint256 _liquidity) {\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        if (IPairFactory(factory).isPair(_pair)) _liquidity = IStablePair(_pair).calculateTokenAmount(_tokens, _amounts, false) + 1;\r\n    }\r\n\r\n    function addLiquidity(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory,\r\n        uint256 _minLiquidity,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external override ensure(_deadline) returns (uint256[] memory _amounts, uint256 _liquidity) {\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        require(IPairFactory(factory).isPair(_pair), \"StableRouter: is not pair\");\r\n        _amounts = _amountDesireds;\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            _safeTransferFrom(_tokens[i], msg.sender, address(this), _amounts[i]);\r\n            _safeApprove(_tokens[i], _pair, _amounts[i]);\r\n        }\r\n        _liquidity = IStablePair(_pair).addLiquidity(_tokens, _amounts, _minLiquidity, _to, _deadline);\r\n    }\r\n\r\n    /// @param _amountDesireds The last one is the amount of weth, And the array length is one bit longer than _tokens\r\n    /// @param _amountMins only minLiquidity\r\n    function addLiquidityETH(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory _amountMins,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable override returns (uint256[] memory _amounts, uint256 _liquidity) {\r\n        _amounts = new uint256[](2);\r\n        _tokens = _tokens.copyAndAddOne(address(weth));\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        require(IPairFactory(factory).isPair(_pair), \"StableRouter: is not pair\");\r\n        _amounts = _amountDesireds;\r\n        weth.deposit{ value: _amounts[_amounts.length - 1] }();\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            _safeTransferFrom(_tokens[i], msg.sender, address(this), _amounts[i]);\r\n            _safeApprove(_tokens[i], _pair, _amounts[i]);\r\n        }\r\n        _liquidity = IStablePair(_pair).addLiquidity(_tokens, _amounts, _amountMins[0], _to, _deadline);\r\n        if (msg.value > _amounts[_amounts.length - 1]) _safeTransferETH(msg.sender, msg.value - _amounts[_amounts.length - 1]);\r\n    }\r\n\r\n    function removeLiquidity(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external override returns (uint256[] memory _amounts) {\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        require(IPairFactory(factory).isPair(_pair), \"StableRouter: pair doesn't exist\"); // send liquidity to pair\r\n\r\n        address _lpToken = IStablePair(_pair).lpToken();\r\n        _safeTransferFrom(_lpToken, msg.sender, address(this), _liquidity);\r\n        _safeApprove(_lpToken, _pair, _liquidity);\r\n\r\n        _amounts = IStablePair(_pair).removeLiquidity(_liquidity, _amountsMin, _to, _deadline);\r\n    }\r\n\r\n    function removeLiquidityETH(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external override returns (uint256[] memory _amounts) {\r\n        _tokens = _tokens.copyAndAddOne(address(weth));\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        require(IPairFactory(factory).isPair(_pair), \"StableRouter: pair doesn't exist\"); // send liquidity to pair\r\n    }\r\n\r\n    function removeLiquidityWithPermit(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external override returns (uint256[] memory _amounts) {}\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external override returns (uint256[] memory _amounts) {}\r\n\r\n    function removeLiquidityOneToken(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external override returns (uint256 _amount) {}\r\n\r\n    function removeLiquidityImbalance(\r\n        address[] memory _tokens,\r\n        uint256[] calldata _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external override returns (uint256 _amount) {}\r\n\r\n    function swap(\r\n        Route memory _route,\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external override returns (uint256 _amountOut) {\r\n        require(IPairFactory(factory).isPair(_route.pair), \"StableRouter: is not pair\");\r\n\r\n        _safeTransferFrom(_route.from, msg.sender, address(this), _amountIn);\r\n        _safeApprove(_route.from, _route.pair, _amountIn);\r\n\r\n        return IStablePair(_route.pair).swap(_route.from, _route.to, _amountIn, _amountOutMin, _to, _deadline);\r\n    }\r\n\r\n    function _safeTransferFrom(address _token, address _from, address _to, uint256 _value) internal {\r\n        require(_token.code.length > 0);\r\n        (bool _success, bytes memory _data) = _token.call(abi.encodeWithSelector(IPairERC20.transferFrom.selector, _from, _to, _value));\r\n        require(_success && (_data.length == 0 || abi.decode(_data, (bool))));\r\n    }\r\n\r\n    function _safeApprove(address token, address to, uint256 amount) internal {\r\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(IPairERC20(token).approve.selector, to, amount));\r\n\r\n        if (!success || (returndata.length > 0 && !abi.decode(returndata, (bool)))) {\r\n            _callOptionalReturn(token, abi.encodeWithSelector(IPairERC20(token).approve.selector, to, 0));\r\n            _callOptionalReturn(token, abi.encodeWithSelector(IPairERC20(token).approve.selector, to, amount));\r\n        }\r\n    }\r\n\r\n    function _callOptionalReturn(address token, bytes memory data) private {\r\n        (bool success, bytes memory result) = token.call(data);\r\n        require(success, \"StablePair: Low-level call failed\");\r\n\r\n        if (result.length > 0) {\r\n            require(abi.decode(result, (bool)), \"StablePair: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n\r\n    function _safeTransferETH(address _to, uint256 _value) internal {\r\n        (bool _success, ) = _to.call{ value: _value }(new bytes(0));\r\n        require(_success, \"TransferHelper: ETH_TRANSFER_FAILED\");\r\n    }\r\n}\r\n"
    },
    "contracts/routers/VolatileRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\nimport \"../interface/IPair.sol\";\r\nimport \"../interface/IWETH.sol\";\r\nimport \"../interface/IPairRouter.sol\";\r\nimport \"../interface/IPairFactory.sol\";\r\nimport \"../interface/IPairERC20.sol\";\r\nimport \"../utils/Arrays.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\n\r\ncontract VolatileRouter is IPairRouter {\r\n    using Arrays for address[];\r\n\r\n    uint8 public constant PAIR_TYPE = 1;\r\n    uint256 internal constant MINIMUM_LIQUIDITY = 10**3;\r\n\r\n    address public immutable factory;\r\n    IWETH public immutable weth;\r\n\r\n    modifier ensure(uint256 _deadline) {\r\n        require(_deadline >= block.timestamp, \"Router: EXPIRED\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _factory, address _weth) {\r\n        factory = _factory;\r\n        weth = IWETH(_weth);\r\n    }\r\n\r\n    function quoteAddLiquidity(address[] memory _tokens, uint256[] memory _amountDesireds)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256[] memory _amountIn, uint256 liquidity)\r\n    {\r\n        // create the pair if it doesn't exist yet\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        (uint256 reserveA, uint256 reserveB) = (0, 0);\r\n        uint256 _totalSupply = 0;\r\n        if (_pair != address(0)) {\r\n            _totalSupply = IPairERC20(_pair).totalSupply();\r\n            (reserveA, reserveB) = getReserves(_pair, _tokens[0], _tokens[1]);\r\n        }\r\n        (uint256 amountA, uint256 amountB) = (0, 0);\r\n        (uint256 amountADesired, uint256 amountBDesired) = (_amountDesireds[0], _amountDesireds[1]);\r\n        if (reserveA == 0 && reserveB == 0) {\r\n            (amountA, amountB) = (amountADesired, amountBDesired);\r\n            liquidity = Math.sqrt(amountA * amountB) - MINIMUM_LIQUIDITY;\r\n        } else {\r\n            uint256 amountBOptimal = _quoteLiquidity(amountADesired, reserveA, reserveB);\r\n            if (amountBOptimal <= amountBDesired) {\r\n                (amountA, amountB) = (amountADesired, amountBOptimal);\r\n                liquidity = Math.min((amountA * _totalSupply) / reserveA, (amountB * _totalSupply) / reserveB);\r\n            } else {\r\n                uint256 amountAOptimal = _quoteLiquidity(amountBDesired, reserveB, reserveA);\r\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\r\n                liquidity = Math.min((amountA * _totalSupply) / reserveA, (amountB * _totalSupply) / reserveB);\r\n            }\r\n        }\r\n        _amountIn = new uint256[](2);\r\n        (_amountIn[0], _amountIn[1]) = (amountA, amountB);\r\n    }\r\n\r\n    function quoteRemoveLiquidity(address[] memory _tokens, uint256 _liquidity) external view override returns (uint256[] memory _amounts) {\r\n        // create the pair if it doesn't exist yet\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n\r\n        if (!IPairFactory(factory).isPair(_pair)) {\r\n            return _amounts;\r\n        }\r\n\r\n        (uint256 _reserveA, uint256 _reserveB) = getReserves(_pair, _tokens[0], _tokens[1]);\r\n        uint256 _totalSupply = IPairERC20(_pair).totalSupply();\r\n\r\n        _amounts = new uint256[](2);\r\n\r\n        _amounts[0] = (_liquidity * _reserveA) / _totalSupply; // using balances ensures pro-rata distribution\r\n        _amounts[1] = (_liquidity * _reserveB) / _totalSupply; // using balances ensures pro-rata distribution\r\n    }\r\n\r\n    function addLiquidity(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory _amountsMin,\r\n        uint256 _minLiquidity,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external override ensure(_deadline) returns (uint256[] memory _amounts, uint256 _liquidity) {\r\n        _amounts = _amountDesireds;\r\n        (_amounts[0], _amounts[1]) = _addLiquidity(_tokens[0], _tokens[1], _amountDesireds[0], _amountDesireds[1], _amountsMin[0], _amountsMin[1]);\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            _safeTransferFrom(_tokens[i], msg.sender, _pair, _amounts[i]);\r\n        }\r\n        _liquidity = IVolatilePair(_pair).mint(_to);\r\n        require(_liquidity >= _minLiquidity, \"Couldn't mint min requested\");\r\n    }\r\n\r\n    function _addLiquidity(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _amountADesired,\r\n        uint256 _amountBDesired,\r\n        uint256 _amountAMin,\r\n        uint256 _amountBMin\r\n    ) internal returns (uint256 _amountA, uint256 _amountB) {\r\n        require(_amountADesired >= _amountAMin);\r\n        require(_amountBDesired >= _amountBMin);\r\n        // create the pair if it doesn't exist yet\r\n        address _pair = getPair(_tokenA, _tokenB);\r\n        if (_pair == address(0)) {\r\n            address[] memory _tokens = new address[](2);\r\n            _tokens[0] = _tokenA;\r\n            _tokens[1] = _tokenB;\r\n            _pair = IPairFactory(factory).createPair(_tokens, PAIR_TYPE, new bytes(0));\r\n        }\r\n        require(_pair != address(0), \"Router: not have this pair\");\r\n        (uint256 _reserveA, uint256 _reserveB) = getReserves(_pair, _tokenA, _tokenB);\r\n        if (_reserveA == 0 && _reserveB == 0) {\r\n            (_amountA, _amountB) = (_amountADesired, _amountBDesired);\r\n        } else {\r\n            uint256 _amountBOptimal = _quoteLiquidity(_amountADesired, _reserveA, _reserveB);\r\n            if (_amountBOptimal <= _amountBDesired) {\r\n                require(_amountBOptimal >= _amountBMin, \"Router: INSUFFICIENT_B_AMOUNT\");\r\n                (_amountA, _amountB) = (_amountADesired, _amountBOptimal);\r\n            } else {\r\n                uint256 _amountAOptimal = _quoteLiquidity(_amountBDesired, _reserveB, _reserveA);\r\n                assert(_amountAOptimal <= _amountADesired);\r\n                require(_amountAOptimal >= _amountAMin, \"Router: INSUFFICIENT_A_AMOUNT\");\r\n                (_amountA, _amountB) = (_amountAOptimal, _amountBDesired);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @param _tokens only other token\r\n    /// @param _amountDesireds only other token\r\n    /// @param _amountMins 0: other token, 1: weth\r\n    /// @return _amounts 0: other token, 1: weth\r\n    function addLiquidityETH(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory _amountMins,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable override ensure(_deadline) returns (uint256[] memory _amounts, uint256 _liquidity) {\r\n        _amounts = new uint256[](2);\r\n        (_amounts[0], _amounts[1]) = _addLiquidity(_tokens[0], address(weth), _amountDesireds[0], msg.value, _amountMins[0], _amountMins[1]);\r\n        address _pair = getPair(_tokens[0], address(weth));\r\n        _safeTransferFrom(_tokens[0], msg.sender, _pair, _amounts[0]);\r\n        weth.deposit{ value: _amounts[1] }();\r\n        assert(weth.transfer(_pair, _amounts[1]));\r\n        _liquidity = IVolatilePair(_pair).mint(_to);\r\n        // refund dust eth, if any\r\n        if (msg.value > _amounts[1]) _safeTransferETH(msg.sender, msg.value - _amounts[1]);\r\n    }\r\n\r\n    function removeLiquidity(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public override ensure(_deadline) returns (uint256[] memory _amounts) {\r\n        return _removeLiquidity(_tokens[0], _tokens[1], _liquidity, _amountsMin, _to);\r\n    }\r\n\r\n    function _removeLiquidity(\r\n        address _token0,\r\n        address _token1,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to\r\n    ) internal returns (uint256[] memory _amounts) {\r\n        address _pair = getPair(_token0, _token1);\r\n        require(IPairFactory(factory).isPair(_pair), \"Router: pair doesn't exist\"); // send liquidity to pair\r\n        IPairERC20(_pair).transferFrom(msg.sender, _pair, _liquidity);\r\n        (uint256 _amount0, uint256 _amount1) = IVolatilePair(_pair).burn(_to);\r\n        _amounts = new uint256[](2);\r\n        (_amounts[0], _amounts[1]) = (_amount0, _amount1);\r\n\r\n        for (uint256 i = 0; i < _amounts.length; i++) {\r\n            require(_amounts[i] >= _amountsMin[i], \"Router: INSUFFICIENT_A_AMOUNT\");\r\n        }\r\n    }\r\n\r\n    /// @param _tokens only other token\r\n    /// @param _amountsMin 0: other token amount, 1: eth amount\r\n    function removeLiquidityETH(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public override ensure(_deadline) returns (uint256[] memory _amounts) {\r\n        _amounts = _removeLiquidity(_tokens[0], address(weth), _liquidity, _amountsMin, address(this));\r\n        _safeTransfer(_tokens[0], _to, _amounts[0]);\r\n        weth.withdraw(_amounts[1]);\r\n        _safeTransferETH(_to, _amounts[1]);\r\n    }\r\n\r\n    function removeLiquidityWithPermit(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external override returns (uint256[] memory _amounts) {\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n        {\r\n            uint256 _value = _approveMax ? type(uint256).max : _liquidity;\r\n            IPairERC20(_pair).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s);\r\n        }\r\n        _amounts = removeLiquidity(_tokens, _liquidity, _amountMin, _to, _deadline);\r\n    }\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external override returns (uint256[] memory) {\r\n        address _pair = getPair(_tokens[0], address(weth));\r\n        uint256 _value = _approveMax ? type(uint256).max : _liquidity;\r\n        IPairERC20(_pair).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s);\r\n        return removeLiquidityETH(_tokens, _liquidity, _amountsMin, _to, _deadline);\r\n    }\r\n\r\n    function swap(\r\n        Route memory _route,\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external ensure(_deadline) returns (uint256 _amountOut) {\r\n        address[] memory _tokens = IVolatilePair(_route.pair).tokens();\r\n        _amountOut = IVolatilePair(_route.pair).getAmountOut(_route.from, _route.to, _amountIn);\r\n        require(_amountOut >= _amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n        (uint256 amount0Out, uint256 amount1Out) = _route.pair == _tokens[0] ? (uint256(0), _amountOut) : (_amountOut, uint256(0));\r\n\r\n        ///@dev The delegatecall function of the super router\r\n        _safeTransfer(_route.from, _route.pair, _amountIn);\r\n        IVolatilePair(_route.pair).swap(amount0Out, amount1Out, _to, new bytes(0));\r\n    }\r\n\r\n    function _swap(\r\n        uint256[] memory amounts,\r\n        address[] memory path,\r\n        address _to\r\n    ) internal virtual {\r\n        for (uint256 i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0, ) = sortTokens(input, output);\r\n            uint256 amountOut = amounts[i + 1];\r\n            (uint256 amount0Out, uint256 amount1Out) = input == token0 ? (uint256(0), amountOut) : (amountOut, uint256(0));\r\n            address to = i < path.length - 2 ? getPair(output, path[i + 2]) : _to;\r\n            IVolatilePair(getPair(input, output)).swap(amount0Out, amount1Out, to, new bytes(0));\r\n        }\r\n    }\r\n\r\n    function getReserves(\r\n        address _pair,\r\n        address tokenA,\r\n        address tokenB\r\n    ) public view returns (uint256 reserveA, uint256 reserveB) {\r\n        (address token0, ) = sortTokens(tokenA, tokenB);\r\n        (uint256 reserve0, uint256 reserve1, ) = IVolatilePair(_pair).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    function sortTokens(address tokenA, address tokenB) public pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, \"Router: IDENTICAL_ADDRESSES\");\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), \"Router: ZERO_ADDRESS\");\r\n    }\r\n\r\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n    function _quoteLiquidity(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) internal pure returns (uint256 amountB) {\r\n        require(amountA > 0, \"Router: INSUFFICIENT_AMOUNT\");\r\n        require(reserveA > 0 && reserveB > 0, \"Router: INSUFFICIENT_LIQUIDITY\");\r\n        amountB = (amountA * reserveB) / reserveA;\r\n    }\r\n\r\n    function _safeTransferFrom(\r\n        address _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal {\r\n        require(_token.code.length > 0);\r\n        (bool _success, bytes memory _data) = _token.call(abi.encodeWithSelector(IPairERC20.transferFrom.selector, _from, _to, _value));\r\n        require(_success && (_data.length == 0 || abi.decode(_data, (bool))));\r\n    }\r\n\r\n    function _safeTransferETH(address _to, uint256 _value) internal {\r\n        (bool _success, ) = _to.call{ value: _value }(new bytes(0));\r\n        require(_success, \"TransferHelper: ETH_TRANSFER_FAILED\");\r\n    }\r\n\r\n    function _safeTransfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal {\r\n        require(_token.code.length > 0);\r\n        (bool _success, bytes memory _data) = _token.call(abi.encodeWithSelector(IPairERC20.transfer.selector, _to, _value));\r\n        require(_success && (_data.length == 0 || abi.decode(_data, (bool))));\r\n    }\r\n\r\n    function getPair(address _tokenA, address _tokenB) internal view returns (address _pair) {\r\n        address[] memory _tokens = new address[](2);\r\n        _tokens[0] = _tokenA;\r\n        _tokens[1] = _tokenB;\r\n        _pair = IPairFactory(factory).getPairAddress(_tokens, PAIR_TYPE);\r\n    }\r\n\r\n    function getAmountsOut(uint256 _amountIn, Route[] memory _routes) public view returns (uint256[] memory _amounts) {\r\n        require(_routes.length >= 1, \"Router: INVALID_PATH\");\r\n        _amounts = new uint256[](_routes.length + 1);\r\n        _amounts[0] = _amountIn;\r\n        for (uint256 i = 0; i < _routes.length; i++) {\r\n            if (IPairFactory(factory).isPair(_routes[i].pair)) {\r\n                _amounts[i + 1] = IPair(_routes[i].pair).getAmountOut(_routes[i].from, _routes[i].to, _amounts[i]);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/StablePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"./utils/SwapUtils.sol\";\r\nimport \"./utils/AmplificationUtils.sol\";\r\nimport \"./utils/ERC20Call.sol\";\r\nimport \"./interface/IPairERC20.sol\";\r\nimport \"./interface/IPairFactory.sol\";\r\n\r\n/**\r\n * @title Swap - A StableSwap implementation in solidity.\r\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\r\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\r\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\r\n * Users can burn pool tokens and withdraw their share of token(s).\r\n *\r\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\r\n * distributed to the LPs.\r\n *\r\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\r\n * stops the ratio of the tokens in the pool from changing.\r\n * Users can always withdraw their tokens via multi-asset withdraws.\r\n *\r\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\r\n * deployment size.\r\n */\r\ncontract StablePair is Initializable {\r\n    using SwapUtils for SwapUtils.Swap;\r\n    using AmplificationUtils for SwapUtils.Swap;\r\n    using ERC20Call for address;\r\n\r\n    uint8 public constant PAIR_TYPE = 2;\r\n\r\n    address public factory;\r\n\r\n    uint256 private unlocked_ = 1;\r\n\r\n    // Struct storing data responsible for automatic market maker functionalities. In order to\r\n    // access this data, this contract uses SwapUtils library. For more details, see SwapUtils.sol\r\n    SwapUtils.Swap public swapStorage;\r\n\r\n    // Maps token address to an index in the pool. Used to prevent duplicate tokens in the pool.\r\n    // getTokenIndex function also relies on this mapping to retrieve token index.\r\n    mapping(address => uint8) internal tokenIndexes_;\r\n\r\n    /*** EVENTS ***/\r\n\r\n    // events replicated from SwapUtils to make the ABI easier for dumb\r\n    // clients\r\n    event TokenSwap(\r\n        address indexed buyer,\r\n        uint256 tokensSold,\r\n        uint256 tokensBought,\r\n        uint128 soldId,\r\n        uint128 boughtId\r\n    );\r\n    event AddLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidityOne(\r\n        address indexed provider,\r\n        uint256 lpTokenAmount,\r\n        uint256 lpTokenSupply,\r\n        uint256 boughtId,\r\n        uint256 tokensBought\r\n    );\r\n    event RemoveLiquidityImbalance(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event NewAdminFee(uint256 newAdminFee);\r\n    event NewSwapFee(uint256 newSwapFee);\r\n    event NewWithdrawFee(uint256 newWithdrawFee);\r\n    event RampA(\r\n        uint256 oldA,\r\n        uint256 newA,\r\n        uint256 initialTime,\r\n        uint256 futureTime\r\n    );\r\n    event StopRampA(uint256 currentA, uint256 time);\r\n\r\n    constructor() {\r\n        factory = msg.sender;\r\n    }\r\n\r\n    function initialize(\r\n        address[] calldata _tokens,\r\n        bytes calldata _data\r\n    ) external initializer {\r\n        require(factory == msg.sender, \"not factory\");\r\n        string memory _lpTokenName = \"DForce Stable AMM - \";\r\n        string memory _lpTokenSymbol = \"dAMM-Stable-\";\r\n        string memory _separator = \"-\";\r\n        uint8[] memory _decimals = new uint8[](_tokens.length);\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            _decimals[i] = IPairERC20(_tokens[i]).decimals();\r\n            string memory _tokenSymbol = _tokens[0].callSymbol();\r\n            if (i == _tokens.length - 1) _separator = \"\";\r\n            _lpTokenName = string(\r\n                abi.encodePacked(_lpTokenName, _tokenSymbol, _separator)\r\n            );\r\n            _lpTokenSymbol = string(\r\n                abi.encodePacked(_lpTokenSymbol, _tokenSymbol, _separator)\r\n            );\r\n        }\r\n\r\n        (\r\n            uint256 _swapFee,\r\n            uint256 _adminFeeRate,\r\n            uint256 _a,\r\n            address _lpTokenTargetAddress\r\n        ) = abi.decode(_data, (uint256, uint256, uint256, address));\r\n        __SwapV2_init(\r\n            _tokens,\r\n            _decimals,\r\n            _lpTokenName,\r\n            _lpTokenSymbol,\r\n            _a,\r\n            _swapFee,\r\n            _adminFeeRate,\r\n            _lpTokenTargetAddress\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Initializes this Swap contract with the given parameters.\r\n     * This will also clone a LPToken contract that represents users'\r\n     * LP positions. The owner of LPToken will be this contract - which means\r\n     * only this contract is allowed to mint/burn tokens.\r\n     *\r\n     * @param _pooledTokens an array of ERC20s this pool will accept\r\n     * @param _decimals the decimals to use for each pooled token,\r\n     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\r\n     * @param _lpTokenName the long-form name of the token to be deployed\r\n     * @param _lpTokenSymbol the short symbol for the token to be deployed\r\n     * @param _a the amplification coefficient * n * (n - 1). See the\r\n     * StableSwap paper for details\r\n     * @param _fee default swap fee to be initialized with\r\n     * @param _adminFee default adminFee to be initialized with\r\n     * @param _lpTokenTargetAddress the address of an existing LPToken contract to use as a target\r\n     */\r\n    function __SwapV2_init(\r\n        address[] memory _pooledTokens,\r\n        uint8[] memory _decimals,\r\n        string memory _lpTokenName,\r\n        string memory _lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        address _lpTokenTargetAddress\r\n    ) internal virtual {\r\n        // Check _pooledTokens and precisions parameter\r\n        require(_pooledTokens.length > 1, \"_pooledTokens.length <= 1\");\r\n        require(_pooledTokens.length <= 32, \"_pooledTokens.length > 32\");\r\n        require(\r\n            _pooledTokens.length == _decimals.length,\r\n            \"_pooledTokens decimals mismatch\"\r\n        );\r\n\r\n        uint256[] memory _precisionMultipliers = new uint256[](\r\n            _decimals.length\r\n        );\r\n        IERC20[] memory _poolTokens = new IERC20[](_decimals.length);\r\n\r\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\r\n            if (i > 0) {\r\n                // Check if index is already used. Check if 0th element is a duplicate.\r\n                require(\r\n                    tokenIndexes_[_pooledTokens[i]] == 0 &&\r\n                        _pooledTokens[0] != _pooledTokens[i],\r\n                    \"Duplicate tokens\"\r\n                );\r\n            }\r\n            require(\r\n                _pooledTokens[i] != address(0) &&\r\n                    _pooledTokens[i] != address(this),\r\n                \"The 0 address isn't an ERC-20\"\r\n            );\r\n            require(\r\n                _decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS,\r\n                \"Token decimals exceeds max\"\r\n            );\r\n            _precisionMultipliers[i] =\r\n                10 **\r\n                    (uint256(SwapUtils.POOL_PRECISION_DECIMALS) -\r\n                        uint256(_decimals[i]));\r\n            _poolTokens[i] = IERC20(_pooledTokens[i]);\r\n            tokenIndexes_[_pooledTokens[i]] = i;\r\n        }\r\n\r\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\r\n        require(_a < AmplificationUtils.MAX_A, \"_a exceeds maximum\");\r\n        require(_fee < SwapUtils.MAX_SWAP_FEE, \"_fee exceeds maximum\");\r\n        require(\r\n            _adminFee < SwapUtils.MAX_ADMIN_FEE,\r\n            \"_adminFee exceeds maximum\"\r\n        );\r\n\r\n        // Clone and initialize a LPToken contract\r\n        LPToken _lpToken = LPToken(Clones.clone(_lpTokenTargetAddress));\r\n        require(\r\n            _lpToken.initialize(_lpTokenName, _lpTokenSymbol),\r\n            \"could not init lpToken clone\"\r\n        );\r\n\r\n        // Initialize swapStorage struct\r\n        swapStorage.lpToken = _lpToken;\r\n        swapStorage.pooledTokens = _poolTokens;\r\n        swapStorage.tokenPrecisionMultipliers = _precisionMultipliers;\r\n        swapStorage.balances = new uint256[](_pooledTokens.length);\r\n        swapStorage.initialA = _a * AmplificationUtils.A_PRECISION;\r\n        swapStorage.futureA = _a * AmplificationUtils.A_PRECISION;\r\n        // swapStorage.initialATime = 0;\r\n        // swapStorage.futureATime = 0;\r\n        swapStorage.swapFee = _fee;\r\n        swapStorage.adminFee = _adminFee;\r\n    }\r\n\r\n    /*** MODIFIERS ***/\r\n\r\n    /**\r\n     * @notice Modifier to check sender against factory manager.\r\n     */\r\n    modifier onlyManager() {\r\n        require(\r\n            factory == msg.sender ||\r\n                IPairFactory(factory).manager() == msg.sender,\r\n            \"Ownable: caller is not the owner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice contract function lock modifier.\r\n     */\r\n    modifier lock() {\r\n        require(unlocked_ == 1, \"Pair: LOCKED\");\r\n        unlocked_ = 0;\r\n        _;\r\n        unlocked_ = 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Modifier to check _deadline against current timestamp\r\n     * @param _deadline latest timestamp to accept this transaction\r\n     */\r\n    modifier deadlineCheck(uint256 _deadline) {\r\n        require(block.timestamp <= _deadline, \"Deadline not met\");\r\n        _;\r\n    }\r\n\r\n    /*** VIEW FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Return A, the amplification coefficient * n * (n - 1)\r\n     * @dev See the StableSwap paper for details\r\n     * @return A parameter\r\n     */\r\n    function getA() external view virtual returns (uint256) {\r\n        return swapStorage.getA();\r\n    }\r\n\r\n    /**\r\n     * @notice Return A in its raw precision form\r\n     * @dev See the StableSwap paper for details\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function getAPrecise() external view virtual returns (uint256) {\r\n        return swapStorage.getAPrecise();\r\n    }\r\n\r\n    /**\r\n     * @notice Return address of the pooled token at given index. Reverts if _tokenIndex is out of range.\r\n     * @param _index the index of the token\r\n     * @return address of the token at given index\r\n     */\r\n    function getToken(uint8 _index) public view virtual returns (address) {\r\n        require(_index < swapStorage.pooledTokens.length, \"Out of range\");\r\n        return address(swapStorage.pooledTokens[_index]);\r\n    }\r\n\r\n    /**\r\n     * @notice Query all token addresses in pair.\r\n     * @return all token addresses\r\n     */\r\n    function tokens() external view returns (IERC20[] memory) {\r\n        return swapStorage.pooledTokens;\r\n    }\r\n\r\n    /**\r\n     * @notice Query lpToken addresse.\r\n     * @return lpToken addresse\r\n     */\r\n    function lpToken() external view returns (address) {\r\n        return address(swapStorage.lpToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Return the index of the given token address. Reverts if no matching\r\n     * token is found.\r\n     * @param _tokenAddress address of the token\r\n     * @return the index of the given token address\r\n     */\r\n    function getTokenIndex(\r\n        address _tokenAddress\r\n    ) external view virtual returns (uint8) {\r\n        uint8 _index = tokenIndexes_[_tokenAddress];\r\n        require(getToken(_index) == _tokenAddress, \"Token does not exist\");\r\n        return _index;\r\n    }\r\n\r\n    /**\r\n     * @notice Return current balance of the pooled token at given index\r\n     * @param _index the index of the token\r\n     * @return current balance of the pooled token at given index with token's native precision\r\n     */\r\n    function getTokenBalance(\r\n        uint8 _index\r\n    ) external view virtual returns (uint256) {\r\n        require(_index < swapStorage.pooledTokens.length, \"Index out of range\");\r\n        return swapStorage.balances[_index];\r\n    }\r\n\r\n    /**\r\n     * @notice Return current balances of the pooled tokens\r\n     * @return current balances of the pooled tokens\r\n     */\r\n    function getTokenBalances()\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256[] memory)\r\n    {\r\n        return swapStorage.balances;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the virtual price, to help calculate profit\r\n     * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\r\n     */\r\n    function getVirtualPrice() external view virtual returns (uint256) {\r\n        return swapStorage.getVirtualPrice();\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate amount of tokens you receive on swap\r\n     * @param _tokenFrom the token address the user wants to sell\r\n     * @param _tokenTo the token address the user wants to buy\r\n     * @param _dx the amount of tokens the user wants to sell. If the token charges\r\n     * a fee on transfers, use the amount that gets transferred after the fee.\r\n     * @return amount of tokens the user will receive\r\n     */\r\n    function getAmountOut(\r\n        address _tokenFrom,\r\n        address _tokenTo,\r\n        uint256 _dx\r\n    ) external view returns (uint256) {\r\n        return\r\n            swapStorage.calculateSwap(\r\n                tokenIndexes_[_tokenFrom],\r\n                tokenIndexes_[_tokenTo],\r\n                _dx\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Convert the array index, according to tokenIndexes_.\r\n     * @param _tokens an array of all token addresses for the pair,\r\n     * @param _amounts an array of token amounts, corresponding to param _tokens.\r\n     * @return _newAmounts amount of tokens after conversion\r\n     */\r\n    function _convertIndex(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts\r\n    ) internal view returns (uint256[] memory _newAmounts) {\r\n        _newAmounts = _amounts;\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            _newAmounts[tokenIndexes_[_tokens[i]]] = _amounts[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate prices from deposits or\r\n     * withdrawals, excluding fees but including slippage. This is\r\n     * helpful as an input into the various \"min\" parameters on calls\r\n     * to fight front-running\r\n     *\r\n     * @dev This shouldn't be used outside frontends for user estimates.\r\n     *\r\n     * @param _tokens an array of all token addresses for the pair,\r\n     * @param _amounts an array of token amounts to deposit or withdrawal,\r\n     * corresponding to param _tokens. The amount should be in each\r\n     * pooled token's native precision. If a token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @param _deposit whether this is a deposit or a withdrawal\r\n     * @return token amount the user will receive\r\n     */\r\n    function calculateTokenAmount(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts,\r\n        bool _deposit\r\n    ) external view virtual returns (uint256) {\r\n        return\r\n            swapStorage.calculateTokenAmount(\r\n                _convertIndex(_tokens, _amounts),\r\n                _deposit\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate amount of each underlying\r\n     * tokens that is returned upon burning given amount of LP tokens\r\n     * @param _tokens token address list\r\n     * @param _amount the amount of LP tokens that would be burned on withdrawal\r\n     * @return array of token balances that the user will receive\r\n     */\r\n    function calculateRemoveLiquidity(\r\n        address[] calldata _tokens,\r\n        uint256 _amount\r\n    ) external view virtual returns (uint256[] memory) {\r\n        uint256[] memory _amounts = swapStorage.calculateRemoveLiquidity(\r\n            _amount\r\n        );\r\n        uint256[] memory _actualAmounts = _amounts;\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            _actualAmounts[i] = _amounts[tokenIndexes_[_tokens[i]]];\r\n        }\r\n        return _actualAmounts;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the amount of underlying token available to withdraw\r\n     * when withdrawing via only single token\r\n     * @param _token address of tokens that will be withdrawn\r\n     * @param _tokenAmount the amount of LP token to burn\r\n     * @return calculated amount of underlying token\r\n     * available to withdraw\r\n     */\r\n    function calculateRemoveLiquidityOneToken(\r\n        address _token,\r\n        uint256 _tokenAmount\r\n    ) external view virtual returns (uint256) {\r\n        return\r\n            swapStorage.calculateWithdrawOneToken(\r\n                _tokenAmount,\r\n                tokenIndexes_[_token]\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice This function reads the accumulated amount of admin fees of the token with given index\r\n     * @param _index Index of the pooled token\r\n     * @return admin's token balance in the token's precision\r\n     */\r\n    function getAdminBalance(\r\n        uint256 _index\r\n    ) external view virtual returns (uint256) {\r\n        return swapStorage.getAdminBalance(_index);\r\n    }\r\n\r\n    /*** STATE MODIFYING FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Calculate amount of tokens you receive on swap\r\n     * @param _tokenFrom the token address the user wants to sell\r\n     * @param _tokenTo the token address the user wants to buy\r\n     * @param _dx the amount of tokens the user wants to swap from\r\n     * @param _minDy the min amount the user would like to receive, or revert.\r\n     * @param _receiver recipient address\r\n     * @param _deadline latest timestamp to accept this transaction\r\n     */\r\n    function swap(\r\n        address _tokenFrom,\r\n        address _tokenTo,\r\n        uint256 _dx,\r\n        uint256 _minDy,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external lock deadlineCheck(_deadline) returns (uint256) {\r\n        return\r\n            swapStorage.swap(\r\n                tokenIndexes_[_tokenFrom],\r\n                tokenIndexes_[_tokenTo],\r\n                _dx,\r\n                _minDy,\r\n                _receiver\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Add liquidity to the pool with the given amounts of tokens\r\n     * @param _tokens token address list\r\n     * @param _amounts the amounts of each token to add, in their native precision,corresponding to param _tokens\r\n     * @param _minToMint the minimum LP tokens adding this amount of liquidity\r\n     * should mint, otherwise revert. Handy for front-running mitigation\r\n     * @param _receiver recipient address\r\n     * @param _deadline latest timestamp to accept this transaction\r\n     * @return amount of LP token user minted and received\r\n     */\r\n    function addLiquidity(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts,\r\n        uint256 _minToMint,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external lock deadlineCheck(_deadline) returns (uint256) {\r\n        return\r\n            swapStorage.addLiquidity(\r\n                _convertIndex(_tokens, _amounts),\r\n                _minToMint,\r\n                _receiver\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @dev Liquidity can always be removed, even when the pool is paused.\r\n     * @param _amount the amount of LP tokens to burn\r\n     * @param _tokens token address list\r\n     * @param _minAmounts the minimum amounts of each token in the pool\r\n     *        acceptable for this burn. Useful as a front-running mitigation\r\n     * @param _receiver recipient address\r\n     * @param _deadline latest timestamp to accept this transaction\r\n     * @return amounts of tokens user received\r\n     */\r\n    function removeLiquidity(\r\n        uint256 _amount,\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _minAmounts,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        lock\r\n        deadlineCheck(_deadline)\r\n        returns (uint256[] memory)\r\n    {\r\n        return\r\n            swapStorage.removeLiquidity(\r\n                _amount,\r\n                _convertIndex(_tokens, _minAmounts),\r\n                _receiver\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @param _tokenAmount the amount of the token you want to receive\r\n     * @param _token address of the token you want to receive\r\n     * @param _minAmount the minimum amount to withdraw, otherwise revert\r\n     * @param _receiver recipient address\r\n     * @param _deadline latest timestamp to accept this transaction\r\n     * @return amount of chosen token user received\r\n     */\r\n    function removeLiquidityOneToken(\r\n        uint256 _tokenAmount,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external lock deadlineCheck(_deadline) returns (uint256) {\r\n        return\r\n            swapStorage.removeLiquidityOneToken(\r\n                _tokenAmount,\r\n                tokenIndexes_[_token],\r\n                _minAmount,\r\n                _receiver\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool, weighted differently than the\r\n     * pool's current balances. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @param _tokens token address list\r\n     * @param _amounts how much of each token to withdraw\r\n     * @param _maxBurnAmount the max LP token provider is willing to pay to\r\n     * remove liquidity. Useful as a front-running mitigation.\r\n     * @param _receiver recipient address\r\n     * @param _deadline latest timestamp to accept this transaction\r\n     * @return amount of LP tokens burned\r\n     */\r\n    function removeLiquidityImbalance(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external lock deadlineCheck(_deadline) returns (uint256) {\r\n        return\r\n            swapStorage.removeLiquidityImbalance(\r\n                _convertIndex(_tokens, _amounts),\r\n                _maxBurnAmount,\r\n                _receiver\r\n            );\r\n    }\r\n\r\n    /*** ADMIN FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Withdraw all admin fees to the contract factory manager\r\n     */\r\n    function claimFees() external returns (uint256[] memory) {\r\n        return swapStorage.withdrawAdminFees(IPairFactory(factory).manager());\r\n    }\r\n\r\n    /**\r\n     * @notice Update the admin fee. Admin fee takes portion of the swap fee.\r\n     * @param _newAdminFee new admin fee to be applied on future transactions\r\n     */\r\n    function setAdminFeeRate(uint256 _newAdminFee) external onlyManager {\r\n        swapStorage.setAdminFee(_newAdminFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the swap fee to be applied on swaps\r\n     * @param _newSwapFee new swap fee to be applied on future transactions\r\n     */\r\n    function setSwapFee(uint256 _newSwapFee) external payable onlyManager {\r\n        swapStorage.setSwapFee(_newSwapFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Start ramping up or down A parameter towards given futureA and futureTime\r\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\r\n     * the limit range.\r\n     * @param _futureA the new A to ramp towards\r\n     * @param _futureTime timestamp when the new A should be reached\r\n     */\r\n    function rampA(\r\n        uint256 _futureA,\r\n        uint256 _futureTime\r\n    ) external payable onlyManager {\r\n        swapStorage.rampA(_futureA, _futureTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\r\n     */\r\n    function stopRampA() external payable onlyManager {\r\n        swapStorage.stopRampA();\r\n    }\r\n}\r\n"
    },
    "contracts/test/Create2Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\nimport \"../VolatilePair.sol\";\r\n\r\ncontract Create2Test {\r\n    function getCreate2Address(\r\n        address _factory,\r\n        address[] memory _tokens,\r\n        bool _stable,\r\n        uint256 _fee\r\n    ) public pure returns (address) {\r\n        bytes32 salt = keccak256(abi.encodePacked(_tokens, _stable, _fee));\r\n\r\n        return address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), _factory, salt, keccak256(abi.encodePacked(type(VolatilePair).creationCode)))))));\r\n    }\r\n}\r\n"
    },
    "contracts/utils/AmplificationUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"./SwapUtils.sol\";\r\n\r\n/**\r\n * @title AmplificationUtils library\r\n * @notice A library to calculate and ramp the A parameter of a given `SwapUtils.Swap` struct.\r\n * This library assumes the struct is fully validated.\r\n */\r\nlibrary AmplificationUtils {\r\n    event RampA(\r\n        uint256 oldA,\r\n        uint256 newA,\r\n        uint256 initialTime,\r\n        uint256 futureTime\r\n    );\r\n    event StopRampA(uint256 currentA, uint256 time);\r\n\r\n    // Constant values used in ramping A calculations\r\n    uint256 internal constant A_PRECISION = 100;\r\n    uint256 internal constant MAX_A = 10**6;\r\n    uint256 private constant MAX_A_CHANGE = 2;\r\n    uint256 private constant MIN_RAMP_TIME = 14 days;\r\n\r\n    /**\r\n     * @notice Return A, the amplification coefficient * n * (n - 1)\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter\r\n     */\r\n    function getA(SwapUtils.Swap storage self)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return (_getAPrecise(self) / A_PRECISION);\r\n    }\r\n\r\n    /**\r\n     * @notice Return A in its raw precision\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function getAPrecise(SwapUtils.Swap storage self)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _getAPrecise(self);\r\n    }\r\n\r\n    /**\r\n     * @notice Return A in its raw precision\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function _getAPrecise(SwapUtils.Swap storage self)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 t1 = self.futureATime; // time when ramp is finished\r\n        uint256 a1 = self.futureA; // final A value when ramp is finished\r\n\r\n        if (block.timestamp < t1) {\r\n            uint256 t0 = self.initialATime; // time when ramp is started\r\n            uint256 a0 = self.initialA; // initial A value when ramp is started\r\n            if (a1 > a0) {\r\n                // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\r\n                return a0 + (((a1 - a0) * (block.timestamp - t0)) / (t1 - t0));\r\n            } else {\r\n                // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\r\n                return a0 - (((a0 - a1) * (block.timestamp - t0)) / (t1 - t0));\r\n            }\r\n        } else {\r\n            return a1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\r\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\r\n     * the limit range.\r\n     * @param self Swap struct to update\r\n     * @param futureA_ the new A to ramp towards\r\n     * @param futureTime_ timestamp when the new A should be reached\r\n     */\r\n    function rampA(\r\n        SwapUtils.Swap storage self,\r\n        uint256 futureA_,\r\n        uint256 futureTime_\r\n    ) internal {\r\n        require(\r\n            block.timestamp >= (self.initialATime + (1 days)),\r\n            \"Wait 1 day before starting ramp\"\r\n        );\r\n        require(\r\n            futureTime_ >= (block.timestamp + MIN_RAMP_TIME),\r\n            \"Insufficient ramp time\"\r\n        );\r\n        require(\r\n            futureA_ > 0 && futureA_ < MAX_A,\r\n            \"futureA_ must be > 0 and < MAX_A\"\r\n        );\r\n\r\n        uint256 initialAPrecise = _getAPrecise(self);\r\n        uint256 futureAPrecise = futureA_ * A_PRECISION;\r\n\r\n        if (futureAPrecise < initialAPrecise) {\r\n            require(\r\n                (futureAPrecise * MAX_A_CHANGE) >= initialAPrecise,\r\n                \"futureA_ is too small\"\r\n            );\r\n        } else {\r\n            require(\r\n                futureAPrecise <= (initialAPrecise * MAX_A_CHANGE),\r\n                \"futureA_ is too large\"\r\n            );\r\n        }\r\n\r\n        self.initialA = initialAPrecise;\r\n        self.futureA = futureAPrecise;\r\n        self.initialATime = block.timestamp;\r\n        self.futureATime = futureTime_;\r\n\r\n        emit RampA(\r\n            initialAPrecise,\r\n            futureAPrecise,\r\n            block.timestamp,\r\n            futureTime_\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Stops ramping A immediately. Once this function is called, rampA()\r\n     * cannot be called for another 24 hours\r\n     * @param self Swap struct to update\r\n     */\r\n    function stopRampA(SwapUtils.Swap storage self) internal {\r\n        require(self.futureATime > block.timestamp, \"Ramp is already stopped\");\r\n\r\n        uint256 currentA = _getAPrecise(self);\r\n        self.initialA = currentA;\r\n        self.futureA = currentA;\r\n        self.initialATime = block.timestamp;\r\n        self.futureATime = block.timestamp;\r\n\r\n        emit StopRampA(currentA, block.timestamp);\r\n    }\r\n}\r\n"
    },
    "contracts/utils/Arrays.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\nlibrary Arrays {\r\n    function sortArray(address[] memory arr) internal pure returns (address[] memory) {\r\n        uint256 l = arr.length;\r\n        for (uint256 i = 0; i < l; i++) {\r\n            for (uint256 j = i + 1; j < l; j++) {\r\n                if (arr[i] > arr[j]) {\r\n                    address temp = arr[i];\r\n                    arr[i] = arr[j];\r\n                    arr[j] = temp;\r\n                }\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function copyAndAddOne(address[] memory arr, address _add) internal pure returns (address[] memory _result) {\r\n        _result = new address[](arr.length + 1);\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            _result[i] = arr[i];\r\n        }\r\n        _result[arr.length] = _add;\r\n    }\r\n\r\n    function removeEmpty(address[] memory arr) internal pure returns (address[] memory _new) {\r\n        uint256 count;\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            if (arr[i] != address(0)) {\r\n                count++;\r\n            }\r\n        }\r\n        _new = new address[](count);\r\n        uint256 j;\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            if (arr[i] == address(0)) {\r\n                continue;\r\n            }\r\n            _new[j] = arr[i];\r\n            j++;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/utils/ERC20Call.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\nlibrary ERC20Call {\r\n\r\n    function callSymbol(address _token)\r\n        internal\r\n        view\r\n        returns (string memory _symbol)\r\n    {\r\n        if (_token != address(0)) {\r\n            (bool _success, bytes memory _res) =\r\n                _token.staticcall(abi.encodeWithSignature(\"symbol()\"));\r\n            if (_success)\r\n                _symbol = _res.length == 32\r\n                    ? string(_res)\r\n                    : abi.decode(_res, (string));\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/utils/LPToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// import \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"../lib/PairERC20.sol\";\r\n\r\n/**\r\n * @title Liquidity Provider Token\r\n * @notice This token is an ERC20 detailed token with added capability to be minted by the owner.\r\n * It is used to represent user's shares when providing liquidity to swap contracts.\r\n * @dev Only Swap contracts should initialize and own LPToken contracts.\r\n */\r\ncontract LPToken is OwnableUpgradeable, PairERC20 {\r\n    /**\r\n     * @notice Initializes this LPToken contract with the given name and symbol\r\n     * @dev The caller of this function will become the owner. A Swap contract should call this\r\n     * in its initializer function.\r\n     * @param name name of this token\r\n     * @param symbol symbol of this token\r\n     */\r\n    function initialize(string memory name, string memory symbol)\r\n        external\r\n        initializer\r\n        returns (bool)\r\n    {\r\n        __Context_init_unchained();\r\n        __Ownable_init_unchained();\r\n        _setNameAndSymbol(name, symbol);\r\n        return true;\r\n    }\r\n\r\n    modifier addressCheck(address recipient) {\r\n        require(recipient != address(this), \"LPToken: cannot send to itself\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Mints the given amount of LPToken to the recipient.\r\n     * @dev only owner can call this mint function\r\n     * @param recipient address of account to receive the tokens\r\n     * @param amount amount of tokens to mint\r\n     */\r\n    function mint(address recipient, uint256 amount) external onlyOwner addressCheck(recipient) {\r\n        require(amount != 0, \"LPToken: cannot mint 0\");\r\n        _mint(recipient, amount);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal override addressCheck(to) {\r\n        super._transfer(from, to, value);\r\n    }\r\n\r\n    function burnFrom(address from, uint256 value) external {\r\n        if (allowance[from][msg.sender] != type(uint256).max) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender] - value;\r\n        }\r\n        _burn(from, value);\r\n    }\r\n}\r\n"
    },
    "contracts/utils/MathUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title MathUtils library\r\n * @notice A library to be used in conjunction with SafeMath. Contains functions for calculating\r\n * differences between two uint256.\r\n */\r\nlibrary MathUtils {\r\n    /**\r\n     * @notice Compares a and b and returns true if the difference between a and b\r\n     *         is less than 1 or equal to each other.\r\n     * @param a uint256 to compare with\r\n     * @param b uint256 to compare with\r\n     * @return True if the difference between a and b is less than 1 or equal,\r\n     *         otherwise return false\r\n     */\r\n    function within1(uint256 a, uint256 b) internal pure returns (bool) {\r\n        return (difference(a, b) <= 1);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates absolute difference between a and b\r\n     * @param a uint256 to compare with\r\n     * @param b uint256 to compare with\r\n     * @return Difference between a and b\r\n     */\r\n    function difference(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a > b) {\r\n            return a - b;\r\n        }\r\n        return b - a;\r\n    }\r\n}\r\n"
    },
    "contracts/utils/SwapUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"./AmplificationUtils.sol\";\r\nimport \"./LPToken.sol\";\r\nimport \"./MathUtils.sol\";\r\n\r\n/**\r\n * @title SwapUtils library\r\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\r\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\r\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\r\n * Admin functions should be protected within contracts using this library.\r\n */\r\nlibrary SwapUtils {\r\n    using SafeERC20 for IERC20;\r\n    using MathUtils for uint256;\r\n\r\n    /*** EVENTS ***/\r\n\r\n    event TokenSwap(\r\n        address indexed buyer,\r\n        uint256 tokensSold,\r\n        uint256 tokensBought,\r\n        uint128 soldId,\r\n        uint128 boughtId\r\n    );\r\n    event AddLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidityOne(\r\n        address indexed provider,\r\n        uint256 lpTokenAmount,\r\n        uint256 lpTokenSupply,\r\n        uint256 boughtId,\r\n        uint256 tokensBought\r\n    );\r\n    event RemoveLiquidityImbalance(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event NewAdminFee(uint256 newAdminFee);\r\n    event NewSwapFee(uint256 newSwapFee);\r\n\r\n    struct Swap {\r\n        // variables around the ramp management of A,\r\n        // the amplification coefficient * n * (n - 1)\r\n        // see https://www.curve.fi/stableswap-paper.pdf for details\r\n        uint256 initialA;\r\n        uint256 futureA;\r\n        uint256 initialATime;\r\n        uint256 futureATime;\r\n        // fee calculation\r\n        uint256 swapFee;\r\n        uint256 adminFee;\r\n        LPToken lpToken;\r\n        // contract references for all tokens being pooled\r\n        IERC20[] pooledTokens;\r\n        // multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS\r\n        // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\r\n        // has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10\r\n        uint256[] tokenPrecisionMultipliers;\r\n        // the pool balance of each token, in the token's precision\r\n        // the contract's actual token balance might differ\r\n        uint256[] balances;\r\n    }\r\n\r\n    // Struct storing variables used in calculations in the\r\n    // calculateWithdrawOneTokenDY function to avoid stack too deep errors\r\n    struct CalculateWithdrawOneTokenDYInfo {\r\n        uint256 d0;\r\n        uint256 d1;\r\n        uint256 newY;\r\n        uint256 feePerToken;\r\n        uint256 preciseA;\r\n    }\r\n\r\n    // Struct storing variables used in calculations in the\r\n    // {add,remove}Liquidity functions to avoid stack too deep errors\r\n    struct ManageLiquidityInfo {\r\n        uint256 d0;\r\n        uint256 d1;\r\n        uint256 d2;\r\n        uint256 preciseA;\r\n        LPToken lpToken;\r\n        uint256 totalSupply;\r\n        uint256[] balances;\r\n        uint256[] multipliers;\r\n    }\r\n\r\n    // the precision all pools tokens will be converted to\r\n    uint8 public constant POOL_PRECISION_DECIMALS = 18;\r\n\r\n    // the denominator used to calculate admin and LP fees. For example, an\r\n    // LP fee might be something like tradeAmount * (fee) / (FEE_DENOMINATOR)\r\n    uint256 private constant FEE_DENOMINATOR = 10**10;\r\n\r\n    // Max swap fee is 1% or 100bps of each swap\r\n    uint256 public constant MAX_SWAP_FEE = 10**8;\r\n\r\n    // Max adminFee is 100% of the swapFee\r\n    // adminFee does not add additional fee on top of swapFee\r\n    // Instead it takes a certain % of the swapFee. Therefore it has no impact on the\r\n    // users but only on the earnings of LPs\r\n    uint256 public constant MAX_ADMIN_FEE = 10**10;\r\n\r\n    // Constant value used as max loop limit\r\n    uint256 private constant MAX_LOOP_LIMIT = 256;\r\n\r\n    /*** VIEW & PURE FUNCTIONS ***/\r\n\r\n    function _getAPrecise(Swap storage self) internal view returns (uint256) {\r\n        return AmplificationUtils._getAPrecise(self);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the dy, the amount of selected token that user receives and\r\n     * the fee of withdrawing in one token\r\n     * @param tokenAmount the amount to withdraw in the pool's precision\r\n     * @param tokenIndex which token will be withdrawn\r\n     * @param self Swap struct to read from\r\n     * @return the amount of token user will receive\r\n     */\r\n    function calculateWithdrawOneToken(\r\n        Swap storage self,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) external view returns (uint256) {\r\n        (uint256 availableTokenAmount, ) = _calculateWithdrawOneToken(\r\n            self,\r\n            tokenAmount,\r\n            tokenIndex,\r\n            self.lpToken.totalSupply()\r\n        );\r\n        return availableTokenAmount;\r\n    }\r\n\r\n    function _calculateWithdrawOneToken(\r\n        Swap storage self,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 totalSupply\r\n    ) internal view returns (uint256, uint256) {\r\n        uint256 dy;\r\n        uint256 newY;\r\n        uint256 currentY;\r\n\r\n        (dy, newY, currentY) = calculateWithdrawOneTokenDY(\r\n            self,\r\n            tokenIndex,\r\n            tokenAmount,\r\n            totalSupply\r\n        );\r\n\r\n        // dy_0 (without fees)\r\n        // dy, dy_0 - dy\r\n\r\n        uint256 dySwapFee = ((currentY - newY) /\r\n            self.tokenPrecisionMultipliers[tokenIndex]) - dy;\r\n\r\n        return (dy, dySwapFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the dy of withdrawing in one token\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndex which token will be withdrawn\r\n     * @param tokenAmount the amount to withdraw in the pools precision\r\n     * @return the d and the new y after withdrawing one token\r\n     */\r\n    function calculateWithdrawOneTokenDY(\r\n        Swap storage self,\r\n        uint8 tokenIndex,\r\n        uint256 tokenAmount,\r\n        uint256 totalSupply\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        // Get the current D, then solve the stableswap invariant\r\n        // y_i for D - tokenAmount\r\n        uint256[] memory xp = _xp(self);\r\n\r\n        require(tokenIndex < xp.length, \"Token index out of range\");\r\n\r\n        CalculateWithdrawOneTokenDYInfo\r\n            memory v = CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\r\n        v.preciseA = _getAPrecise(self);\r\n        v.d0 = getD(xp, v.preciseA);\r\n        v.d1 = v.d0 - ((tokenAmount * v.d0) / totalSupply);\r\n\r\n        require(tokenAmount <= xp[tokenIndex], \"Withdraw exceeds available\");\r\n\r\n        v.newY = getYD(v.preciseA, tokenIndex, xp, v.d1);\r\n\r\n        uint256[] memory xpReduced = new uint256[](xp.length);\r\n\r\n        v.feePerToken = _feePerToken(self.swapFee, xp.length);\r\n        for (uint256 i = 0; i < xp.length; i++) {\r\n            uint256 xpi = xp[i];\r\n            // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\r\n            // else dxExpected = xp[i] - (xp[i] * d1 / d0)\r\n            // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\r\n            xpReduced[i] =\r\n                xpi -\r\n                (((\r\n                    (i == tokenIndex)\r\n                        ? ((xpi * v.d1) / v.d0) - v.newY\r\n                        : xpi - ((xpi * v.d1) / v.d0)\r\n                ) * v.feePerToken) / FEE_DENOMINATOR);\r\n        }\r\n\r\n        uint256 dy = xpReduced[tokenIndex] -\r\n            (getYD(v.preciseA, tokenIndex, xpReduced, v.d1));\r\n        dy = (dy - 1) / self.tokenPrecisionMultipliers[tokenIndex];\r\n\r\n        return (dy, v.newY, xp[tokenIndex]);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the price of a token in the pool with given\r\n     * precision-adjusted balances and a particular D.\r\n     *\r\n     * @dev This is accomplished via solving the invariant iteratively.\r\n     * See the StableSwap paper and Curve.fi implementation for further details.\r\n     *\r\n     * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\r\n     * x_1**2 + b*x_1 = c\r\n     * x_1 = (x_1**2 + c) / (2*x_1 + b)\r\n     *\r\n     * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\r\n     * @param tokenIndex Index of token we are calculating for.\r\n     * @param xp a precision-adjusted set of pool balances. Array should be\r\n     * the same cardinality as the pool.\r\n     * @param d the stableswap invariant\r\n     * @return the price of the token, in the same precision as in xp\r\n     */\r\n    function getYD(\r\n        uint256 a,\r\n        uint8 tokenIndex,\r\n        uint256[] memory xp,\r\n        uint256 d\r\n    ) internal pure returns (uint256) {\r\n        uint256 numTokens = xp.length;\r\n        require(tokenIndex < numTokens, \"Token not found\");\r\n\r\n        uint256 c = d;\r\n        uint256 s;\r\n        uint256 nA = a * (numTokens);\r\n\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            if (i != tokenIndex) {\r\n                s = s + xp[i];\r\n                c = (c * d) / (xp[i] * (numTokens));\r\n                // If we were to protect the division loss we would have to keep the denominator separate\r\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n                // c = c * D * D * D * ... overflow!\r\n            }\r\n        }\r\n        c = (c * d * AmplificationUtils.A_PRECISION) / (nA * numTokens);\r\n\r\n        uint256 b = s + ((d * AmplificationUtils.A_PRECISION) / nA);\r\n        uint256 yPrev;\r\n        uint256 y = d;\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            yPrev = y;\r\n            y = ((y * y) + c) / ((y * 2) + b - d);\r\n            if (y.within1(yPrev)) {\r\n                return y;\r\n            }\r\n        }\r\n        revert(\"Approximation did not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\r\n     * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\r\n     * as the pool.\r\n     * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\r\n     * See the StableSwap paper for details\r\n     * @return the invariant, at the precision of the pool\r\n     */\r\n    function getD(uint256[] memory xp, uint256 a)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 numTokens = xp.length;\r\n        uint256 s;\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            s = s + xp[i];\r\n        }\r\n        if (s == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 prevD;\r\n        uint256 d = s;\r\n        uint256 nA = a * numTokens;\r\n\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            uint256 dP = d;\r\n            for (uint256 j = 0; j < numTokens; j++) {\r\n                dP = (dP * d) / (xp[j] * numTokens);\r\n                // If we were to protect the division loss we would have to keep the denominator separate\r\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n                // dP = dP * D * D * D * ... overflow!\r\n            }\r\n            prevD = d;\r\n            d =\r\n                ((((nA * s) / AmplificationUtils.A_PRECISION) +\r\n                    (dP * numTokens)) * d) /\r\n                ((((nA - AmplificationUtils.A_PRECISION) * d) /\r\n                    AmplificationUtils.A_PRECISION) + ((numTokens + 1) * dP));\r\n            if (d.within1(prevD)) {\r\n                return d;\r\n            }\r\n        }\r\n\r\n        // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\r\n        // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\r\n        // function which does not rely on D.\r\n        revert(\"D does not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Given a set of balances and precision multipliers, return the\r\n     * precision-adjusted balances.\r\n     *\r\n     * @param balances an array of token balances, in their native precisions.\r\n     * These should generally correspond with pooled tokens.\r\n     *\r\n     * @param precisionMultipliers an array of multipliers, corresponding to\r\n     * the amounts in the balances array. When multiplied together they\r\n     * should yield amounts at the pool's precision.\r\n     *\r\n     * @return an array of amounts \"scaled\" to the pool's precision\r\n     */\r\n    function _xp(\r\n        uint256[] memory balances,\r\n        uint256[] memory precisionMultipliers\r\n    ) internal pure returns (uint256[] memory) {\r\n        uint256 numTokens = balances.length;\r\n        require(\r\n            numTokens == precisionMultipliers.length,\r\n            \"Balances must match multipliers\"\r\n        );\r\n        uint256[] memory xp = new uint256[](numTokens);\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            xp[i] = balances[i] * precisionMultipliers[i];\r\n        }\r\n        return xp;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the precision-adjusted balances of all tokens in the pool\r\n     * @param self Swap struct to read from\r\n     * @return the pool balances \"scaled\" to the pool's precision, allowing\r\n     * them to be more easily compared.\r\n     */\r\n    function _xp(Swap storage self) internal view returns (uint256[] memory) {\r\n        return _xp(self.balances, self.tokenPrecisionMultipliers);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the virtual price, to help calculate profit\r\n     * @param self Swap struct to read from\r\n     * @return the virtual price, scaled to precision of POOL_PRECISION_DECIMALS\r\n     */\r\n    function getVirtualPrice(Swap storage self)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 d = getD(_xp(self), _getAPrecise(self));\r\n        LPToken lpToken = self.lpToken;\r\n        uint256 supply = lpToken.totalSupply();\r\n        if (supply > 0) {\r\n            return (d * (10**uint256(POOL_PRECISION_DECIMALS))) / supply;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the new balances of the tokens given the indexes of the token\r\n     * that is swapped from (FROM) and the token that is swapped to (TO).\r\n     * This function is used as a helper function to calculate how much TO token\r\n     * the user should receive on swap.\r\n     *\r\n     * @param preciseA precise form of amplification coefficient\r\n     * @param tokenIndexFrom index of FROM token\r\n     * @param tokenIndexTo index of TO token\r\n     * @param x the new total amount of FROM token\r\n     * @param xp balances of the tokens in the pool\r\n     * @return the amount of TO token that should remain in the pool\r\n     */\r\n    function getY(\r\n        uint256 preciseA,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 x,\r\n        uint256[] memory xp\r\n    ) internal pure returns (uint256) {\r\n        uint256 numTokens = xp.length;\r\n        require(\r\n            tokenIndexFrom != tokenIndexTo,\r\n            \"Can't compare token to itself\"\r\n        );\r\n        require(\r\n            tokenIndexFrom < numTokens && tokenIndexTo < numTokens,\r\n            \"Tokens must be in pool\"\r\n        );\r\n\r\n        uint256 d = getD(xp, preciseA);\r\n        uint256 c = d;\r\n        uint256 s;\r\n        uint256 nA = numTokens * preciseA;\r\n\r\n        uint256 _x;\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            if (i == tokenIndexFrom) {\r\n                _x = x;\r\n            } else if (i != tokenIndexTo) {\r\n                _x = xp[i];\r\n            } else {\r\n                continue;\r\n            }\r\n            s = s + _x;\r\n            c = (c * d) / (_x * numTokens);\r\n            // If we were to protect the division loss we would have to keep the denominator separate\r\n            // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n            // c = c * D * D * D * ... overflow!\r\n        }\r\n        c = (c * d * AmplificationUtils.A_PRECISION) / (nA * numTokens);\r\n        uint256 b = s + ((d * AmplificationUtils.A_PRECISION) / nA);\r\n        uint256 yPrev;\r\n        uint256 y = d;\r\n\r\n        // iterative approximation\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            yPrev = y;\r\n            y = (y * y + c) / (y * 2 + b - d);\r\n            if (y.within1(yPrev)) {\r\n                return y;\r\n            }\r\n        }\r\n        revert(\"Approximation did not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Externally calculates a swap between two tokens.\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndexFrom the token to sell\r\n     * @param tokenIndexTo the token to buy\r\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @return dy the number of tokens the user will get\r\n     */\r\n    function calculateSwap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view returns (uint256 dy) {\r\n        (dy, ) = _calculateSwap(\r\n            self,\r\n            tokenIndexFrom,\r\n            tokenIndexTo,\r\n            dx,\r\n            self.balances\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Internally calculates a swap between two tokens.\r\n     *\r\n     * @dev The caller is expected to transfer the actual amounts (dx and dy)\r\n     * using the token contracts.\r\n     *\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndexFrom the token to sell\r\n     * @param tokenIndexTo the token to buy\r\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @return dy the number of tokens the user will get\r\n     * @return dyFee the associated fee\r\n     */\r\n    function _calculateSwap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256[] memory balances\r\n    ) internal view returns (uint256 dy, uint256 dyFee) {\r\n        uint256[] memory multipliers = self.tokenPrecisionMultipliers;\r\n        uint256[] memory xp = _xp(balances, multipliers);\r\n        require(\r\n            tokenIndexFrom < xp.length && tokenIndexTo < xp.length,\r\n            \"Token index out of range\"\r\n        );\r\n        uint256 x = dx * multipliers[tokenIndexFrom] + xp[tokenIndexFrom];\r\n        uint256 y = getY(\r\n            _getAPrecise(self),\r\n            tokenIndexFrom,\r\n            tokenIndexTo,\r\n            x,\r\n            xp\r\n        );\r\n        dy = xp[tokenIndexTo] - y - 1;\r\n        dyFee = (dy * self.swapFee) / FEE_DENOMINATOR;\r\n        dy = (dy - dyFee) / multipliers[tokenIndexTo];\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate amount of each underlying\r\n     * tokens that is returned upon burning given amount of\r\n     * LP tokens\r\n     *\r\n     * @param amount the amount of LP tokens that would to be burned on\r\n     * withdrawal\r\n     * @return array of amounts of tokens user will receive\r\n     */\r\n    function calculateRemoveLiquidity(Swap storage self, uint256 amount)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        return\r\n            _calculateRemoveLiquidity(\r\n                self.balances,\r\n                amount,\r\n                self.lpToken.totalSupply()\r\n            );\r\n    }\r\n\r\n    function _calculateRemoveLiquidity(\r\n        uint256[] memory balances,\r\n        uint256 amount,\r\n        uint256 totalSupply\r\n    ) internal pure returns (uint256[] memory) {\r\n        require(amount <= totalSupply, \"Cannot exceed total supply\");\r\n\r\n        uint256[] memory amounts = new uint256[](balances.length);\r\n\r\n        for (uint256 i = 0; i < balances.length; i++) {\r\n            amounts[i] = (balances[i] * amount) / totalSupply;\r\n        }\r\n        return amounts;\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate prices from deposits or\r\n     * withdrawals, excluding fees but including slippage. This is\r\n     * helpful as an input into the various \"min\" parameters on calls\r\n     * to fight front-running\r\n     *\r\n     * @dev This shouldn't be used outside frontends for user estimates.\r\n     *\r\n     * @param self Swap struct to read from\r\n     * @param amounts an array of token amounts to deposit or withdrawal,\r\n     * corresponding to pooledTokens. The amount should be in each\r\n     * pooled token's native precision. If a token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @param deposit whether this is a deposit or a withdrawal\r\n     * @return if deposit was true, total amount of lp token that will be minted and if\r\n     * deposit was false, total amount of lp token that will be burned\r\n     */\r\n    function calculateTokenAmount(\r\n        Swap storage self,\r\n        uint256[] calldata amounts,\r\n        bool deposit\r\n    ) external view returns (uint256) {\r\n        uint256 a = _getAPrecise(self);\r\n        uint256[] memory balances = self.balances;\r\n        uint256[] memory multipliers = self.tokenPrecisionMultipliers;\r\n\r\n        uint256 d0 = getD(_xp(balances, multipliers), a);\r\n        for (uint256 i = 0; i < balances.length; i++) {\r\n            if (deposit) {\r\n                balances[i] = balances[i] + amounts[i];\r\n            } else {\r\n                if (amounts[i] > balances[i]) {\r\n                    revert(\"Cannot withdraw more than available\");\r\n                } else {\r\n                    unchecked {\r\n                        balances[i] = balances[i] - amounts[i];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        uint256 d1 = getD(_xp(balances, multipliers), a);\r\n        uint256 totalSupply = self.lpToken.totalSupply();\r\n\r\n        if (deposit) {\r\n            return (((d1 - d0) * totalSupply) / d0);\r\n        } else {\r\n            return (((d0 - d1) * totalSupply) / d0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice return accumulated amount of admin fees of the token with given index\r\n     * @param self Swap struct to read from\r\n     * @param index Index of the pooled token\r\n     * @return admin balance in the token's precision\r\n     */\r\n    function getAdminBalance(Swap storage self, uint256 index)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(index < self.pooledTokens.length, \"Token index out of range\");\r\n        return\r\n            self.pooledTokens[index].balanceOf(address(this)) -\r\n            self.balances[index];\r\n    }\r\n\r\n    /**\r\n     * @notice internal helper function to calculate fee per token multiplier used in\r\n     * swap fee calculations\r\n     * @param swapFee swap fee for the tokens\r\n     * @param numTokens number of tokens pooled\r\n     */\r\n    function _feePerToken(uint256 swapFee, uint256 numTokens)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return ((swapFee * numTokens) / ((numTokens - 1) * 4));\r\n    }\r\n\r\n    /*** STATE MODIFYING FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice swap two tokens in the pool\r\n     * @param self Swap struct to read from and write to\r\n     * @param tokenIndexFrom the token the user wants to sell\r\n     * @param tokenIndexTo the token the user wants to buy\r\n     * @param dx the amount of tokens the user wants to sell\r\n     * @param minDy the min amount the user would like to receive, or revert.\r\n     * @param receiver recipient address\r\n     * @return amount of token user received on swap\r\n     */\r\n    function swap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy,\r\n        address receiver\r\n    ) external returns (uint256) {\r\n        {\r\n            IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\r\n            require(\r\n                dx <= tokenFrom.balanceOf(msg.sender),\r\n                \"Cannot swap more than you own\"\r\n            );\r\n            // Transfer tokens first to see if a fee was charged on transfer\r\n            uint256 beforeBalance = tokenFrom.balanceOf(address(this));\r\n            tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\r\n\r\n            // Use the actual transferred amount for AMM math\r\n            dx = tokenFrom.balanceOf(address(this)) - beforeBalance;\r\n        }\r\n\r\n        uint256 dy;\r\n        uint256 dyFee;\r\n        uint256[] memory balances = self.balances;\r\n        (dy, dyFee) = _calculateSwap(\r\n            self,\r\n            tokenIndexFrom,\r\n            tokenIndexTo,\r\n            dx,\r\n            balances\r\n        );\r\n        require(dy >= minDy, \"Swap didn't result in min tokens\");\r\n\r\n        uint256 dyAdminFee = (((dyFee * self.adminFee) / FEE_DENOMINATOR) /\r\n            self.tokenPrecisionMultipliers[tokenIndexTo]);\r\n\r\n        self.balances[tokenIndexFrom] = balances[tokenIndexFrom] + dx;\r\n        self.balances[tokenIndexTo] = balances[tokenIndexTo] - dy - dyAdminFee;\r\n\r\n        self.pooledTokens[tokenIndexTo].safeTransfer(receiver, dy);\r\n\r\n        emit TokenSwap(receiver, dx, dy, tokenIndexFrom, tokenIndexTo);\r\n\r\n        return dy;\r\n    }\r\n\r\n    /**\r\n     * @notice Add liquidity to the pool\r\n     * @param self Swap struct to read from and write to\r\n     * @param amounts the amounts of each token to add, in their native precision\r\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\r\n     * should mint, otherwise revert. Handy for front-running mitigation\r\n     * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\r\n     * @param receiver recipient address\r\n     * @return amount of LP token user received\r\n     */\r\n    function addLiquidity(\r\n        Swap storage self,\r\n        uint256[] memory amounts,\r\n        uint256 minToMint,\r\n        address receiver\r\n    ) external returns (uint256) {\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n        require(\r\n            amounts.length == pooledTokens.length,\r\n            \"Amounts must match pooled tokens\"\r\n        );\r\n\r\n        // current state\r\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\r\n            0,\r\n            0,\r\n            0,\r\n            _getAPrecise(self),\r\n            self.lpToken,\r\n            0,\r\n            self.balances,\r\n            self.tokenPrecisionMultipliers\r\n        );\r\n        v.totalSupply = v.lpToken.totalSupply();\r\n\r\n        if (v.totalSupply != 0) {\r\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\r\n        }\r\n\r\n        uint256[] memory newBalances = new uint256[](pooledTokens.length);\r\n\r\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n            require(\r\n                v.totalSupply != 0 || amounts[i] > 0,\r\n                \"Must supply all tokens in pool\"\r\n            );\r\n\r\n            // Transfer tokens first to see if a fee was charged on transfer\r\n            if (amounts[i] != 0) {\r\n                uint256 beforeBalance = pooledTokens[i].balanceOf(\r\n                    address(this)\r\n                );\r\n                pooledTokens[i].safeTransferFrom(\r\n                    msg.sender,\r\n                    address(this),\r\n                    amounts[i]\r\n                );\r\n\r\n                // Update the amounts[] with actual transfer amount\r\n                amounts[i] =\r\n                    pooledTokens[i].balanceOf(address(this)) -\r\n                    beforeBalance;\r\n            }\r\n\r\n            newBalances[i] = v.balances[i] + amounts[i];\r\n        }\r\n        // invariant after change\r\n        v.d1 = getD(_xp(newBalances, v.multipliers), v.preciseA);\r\n        require(v.d1 > v.d0, \"D should increase\");\r\n        // updated to reflect fees and calculate the user's LP tokens\r\n        v.d2 = v.d1;\r\n        uint256[] memory fees = new uint256[](pooledTokens.length);\r\n\r\n        if (v.totalSupply != 0) {\r\n            uint256 feePerToken = _feePerToken(\r\n                self.swapFee,\r\n                pooledTokens.length\r\n            );\r\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n                uint256 idealBalance = (v.d1 * v.balances[i]) / v.d0;\r\n                fees[i] =\r\n                    (feePerToken * idealBalance.difference(newBalances[i])) /\r\n                    FEE_DENOMINATOR;\r\n                self.balances[i] =\r\n                    newBalances[i] -\r\n                    ((fees[i] * self.adminFee) / FEE_DENOMINATOR);\r\n                newBalances[i] = newBalances[i] - fees[i];\r\n            }\r\n            v.d2 = getD(_xp(newBalances, v.multipliers), v.preciseA);\r\n        } else {\r\n            // the initial depositor doesn't pay fees\r\n            self.balances = newBalances;\r\n        }\r\n\r\n        uint256 toMint;\r\n        if (v.totalSupply == 0) {\r\n            toMint = v.d1;\r\n        } else {\r\n            toMint = ((v.d2 - v.d0) * v.totalSupply) / v.d0;\r\n        }\r\n\r\n        require(toMint >= minToMint, \"Couldn't mint min requested\");\r\n\r\n        // mint the user's LP tokens\r\n        v.lpToken.mint(receiver, toMint);\r\n\r\n        emit AddLiquidity(\r\n            receiver,\r\n            amounts,\r\n            fees,\r\n            v.d1,\r\n            v.totalSupply + toMint\r\n        );\r\n\r\n        return toMint;\r\n    }\r\n\r\n    /**\r\n     * @notice Burn LP tokens to remove liquidity from the pool.\r\n     * @dev Liquidity can always be removed, even when the pool is paused.\r\n     * @param self Swap struct to read from and write to\r\n     * @param amount the amount of LP tokens to burn\r\n     * @param minAmounts the minimum amounts of each token in the pool\r\n     * acceptable for this burn. Useful as a front-running mitigation\r\n     * @param receiver recipient address\r\n     * @return amounts of tokens the user received\r\n     */\r\n    function removeLiquidity(\r\n        Swap storage self,\r\n        uint256 amount,\r\n        uint256[] calldata minAmounts,\r\n        address receiver\r\n    ) external returns (uint256[] memory) {\r\n        LPToken lpToken = self.lpToken;\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n        require(amount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\r\n        require(\r\n            minAmounts.length == pooledTokens.length,\r\n            \"minAmounts must match poolTokens\"\r\n        );\r\n\r\n        uint256[] memory balances = self.balances;\r\n        uint256 totalSupply = lpToken.totalSupply();\r\n\r\n        uint256[] memory amounts = _calculateRemoveLiquidity(\r\n            balances,\r\n            amount,\r\n            totalSupply\r\n        );\r\n\r\n        for (uint256 i = 0; i < amounts.length; i++) {\r\n            require(amounts[i] >= minAmounts[i], \"amounts[i] < minAmounts[i]\");\r\n            self.balances[i] = balances[i] - amounts[i];\r\n            pooledTokens[i].safeTransfer(receiver, amounts[i]);\r\n        }\r\n\r\n        lpToken.burnFrom(msg.sender, amount);\r\n\r\n        emit RemoveLiquidity(receiver, amounts, totalSupply - amount);\r\n\r\n        return amounts;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool all in one token.\r\n     * @param self Swap struct to read from and write to\r\n     * @param tokenAmount the amount of the lp tokens to burn\r\n     * @param tokenIndex the index of the token you want to receive\r\n     * @param minAmount the minimum amount to withdraw, otherwise revert\r\n     * @param receiver recipient address\r\n     * @return amount chosen token that user received\r\n     */\r\n    function removeLiquidityOneToken(\r\n        Swap storage self,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount,\r\n        address receiver\r\n    ) external returns (uint256) {\r\n        LPToken lpToken = self.lpToken;\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n\r\n        require(tokenAmount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\r\n        require(tokenIndex < pooledTokens.length, \"Token not found\");\r\n\r\n        uint256 totalSupply = lpToken.totalSupply();\r\n\r\n        (uint256 dy, uint256 dyFee) = _calculateWithdrawOneToken(\r\n            self,\r\n            tokenAmount,\r\n            tokenIndex,\r\n            totalSupply\r\n        );\r\n\r\n        require(dy >= minAmount, \"dy < minAmount\");\r\n\r\n        self.balances[tokenIndex] =\r\n            self.balances[tokenIndex] -\r\n            (dy + ((dyFee * self.adminFee) / FEE_DENOMINATOR));\r\n        lpToken.burnFrom(msg.sender, tokenAmount);\r\n        pooledTokens[tokenIndex].safeTransfer(receiver, dy);\r\n\r\n        emit RemoveLiquidityOne(\r\n            receiver,\r\n            tokenAmount,\r\n            totalSupply,\r\n            tokenIndex,\r\n            dy\r\n        );\r\n\r\n        return dy;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool, weighted differently than the\r\n     * pool's current balances.\r\n     *\r\n     * @param self Swap struct to read from and write to\r\n     * @param amounts how much of each token to withdraw\r\n     * @param maxBurnAmount the max LP token provider is willing to pay to\r\n     * remove liquidity. Useful as a front-running mitigation.\r\n     * @param receiver recipient address\r\n     * @return actual amount of LP tokens burned in the withdrawal\r\n     */\r\n    function removeLiquidityImbalance(\r\n        Swap storage self,\r\n        uint256[] calldata amounts,\r\n        uint256 maxBurnAmount,\r\n        address receiver\r\n    ) external returns (uint256) {\r\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\r\n            0,\r\n            0,\r\n            0,\r\n            _getAPrecise(self),\r\n            self.lpToken,\r\n            0,\r\n            self.balances,\r\n            self.tokenPrecisionMultipliers\r\n        );\r\n        v.totalSupply = v.lpToken.totalSupply();\r\n\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n\r\n        require(\r\n            amounts.length == pooledTokens.length,\r\n            \"Amounts should match pool tokens\"\r\n        );\r\n\r\n        require(\r\n            maxBurnAmount <= v.lpToken.balanceOf(msg.sender) &&\r\n                maxBurnAmount != 0,\r\n            \">LP.balanceOf\"\r\n        );\r\n\r\n        uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\r\n        uint256[] memory fees = new uint256[](pooledTokens.length);\r\n        {\r\n            uint256[] memory balances1 = new uint256[](pooledTokens.length);\r\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\r\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n                if (amounts[i] > v.balances[i]) {\r\n                    revert(\"Cannot withdraw more than available\");\r\n                } else {\r\n                    unchecked {\r\n                        balances1[i] = v.balances[i] - amounts[i];\r\n                    }\r\n                }\r\n            }\r\n            v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\r\n\r\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n                uint256 idealBalance = (v.d1 * v.balances[i]) / v.d0;\r\n                uint256 difference = idealBalance.difference(balances1[i]);\r\n                fees[i] = (feePerToken * difference) / FEE_DENOMINATOR;\r\n                self.balances[i] =\r\n                    balances1[i] -\r\n                    ((fees[i] * self.adminFee) / FEE_DENOMINATOR);\r\n                balances1[i] = balances1[i] - fees[i];\r\n            }\r\n\r\n            v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\r\n        }\r\n        uint256 tokenAmount = ((v.d0 - v.d2) * v.totalSupply) / v.d0;\r\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\r\n        tokenAmount = tokenAmount + 1;\r\n\r\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\r\n\r\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\r\n\r\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n            pooledTokens[i].safeTransfer(receiver, amounts[i]);\r\n        }\r\n\r\n        emit RemoveLiquidityImbalance(\r\n            receiver,\r\n            amounts,\r\n            fees,\r\n            v.d1,\r\n            v.totalSupply - tokenAmount\r\n        );\r\n\r\n        return tokenAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice withdraw all admin fees to a given address\r\n     * @param self Swap struct to withdraw fees from\r\n     * @param to Address to send the fees to\r\n     */\r\n    function withdrawAdminFees(Swap storage self, address to) external returns (uint256[] memory) {\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n        uint256[] memory amounts = new uint256[](pooledTokens.length);\r\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n            IERC20 token = pooledTokens[i];\r\n            uint256 balance = token.balanceOf(address(this)) - self.balances[i];\r\n            amounts[i] = balance;\r\n            if (balance != 0) {\r\n                token.safeTransfer(to, balance);\r\n            }\r\n        }\r\n        return amounts;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the admin fee\r\n     * @dev adminFee cannot be higher than 100% of the swap fee\r\n     * @param self Swap struct to update\r\n     * @param newAdminFee new admin fee to be applied on future transactions\r\n     */\r\n    function setAdminFee(Swap storage self, uint256 newAdminFee) external {\r\n        require(newAdminFee <= MAX_ADMIN_FEE, \"Fee is too high\");\r\n        self.adminFee = newAdminFee;\r\n\r\n        emit NewAdminFee(newAdminFee);\r\n    }\r\n\r\n    /**\r\n     * @notice update the swap fee\r\n     * @dev fee cannot be higher than 1% of each swap\r\n     * @param self Swap struct to update\r\n     * @param newSwapFee new swap fee to be applied on future transactions\r\n     */\r\n    function setSwapFee(Swap storage self, uint256 newSwapFee) external {\r\n        require(newSwapFee <= MAX_SWAP_FEE, \"Fee is too high\");\r\n        self.swapFee = newSwapFee;\r\n\r\n        emit NewSwapFee(newSwapFee);\r\n    }\r\n}\r\n"
    },
    "contracts/utils/UQ112x112.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}"
    },
    "contracts/VolatilePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\nimport { IVolatilePair } from \"./interface/IPair.sol\";\r\nimport \"./lib/PairERC20.sol\";\r\nimport \"./utils/UQ112x112.sol\";\r\nimport \"./utils/ERC20Call.sol\";\r\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\r\nimport \"./interface/IPairCallee.sol\";\r\nimport \"./interface/IPairFactory.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\n\r\ncontract VolatilePair is PairERC20, IVolatilePair, Initializable {\r\n    using SafeMath for uint256;\r\n    using UQ112x112 for uint224;\r\n    using ERC20Call for address;\r\n\r\n    uint256 public constant MINIMUM_LIQUIDITY = 10**3;\r\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\r\n\r\n    address public factory;\r\n    address public token0;\r\n    address public token1;\r\n\r\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\r\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\r\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\r\n\r\n    uint256 public price0CumulativeLast;\r\n    uint256 public price1CumulativeLast;\r\n    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\r\n\r\n    uint256 private unlocked = 1;\r\n\r\n    uint8 public constant PAIR_TYPE = 1;\r\n    uint256 public constant FEE_DENOMINATOR = 10**10;\r\n    uint256 public constant MAX_SWAP_FEE = 10**8;\r\n    uint256 public constant MAX_ADMIN_FEE = 10**10;\r\n\r\n    uint256 public swapFeeRate;\r\n    uint256 public adminFeeRate;\r\n\r\n    uint256 public totalAdminFee0;\r\n    uint256 public totalAdminFee1;\r\n\r\n    modifier lock() {\r\n        require(unlocked == 1, \"Pair: LOCKED\");\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    modifier onlyManager() {\r\n        require(msg.sender == IPairFactory(factory).manager(), \"Pair: not manager\");\r\n        _;\r\n    }\r\n\r\n    function getReserves()\r\n        public\r\n        view\r\n        returns (\r\n            uint112 _reserve0,\r\n            uint112 _reserve1,\r\n            uint32 _blockTimestampLast\r\n        )\r\n    {\r\n        _reserve0 = reserve0;\r\n        _reserve1 = reserve1;\r\n        _blockTimestampLast = blockTimestampLast;\r\n    }\r\n\r\n    function _safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"Pair: TRANSFER_FAILED\");\r\n    }\r\n\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\r\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n    event ClaimFees(address token0, address token1, uint256 amount0, uint256 amount1);\r\n    event SetAdminFeeRate(uint256 _old, uint256 _new);\r\n    event SetSwapFeeRate(uint256 _old, uint256 _new);\r\n\r\n    constructor() {\r\n        factory = msg.sender;\r\n    }\r\n\r\n    function initialize(address[] memory _tokens, bytes memory _data) external initializer {\r\n        require(factory == msg.sender, \"Pair: not factory\");\r\n        (token0, token1) = (_tokens[0], _tokens[1]);\r\n        (uint256 _swapfeeRate, uint256 _adminFeeRate) = abi.decode(_data, (uint256, uint256));\r\n\r\n        require(_swapfeeRate <= MAX_SWAP_FEE, \"Pair: SwapFee is greater than the maximum value\");\r\n        require(_adminFeeRate <= MAX_ADMIN_FEE, \"Pair: AdminFee is greater than the maximum value\");\r\n        (swapFeeRate, adminFeeRate) = (_swapfeeRate, _adminFeeRate);\r\n\r\n        _setNameAndSymbol(\r\n            string(abi.encodePacked(\"DForce Volatile AMM - \", _tokens[0].callSymbol(), \"-\", _tokens[1].callSymbol())),\r\n            string(abi.encodePacked(\"dAMM-Volatile-\", _tokens[0].callSymbol(), \"-\", _tokens[1].callSymbol()))\r\n        );\r\n    }\r\n\r\n    // update reserves and, on the first call per block, price accumulators\r\n    function _update(\r\n        uint256 balance0,\r\n        uint256 balance1,\r\n        uint112 _reserve0,\r\n        uint112 _reserve1\r\n    ) private {\r\n        require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, \"Pair: OVERFLOW\");\r\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\r\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\r\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\r\n            // * never overflows, and + overflow is desired\r\n            price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\r\n            price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\r\n        }\r\n        reserve0 = uint112(balance0);\r\n        reserve1 = uint112(balance1);\r\n        blockTimestampLast = blockTimestamp;\r\n        emit Sync(reserve0, reserve1);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function mint(address to) external lock returns (uint256 liquidity) {\r\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\r\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\r\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\r\n        uint256 amount0 = balance0.sub(_reserve0);\r\n        uint256 amount1 = balance1.sub(_reserve1);\r\n\r\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\r\n        if (_totalSupply == 0) {\r\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\r\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\r\n        } else {\r\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\r\n        }\r\n        require(liquidity > 0, \"Pair: INSUFFICIENT_LIQUIDITY_MINTED\");\r\n        _mint(to, liquidity);\r\n\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n        emit Mint(msg.sender, amount0, amount1);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function burn(address to) external lock returns (uint256 amount0, uint256 amount1) {\r\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\r\n        address _token0 = token0; // gas savings\r\n        address _token1 = token1; // gas savings\r\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\r\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\r\n        uint256 liquidity = balanceOf[address(this)];\r\n\r\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\r\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\r\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\r\n        require(amount0 > 0 && amount1 > 0, \"Pair: INSUFFICIENT_LIQUIDITY_BURNED\");\r\n        _burn(address(this), liquidity);\r\n        _safeTransfer(_token0, to, amount0);\r\n        _safeTransfer(_token1, to, amount1);\r\n        balance0 = IERC20(_token0).balanceOf(address(this));\r\n        balance1 = IERC20(_token1).balanceOf(address(this));\r\n\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n        emit Burn(msg.sender, amount0, amount1, to);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external lock {\r\n        require(amount0Out > 0 || amount1Out > 0, \"Pair: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\r\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, \"Pair: INSUFFICIENT_LIQUIDITY\");\r\n\r\n        uint256 balance0;\r\n        uint256 balance1;\r\n        {\r\n            // scope for _token{0,1}, avoids stack too deep errors\r\n            address _token0 = token0;\r\n            address _token1 = token1;\r\n            require(to != _token0 && to != _token1, \"Pair: INVALID_TO\");\r\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\r\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\r\n            if (data.length > 0) IPairCallee(to).hook(msg.sender, amount0Out, amount1Out, data);\r\n            (balance0, balance1) = getRealBalanceOf();\r\n        }\r\n        uint256 amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\r\n        uint256 amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\r\n        require(amount0In > 0 || amount1In > 0, \"Pair: INSUFFICIENT_INPUT_AMOUNT\");\r\n        {\r\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\r\n            uint256 balance0Adjusted = balance0.mul(FEE_DENOMINATOR).sub(amount0In.mul(swapFeeRate));\r\n            uint256 balance1Adjusted = balance1.mul(FEE_DENOMINATOR).sub(amount1In.mul(swapFeeRate));\r\n            require(balance0Adjusted.mul(balance1Adjusted) >= uint256(_reserve0).mul(_reserve1).mul(FEE_DENOMINATOR**2), \"Pair: K\");\r\n\r\n            //update totalAdminFee and balance\r\n            (uint256 _swapFee0, uint256 _swapFee1) = _updateAdminFee(amount0In, amount1In);\r\n            (balance0 += _swapFee0, balance1 += _swapFee1);\r\n        }\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\r\n    }\r\n\r\n    // force balances to match reserves\r\n    function skim(address to) external lock {\r\n        address _token0 = token0; // gas savings\r\n        address _token1 = token1; // gas savings\r\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\r\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\r\n    }\r\n\r\n    // force reserves to match balances\r\n    function sync() external lock {\r\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\r\n    }\r\n\r\n    function claimFees() external returns (uint256[] memory _adminFees) {\r\n        address _manager = IPairFactory(factory).manager();\r\n        _adminFees = new uint256[](2);\r\n\r\n        (_adminFees[0], _adminFees[1]) = (totalAdminFee0, totalAdminFee1);\r\n        (totalAdminFee0, totalAdminFee1) = (0, 0);\r\n\r\n        _safeTransfer(token0, _manager, _adminFees[0]);\r\n        _safeTransfer(token1, _manager, _adminFees[1]);\r\n        emit ClaimFees(token0, token1, _adminFees[0], _adminFees[1]);\r\n    }\r\n\r\n    function setAdminFeeRate(uint256 _adminFeeRate) external onlyManager {\r\n        require(_adminFeeRate <= MAX_ADMIN_FEE, \"Pair: AdminFee is greater than the maximum value\");\r\n        uint256 _old = adminFeeRate;\r\n        adminFeeRate = _adminFeeRate;\r\n        emit SetAdminFeeRate(_old, _adminFeeRate);\r\n    }\r\n\r\n    function setSwapFeeRate(uint256 _swapFeeRate) external onlyManager {\r\n        require(_swapFeeRate <= MAX_SWAP_FEE, \"Pair: SwapFee is greater than the maximum value\");\r\n        uint256 _old = swapFeeRate;\r\n        swapFeeRate = _swapFeeRate;\r\n        emit SetSwapFeeRate(_old, _swapFeeRate);\r\n    }\r\n\r\n    function getAmountOut(\r\n        address _from,\r\n        address,\r\n        uint256 _amount\r\n    ) external view override returns (uint256) {\r\n        (uint256 reserveA, uint256 reserveB) = _from == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n        return _getAmountOut(_amount, reserveA, reserveB);\r\n    }\r\n\r\n    function tokens() external view override returns (address[] memory _tokens) {\r\n        _tokens = new address[](2);\r\n        _tokens[0] = token0;\r\n        _tokens[1] = token1;\r\n    }\r\n\r\n    function sortTokens(address _tokenA, address _tokenB) public pure returns (address _token0, address _token1) {\r\n        require(_tokenA != _tokenB, \"Pair: IDENTICAL_ADDRESSES\");\r\n        (_token0, _token1) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\r\n        require(_token0 != address(0), \"Pair: ZERO_ADDRESS\");\r\n    }\r\n\r\n    function getRealBalanceOf() public view returns (uint256, uint256) {\r\n        return (IERC20(token0).balanceOf(address(this)).sub(totalAdminFee0), IERC20(token1).balanceOf(address(this)).sub(totalAdminFee1));\r\n    }\r\n\r\n    function _getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal view returns (uint256 amountOut) {\r\n        require(amountIn > 0, \"Pair: INSUFFICIENT_INPUT_AMOUNT\");\r\n        require(reserveIn > 0 && reserveOut > 0, \"Pair: INSUFFICIENT_LIQUIDITY\");\r\n        uint256 amountInWithFee = amountIn.mul(FEE_DENOMINATOR - swapFeeRate);\r\n        uint256 numerator = amountInWithFee.mul(reserveOut);\r\n        uint256 denominator = reserveIn.mul(FEE_DENOMINATOR).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    function _updateAdminFee(uint256 _amountIn0, uint256 _amountIn1) internal returns (uint256 _swapFee0, uint256 _swapFee1) {\r\n        uint256 _totalFee0 = _amountIn0.mul(swapFeeRate).div(FEE_DENOMINATOR);\r\n        uint256 _totalFee1 = _amountIn1.mul(swapFeeRate).div(FEE_DENOMINATOR);\r\n\r\n        {\r\n            uint256 _adminFee0 = _totalFee0.mul(adminFeeRate).div(FEE_DENOMINATOR);\r\n            uint256 _adminFee1 = _totalFee1.mul(adminFeeRate).div(FEE_DENOMINATOR);\r\n\r\n            _swapFee0 = _totalFee0 - _adminFee0;\r\n            _swapFee1 = _adminFee1 - _adminFee1;\r\n\r\n            totalAdminFee0 += _adminFee0;\r\n            totalAdminFee1 += _adminFee1;\r\n        }\r\n    }\r\n\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}