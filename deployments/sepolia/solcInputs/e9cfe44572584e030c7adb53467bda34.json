{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address master) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `master` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address master, bytes32 salt) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt, address deployer) internal pure returns (address predicted) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt) internal view returns (address predicted) {\n        return predictDeterministicAddress(master, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./UpgradeableProxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _setAdmin(admin_);\n    }\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _admin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\");\n        emit AdminChanged(_admin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external virtual ifAdmin {\n        _upgradeTo(newImplementation);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {\n        _upgradeTo(newImplementation);\n        Address.functionDelegateCall(newImplementation, data);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address adm) {\n        bytes32 slot = _ADMIN_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        bytes32 slot = _ADMIN_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newAdmin)\n        }\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/UpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./Proxy.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n *\n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\n * {TransparentUpgradeableProxy}.\n */\ncontract UpgradeableProxy is Proxy {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) public payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _setImplementation(_logic);\n        if(_data.length > 0) {\n            Address.functionDelegateCall(_logic, _data);\n        }\n    }\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal virtual {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\n\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/interface/IPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IPair {\r\n    function initialize(address[] memory _tokens, bytes memory _data) external;\r\n\r\n    function PAIR_TYPE() external view returns (uint8);\r\n\r\n    function AUTH() external view returns (bool);\r\n\r\n    function tokens() external view returns (address[] memory);\r\n\r\n    function getAmountOut(address _from, address _to, uint256 _amount) external view returns (uint256);\r\n}\r\n\r\ninterface IVolatilePair is IPair {\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\r\n\r\n    function mint(address _to) external returns (uint256 _liquidity);\r\n\r\n    function burn(address _to) external returns (uint256 _amount0, uint256 _amount1);\r\n\r\n    function swap(uint256 _amount0Out, uint256 _amount1Out, address _to, bytes calldata _data) external;\r\n\r\n    function getRealBalanceOf() external view returns (uint256, uint256);\r\n\r\n    function skim(address _to) external;\r\n\r\n    function sync() external;\r\n\r\n    function claimFees() external returns (uint256[] memory _adminFees);\r\n}\r\n\r\ninterface IStablePair is IPair {\r\n    function lpToken() external view returns (address);\r\n\r\n    function calculateTokenAmount(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts,\r\n        bool _deposit\r\n    ) external view returns (uint256);\r\n\r\n    function calculateRemoveLiquidityOneToken(address _token, uint256 _liquidity) external view returns (uint256);\r\n\r\n    function calculateRemoveLiquidity(\r\n        address[] calldata _tokens,\r\n        uint256 _amount\r\n    ) external view returns (uint256[] memory);\r\n\r\n    function addLiquidity(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts,\r\n        uint256 _minToMint,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external returns (uint256);\r\n\r\n    function removeLiquidity(\r\n        uint256 _amount,\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _minAmounts,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external returns (uint256[] memory);\r\n\r\n    function removeLiquidityOneToken(\r\n        uint256 _tokenAmount,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external returns (uint256);\r\n\r\n    function removeLiquidityImbalance(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external returns (uint256);\r\n\r\n    function swap(\r\n        address _tokenFrom,\r\n        address _tokenTo,\r\n        uint256 _dx,\r\n        uint256 _minDy,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external returns (uint256);\r\n}\r\n"
    },
    "contracts/interface/IPairCallee.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IPairCallee {\r\n    function hook(address sender, uint256 amountOut0, uint256 amountOut1, bytes calldata data) external;\r\n}\r\n"
    },
    "contracts/interface/IPairERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IPairERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n"
    },
    "contracts/interface/IPairFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IPairFactory {\r\n    function allPairsLength() external view returns (uint256);\r\n\r\n    function isPair(address _pair) external view returns (bool);\r\n\r\n    function manager() external view returns (address);\r\n\r\n    function getPairAddress(address[] memory _tokens, uint8 _type) external view returns (address);\r\n\r\n    function pairTypeValues() external view returns (address[] memory);\r\n\r\n    function atPairType(uint256 _index) external view returns (address);\r\n\r\n    function createPair(address[] memory _tokens, uint8 _pairType, bytes memory _data) external returns (address _pair);\r\n}\r\n"
    },
    "contracts/interface/IPairRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IPairRouter {\r\n    /**\r\n     * @dev Struct representing a route between two tokens through a pair contract\r\n     */\r\n    struct Route {\r\n        address from; // Address of the token to swap from\r\n        address to; // Address of the token to swap to\r\n        address pair; // Address of the pair contract to use for the swap\r\n    }\r\n\r\n    function PAIR_TYPE() external view returns (uint8);\r\n\r\n    function quoteAddLiquidity(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amountDesireds\r\n    ) external view returns (uint256[] memory _amountIn, uint256 _liquidity);\r\n\r\n    function quoteRemoveLiquidity(\r\n        address[] calldata _tokens,\r\n        uint256 _liquidity\r\n    ) external view returns (uint256[] memory _amounts);\r\n\r\n    function addLiquidity(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory _amountsMin,\r\n        uint256 _minLiquidity,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256[] memory _amounts, uint256 _liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory _amountMins,\r\n        uint256 _minLiquidity,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable returns (uint256[] memory _amounts, uint256 _liquidity);\r\n\r\n    function removeLiquidity(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256[] memory _amounts);\r\n\r\n    function removeLiquidityETH(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256[] memory _returns);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256[] memory _amounts);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256[] memory);\r\n\r\n    function swap(\r\n        Route memory _route,\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable returns (uint256 _amountOut);\r\n}\r\n\r\ninterface IVolatileRouter is IPairRouter {\r\n    function getReserves(\r\n        address _pair,\r\n        address[] calldata _tokens\r\n    ) external view returns (uint256 _reserveA, uint256 _reserveB);\r\n}\r\n\r\ninterface IStablPairRouter is IPairRouter {\r\n    function quoteRemoveLiquidityOneToken(\r\n        address[] calldata _tokens,\r\n        address _token,\r\n        uint256 _liquidity\r\n    ) external view returns (uint256 _amount);\r\n\r\n    function quoteRemoveLiquidityImbalance(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts\r\n    ) external view returns (uint256 _liquidity);\r\n\r\n    function removeLiquidityOneToken(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 _tokenAmount);\r\n\r\n    function removeLiquidityOneTokenETH(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 _tokenAmount);\r\n\r\n    function removeLiquidityImbalance(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 _amount);\r\n\r\n    function removeLiquidityImbalanceETH(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 _amount);\r\n\r\n    function removeLiquidityOneTokenWithPermit(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256 _tokenAmount);\r\n\r\n    function removeLiquidityOneTokenETHWithPermit(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256 _tokenAmount);\r\n\r\n    function removeLiquidityImbalanceWithPermit(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256 _actualBurnAmount);\r\n\r\n    function removeLiquidityImbalanceETHWithPermit(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256 _actualBurnAmount);\r\n}\r\n"
    },
    "contracts/interface/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n/// @title Interface for WETH9\r\ninterface IWETH {\r\n    /// @notice Deposit ether to get wrapped ether\r\n    function deposit() external payable;\r\n\r\n    /// @notice Withdraw wrapped ether to get ether\r\n    function withdraw(uint256) external;\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n}\r\n"
    },
    "contracts/lib/MyTransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\nimport \"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\";\r\n\r\ncontract MyTransparentUpgradeableProxy is TransparentUpgradeableProxy {\r\n    constructor(\r\n        address _logic,\r\n        address admin_,\r\n        bytes memory _data\r\n    ) public TransparentUpgradeableProxy(_logic, admin_, _data) {}\r\n\r\n    receive() external payable override {}\r\n}\r\n"
    },
    "contracts/lib/PairERC20.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"../interface/IPairERC20.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\n\r\n/**\r\n * @title PairERC20\r\n * @dev Abstract contract that implements the IPairERC20 interface and provides basic ERC20 functionality.\r\n */\r\nabstract contract PairERC20 is IPairERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    string public override name;\r\n    string public override symbol;\r\n    uint8 public constant override decimals = 18;\r\n\r\n    uint256 public override totalSupply;\r\n\r\n    mapping(address => uint256) public override balanceOf;\r\n    mapping(address => mapping(address => uint256)) public override allowance;\r\n\r\n    bytes32 public override DOMAIN_SEPARATOR;\r\n\r\n    // keccak256(\"Permit(address owner,address spender,uint256 chainId, uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant override PERMIT_TYPEHASH =\r\n        0x576144ed657c8304561e56ca632e17751956250114636e8c01f64a7f2c6d98cf;\r\n\r\n    mapping(address => uint256) public override nonces;\r\n\r\n    /**\r\n     * @dev Initializes the contract by setting the name and symbol of the token, as well as the domain separator for the permit function.\r\n     * @param _name The name of the token.\r\n     * @param _symbol The symbol of the token.\r\n     */\r\n    function _initialize(string memory _name, string memory _symbol) internal {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes(\"1\")),\r\n                _getChainId(),\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    function _getChainId() internal pure returns (uint256) {\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        return chainId;\r\n    }\r\n\r\n    /**\r\n     * @dev Mints new tokens and adds them to the total supply.\r\n     * @param to The address to which the new tokens will be minted.\r\n     * @param value The amount of tokens to be minted.\r\n     */\r\n    function _mint(address to, uint256 value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Burns tokens and removes them from the total supply.\r\n     * @param from The address from which the tokens will be burned.\r\n     * @param value The amount of tokens to be burned.\r\n     */\r\n    function _burn(address from, uint256 value) internal {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Approves a spender to transfer tokens on behalf of the owner.\r\n     * @param owner The address of the owner of the tokens.\r\n     * @param spender The address of the spender to be approved.\r\n     * @param value The amount of tokens to be approved for transfer.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens from one address to another.\r\n     * @param from The address from which the tokens will be transferred.\r\n     * @param to The address to which the tokens will be transferred.\r\n     * @param value The amount of tokens to be transferred.\r\n     */\r\n    function _transfer(address from, address to, uint256 value) internal virtual {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Approves a spender to transfer tokens on behalf of the owner.\r\n     * @param spender The address of the spender to be approved.\r\n     * @param value The amount of tokens to be approved for transfer.\r\n     * @return A boolean indicating whether the approval was successful or not.\r\n     */\r\n    function approve(address spender, uint256 value) external override returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens from the caller's address to another address.\r\n     * @param to The address to which the tokens will be transferred.\r\n     * @param value The amount of tokens to be transferred.\r\n     * @return A boolean indicating whether the transfer was successful or not.\r\n     */\r\n    function transfer(address to, uint256 value) external override returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens from one address to another, on behalf of the owner.\r\n     * @param from The address from which the tokens will be transferred.\r\n     * @param to The address to which the tokens will be transferred.\r\n     * @param value The amount of tokens to be transferred.\r\n     * @return A boolean indicating whether the transfer was successful or not.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external override returns (bool) {\r\n        if (allowance[from][msg.sender] != uint256(-1)) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approves a spender to transfer tokens on behalf of the owner, using a permit signature.\r\n     * @param owner The address of the owner of the tokens.\r\n     * @param spender The address of the spender to be approved.\r\n     * @param value The amount of tokens to be approved for transfer.\r\n     * @param deadline The deadline by which the permit must be used.\r\n     * @param v The recovery byte of the permit signature.\r\n     * @param r The R component of the permit signature.\r\n     * @param s The S component of the permit signature.\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external override {\r\n        require(deadline >= block.timestamp, \"PairERC20: EXPIRED\");\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, _getChainId(), value, nonces[owner]++, deadline))\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"PairERC20: INVALID_SIGNATURE\");\r\n        _approve(owner, spender, value);\r\n    }\r\n}\r\n"
    },
    "contracts/lib/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/**\r\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\r\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\r\n */\r\ncontract ProxyAdmin is Ownable {\r\n    /**\r\n     * @dev Returns the current implementation of `proxy`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - This contract must be the admin of `proxy`.\r\n     */\r\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\r\n        // We need to manually run the static call since the getter cannot be flagged as view\r\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\r\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\r\n        require(success);\r\n        return abi.decode(returndata, (address));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current admin of `proxy`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - This contract must be the admin of `proxy`.\r\n     */\r\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\r\n        // We need to manually run the static call since the getter cannot be flagged as view\r\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\r\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\r\n        require(success);\r\n        return abi.decode(returndata, (address));\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the admin of `proxy` to `newAdmin`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - This contract must be the current admin of `proxy`.\r\n     */\r\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\r\n        proxy.changeAdmin(newAdmin);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - This contract must be the admin of `proxy`.\r\n     */\r\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\r\n        proxy.upgradeTo(implementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\r\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - This contract must be the admin of `proxy`.\r\n     */\r\n    function upgradeAndCall(\r\n        TransparentUpgradeableProxy proxy,\r\n        address implementation,\r\n        bytes memory data\r\n    ) public payable virtual onlyOwner {\r\n        proxy.upgradeToAndCall{ value: msg.value }(implementation, data);\r\n    }\r\n}\r\n"
    },
    "contracts/PairFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\n\r\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\n\r\nimport \"./interface/IPairFactory.sol\";\r\n\r\nimport \"./utils/Arrays.sol\";\r\nimport { IPair } from \"./interface/IPair.sol\";\r\n\r\n/**\r\n * @title PairFactory\r\n * @dev This contract is responsible for creating and managing pairs.\r\n */\r\ncontract PairFactory is IPairFactory, Initializable {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    using Arrays for address[];\r\n\r\n    // Maximum swap fee and admin fee rates\r\n    uint256 public constant MAX_SWAP_FEE = 10 ** 8;\r\n    uint256 public constant MAX_ADMIN_FEE = 10 ** 10;\r\n\r\n    // Address of the current manager\r\n    address public override manager;\r\n\r\n    // Address of the pending manager\r\n    address public pendingManager;\r\n\r\n    // Default swap fee rate\r\n    uint256 public defSwapFeeRate;\r\n\r\n    // Default admin fee rate\r\n    uint256 public defAdminFeeRate;\r\n\r\n    // Mapping of pair addresses to boolean values indicating whether the pair exists\r\n    mapping(address => bool) public override isPair;\r\n\r\n    // Array of all pair addresses\r\n    address[] public allPairs;\r\n\r\n    // Set of pair implementation addresses\r\n    EnumerableSet.AddressSet internal pairImpls_;\r\n\r\n    //1: volatile pair, 2: stable pair, 3: yeild pair\r\n    // Struct to store pair implementation and authorization status\r\n    struct PairParams {\r\n        address impl; // Address of the pair implementation\r\n        bool auth; // Authorization status of the pair\r\n    }\r\n    // Mapping of pair type to pair implementation and authorization status\r\n    mapping(uint8 => PairParams) public pairParams;\r\n\r\n    /**\r\n     * @dev Event emitted when a new pair is created.\r\n     * @param tokens The tokens in the new pair.\r\n     * @param pairType The type of the new pair.\r\n     * @param pair The address of the new pair.\r\n     * @param pairsAmount The total number of pairs.\r\n     */\r\n    event PairCreated(address[] tokens, uint8 pairType, address pair, uint256 pairsAmount);\r\n\r\n    /**\r\n     * @dev Event emitted when a new manager is pending.\r\n     * @param manager The current manager.\r\n     * @param pendingManager The new pending manager.\r\n     */\r\n    event SetPendingManager(address manager, address pendingManager);\r\n\r\n    /**\r\n     * @dev Event emitted when the manager is changed.\r\n     * @param oldManager The old manager.\r\n     * @param newManager The new manager.\r\n     */\r\n    event ChangeManager(address oldManager, address newManager);\r\n\r\n    /**\r\n     * @dev Event emitted when the default swap fee rate is changed.\r\n     * @param oldDefSwapFeeRate The old default swap fee rate.\r\n     * @param newDefSwapFeeRate The new default swap fee rate.\r\n     */\r\n    event SetDefSwapFeeRate(uint256 oldDefSwapFeeRate, uint256 newDefSwapFeeRate);\r\n\r\n    /**\r\n     * @dev Event emitted when the default admin fee rate is changed.\r\n     * @param oldDefAdminFeeRate The old default admin fee rate.\r\n     * @param newDefAdminFeeRate The new default admin fee rate.\r\n     */\r\n    event SetDefAdminFeeRate(uint256 oldDefAdminFeeRate, uint256 newDefAdminFeeRate);\r\n\r\n    /**\r\n     * @dev Event emitted when a new pair type is added.\r\n     * @param impl The address of the pair implementation.\r\n     * @param pairType The type of the new pair.\r\n     * @param auth The authorization status of the new pair.\r\n     * @param oldImpl The address of the old pair implementation.\r\n     */\r\n    event SetPairType(address impl, uint8 pairType, bool auth, address oldImpl);\r\n\r\n    /**\r\n     * @dev Event emitted when a pair type is removed.\r\n     * @param impl The address of the pair implementation.\r\n     * @param pairType The type of the pair to be removed.\r\n     * @param auth The authorization status of the pair to be removed.\r\n     */\r\n    event RemovePairType(address impl, uint8 pairType, bool auth);\r\n\r\n    /**\r\n     * @dev Constructor function that initializes the default swap fee rate and default admin fee rate.\r\n     * @param _defSwapFeeRate The default swap fee rate.\r\n     * @param _defAdminFeeRate The default admin fee rate.\r\n     */\r\n    constructor(uint256 _defSwapFeeRate, uint256 _defAdminFeeRate) public {\r\n        initialize(_defSwapFeeRate, _defAdminFeeRate);\r\n    }\r\n\r\n    /**\r\n     * @dev Function that initializes the default swap fee rate, default admin fee rate, and manager.\r\n     * @param _defSwapFeeRate The default swap fee rate.\r\n     * @param _defAdminFeeRate The default admin fee rate.\r\n     */\r\n    function initialize(uint256 _defSwapFeeRate, uint256 _defAdminFeeRate) public initializer {\r\n        manager = msg.sender;\r\n        setDefSwapFeeRate(_defSwapFeeRate);\r\n        setDefAdminFeeRate(_defAdminFeeRate);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier that checks if the caller is the manager.\r\n     */\r\n    modifier onlyManager() {\r\n        require(msg.sender == manager, \"PairFactory: not manager\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Function that returns the length of the allPairs array.\r\n     * @return The length of the allPairs array.\r\n     */\r\n    function allPairsLength() external view override returns (uint256) {\r\n        return allPairs.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Function that checks if a pair with the given address exists.\r\n     * @param value The address of the pair to check.\r\n     * @return A boolean indicating whether the pair exists or not.\r\n     */\r\n    function containsPair(address value) external view returns (bool) {\r\n        return pairImpls_.contains(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Function that returns an array of all pair implementation addresses.\r\n     * @return _pairImpls An array of all pair implementation addresses.\r\n     */\r\n    function pairTypeValues() external view override returns (address[] memory _pairImpls) {\r\n        uint256 _len = pairImpls_.length();\r\n        _pairImpls = new address[](_len);\r\n        for (uint256 i = 0; i < _len; i++) {\r\n            _pairImpls[i] = pairImpls_.at(i);\r\n        }\r\n        return _pairImpls;\r\n    }\r\n\r\n    /**\r\n     * @dev Function that returns the number of pair implementations.\r\n     * @return The number of pair implementations.\r\n     */\r\n    function pairTypeAmount() external view returns (uint256) {\r\n        return pairImpls_.length();\r\n    }\r\n\r\n    /**\r\n     * @dev Function that returns the pair implementation address at the given index.\r\n     * @param _index The index of the pair implementation address to return.\r\n     * @return The pair implementation address at the given index.\r\n     */\r\n    function atPairType(uint256 _index) external view override returns (address) {\r\n        return pairImpls_.at(_index);\r\n    }\r\n\r\n    /**\r\n     * @dev Function that returns the pair address for the given tokens and pair type.\r\n     * @param _tokens The tokens to create the pair with.\r\n     * @param _pairType The type of the pair to create.\r\n     * @return The pair address for the given tokens and pair type.\r\n     */\r\n    function getPairAddress(address[] memory _tokens, uint8 _pairType) public view override returns (address) {\r\n        bytes32 salt = keccak256(abi.encodePacked(_tokens.sortArray(), _pairType));\r\n        return Clones.predictDeterministicAddress(pairParams[_pairType].impl, salt);\r\n    }\r\n\r\n    /**\r\n     * @dev Function that creates a new pair with the given tokens and pair type.\r\n     * @param _tokens The tokens to create the pair with.\r\n     * @param _pairType The type of the pair to create.\r\n     * @param _data Additional data to pass to the pair's `initialize` function.\r\n     * @return _pair The address of the newly created pair.\r\n     */\r\n    function createPair(\r\n        address[] memory _tokens,\r\n        uint8 _pairType,\r\n        bytes memory _data\r\n    ) external override returns (address _pair) {\r\n        _tokens = _tokens.sortArray();\r\n        require(pairParams[_pairType].impl != address(0), \"PairFactory: No impl of this type\");\r\n        require(!isPair[getPairAddress(_tokens, _pairType)], \"PairFactory: Pair already exists\");\r\n\r\n        bytes32 salt = keccak256(abi.encodePacked(_tokens, _pairType));\r\n\r\n        PairParams memory _params = pairParams[_pairType];\r\n        if (_pairType == 1) {\r\n            _data = abi.encode(defSwapFeeRate, defAdminFeeRate);\r\n        }\r\n        if (_params.auth) {\r\n            require(manager == msg.sender, \"PairFactory: this pair type can only be created by manager\");\r\n        }\r\n        _pair = Clones.cloneDeterministic(_params.impl, salt);\r\n\r\n        IPair(_pair).initialize(_tokens, _data);\r\n\r\n        allPairs.push(_pair);\r\n        isPair[_pair] = true;\r\n\r\n        emit PairCreated(_tokens, _pairType, _pair, allPairs.length);\r\n    }\r\n\r\n    /**\r\n     * @dev Function that sets the pending manager address.\r\n     * @param _pendingManager The address of the pending manager.\r\n     */\r\n    function setPendingManager(address _pendingManager) external onlyManager {\r\n        require(manager != _pendingManager && pendingManager != _pendingManager, \"PairFactory: manager has been set\");\r\n\r\n        pendingManager = _pendingManager;\r\n\r\n        emit SetPendingManager(manager, _pendingManager);\r\n    }\r\n\r\n    /**\r\n     * @dev Function that accepts the pending manager address.\r\n     */\r\n    function acceptManager() external {\r\n        require(msg.sender == pendingManager, \"PairFactory: not pending fee manager\");\r\n        address _oldManager = manager;\r\n\r\n        manager = pendingManager;\r\n        pendingManager = address(0);\r\n\r\n        emit ChangeManager(_oldManager, manager);\r\n    }\r\n\r\n    /**\r\n     * @dev Function that sets the default swap fee rate.\r\n     * @param _defSwapFeeRate The new default swap fee rate.\r\n     */\r\n    function setDefSwapFeeRate(uint256 _defSwapFeeRate) public onlyManager {\r\n        require(_defSwapFeeRate <= MAX_SWAP_FEE, \"PairFactory: Over MAX_SWAP_FEE is not allowed\");\r\n\r\n        uint256 _oldDefSwapFeeRate = defSwapFeeRate;\r\n        require(_defSwapFeeRate != _oldDefSwapFeeRate, \"PairFactory: _defSwapFeeRate invalid\");\r\n\r\n        defSwapFeeRate = _defSwapFeeRate;\r\n\r\n        emit SetDefSwapFeeRate(_oldDefSwapFeeRate, _defSwapFeeRate);\r\n    }\r\n\r\n    /**\r\n     * @dev Function that sets the default admin fee rate.\r\n     * @param _defAdminFeeRate The new default admin fee rate.\r\n     */\r\n    function setDefAdminFeeRate(uint256 _defAdminFeeRate) public onlyManager {\r\n        require(_defAdminFeeRate <= MAX_ADMIN_FEE, \"PairFactory: Over MAX_ADMIN_FEE is not allowed\");\r\n\r\n        uint256 _oldDefAdminFeeRate = defAdminFeeRate;\r\n        require(_defAdminFeeRate != _oldDefAdminFeeRate, \"PairFactory: _defAdminFeeRate invalid\");\r\n\r\n        defAdminFeeRate = _defAdminFeeRate;\r\n\r\n        emit SetDefAdminFeeRate(_oldDefAdminFeeRate, _defAdminFeeRate);\r\n    }\r\n\r\n    /**\r\n     * @dev Function that adds a new pair type.\r\n     * @param _impl The address of the pair implementation.\r\n     */\r\n    function addPairType(address _impl) external onlyManager {\r\n        uint8 _type = IPair(_impl).PAIR_TYPE();\r\n        bool _auth = IPair(_impl).AUTH();\r\n\r\n        require(pairImpls_.add(_impl), \"PairFactory: This pair already exists\");\r\n\r\n        require(pairParams[_type].impl == address(0), \"PairFactory: This pair type already exists\");\r\n\r\n        pairParams[_type] = PairParams({ impl: _impl, auth: _auth });\r\n\r\n        emit SetPairType(_impl, _type, _auth, address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Function that removes a pair type.\r\n     * @param _impl The address of the pair implementation.\r\n     */\r\n    function removePairType(address _impl) external onlyManager {\r\n        require(pairImpls_.contains(_impl), \"PairFactory: This pair does not exist\");\r\n\r\n        uint8 _type = IPair(_impl).PAIR_TYPE();\r\n\r\n        pairImpls_.remove(_impl);\r\n        PairParams memory _old = pairParams[_type];\r\n        delete pairParams[_type];\r\n\r\n        emit RemovePairType(_impl, _type, _old.auth);\r\n    }\r\n}\r\n"
    },
    "contracts/Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\nimport \"./utils/TransferHelper.sol\";\r\n\r\nimport \"./interface/IWETH.sol\";\r\nimport \"./interface/IPair.sol\";\r\nimport \"./interface/IPairRouter.sol\";\r\nimport \"./interface/IPairFactory.sol\";\r\n\r\n/**\r\n * @title Router contract\r\n * @dev This contract handles the routing of tokens in the dForce AMM ecosystem\r\n */\r\ncontract Router is Initializable {\r\n    using Address for address;\r\n    using TransferHelper for address;\r\n\r\n    /**\r\n     * @dev Struct to represent a route between two tokens\r\n     */\r\n    struct Route {\r\n        address from; // Address of the token to convert from\r\n        address to; // Address of the token to convert to\r\n        address pair; // Address of the pair contract that connects the two tokens\r\n    }\r\n\r\n    /**\r\n     * @dev Address of the factory contract\r\n     */\r\n    address public factory;\r\n\r\n    /**\r\n     * @dev Address of the WETH contract\r\n     */\r\n    IWETH internal weth_;\r\n\r\n    /**\r\n     * @dev Mapping of pair types to their respective router contracts\r\n     */\r\n    mapping(uint8 => address) internal pairTypes_;\r\n\r\n    /**\r\n     * @dev Event emitted when a pair type is set\r\n     */\r\n    event SetPairTypes(uint8 pairType, address router);\r\n\r\n    /**\r\n     * @dev Constructor function for the Router contract\r\n     * @param _factory Address of the factory contract\r\n     * @param _weth Address of the WETH contract\r\n     */\r\n    constructor(address _factory, address _weth) public {\r\n        initialize(_factory, _weth);\r\n    }\r\n\r\n    /**\r\n     * @dev Initializes the Router contract\r\n     * @param _factory Address of the factory contract\r\n     * @param _weth Address of the WETH contract\r\n     */\r\n    function initialize(address _factory, address _weth) public initializer {\r\n        factory = _factory;\r\n        weth_ = IWETH(_weth);\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function to receive ETH from WETH contract\r\n     */\r\n    receive() external payable {\r\n        assert(msg.sender == address(weth_)); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to restrict access to only the manager\r\n     */\r\n    modifier onlyManager() {\r\n        require(msg.sender == IPairFactory(factory).manager(), \"Router: not manager\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to check if the given pair type is valid\r\n     * @param _pairType The pair type to check\r\n     */\r\n    modifier checkPairType(uint8 _pairType) {\r\n        require(pairTypes_[_pairType] != address(0), \"Router: invalid pair type\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the WETH contract\r\n     */\r\n    function weth() external view returns (address) {\r\n        return address(weth_);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the router contract for a given pair type\r\n     * @param _pairType The pair type\r\n     */\r\n    function pairTypes(uint8 _pairType) external view returns (address) {\r\n        return pairTypes_[_pairType];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens that will be received for a given input amount and route\r\n     * @param _amountIn The input amount\r\n     * @param _routes The route to take\r\n     * @return _amounts The amounts of tokens that will be received\r\n     */\r\n    function _getAmountsOut(\r\n        uint256 _amountIn,\r\n        Route[] memory _routes\r\n    ) internal view returns (uint256[] memory _amounts) {\r\n        _amounts = new uint256[](_routes.length + 1);\r\n        _amounts[0] = _amountIn;\r\n\r\n        for (uint256 i = 0; i < _routes.length; i++)\r\n            _amounts[i + 1] = IPair(_routes[i].pair).getAmountOut(_routes[i].from, _routes[i].to, _amounts[i]);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens that will be received for a given input amount and route\r\n     * @param _amountIn The input amount\r\n     * @param _routes The route to take\r\n     */\r\n    function getAmountsOutPath(\r\n        uint256 _amountIn,\r\n        Route[] memory _routes\r\n    ) external view returns (uint256[] memory _amounts) {\r\n        _amounts = _getAmountsOut(_amountIn, _routes);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens that will be received for a given input amount and route\r\n     * @param _amountIn The input amount\r\n     * @param _routes The route to take\r\n     */\r\n    function getAmountsOut(uint256 _amountIn, Route[] memory _routes) external view returns (uint256) {\r\n        require(_routes.length >= 1, \"Router: INVALID_PATH\");\r\n        uint256[] memory _amounts = _getAmountsOut(_amountIn, _routes);\r\n        return _amounts[_amounts.length - 1];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the pair for the given tokens and pair type\r\n     * @param _tokens The tokens to get the pair address for\r\n     * @param _type The pair type\r\n     * @return _pair The address of the pair\r\n     * @return _has Whether or not the pair exists\r\n     */\r\n    function pairFor(address[] memory _tokens, uint8 _type) external view returns (address _pair, bool _has) {\r\n        _pair = IPairFactory(factory).getPairAddress(_tokens, _type);\r\n        _has = IPairFactory(factory).isPair(_pair);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the reserves of the volatile pair for the given tokens\r\n     * @param _tokens The tokens to get the reserves for\r\n     * @return _reserveA The reserve of token A\r\n     * @return _reserveB The reserve of token B\r\n     */\r\n    function getReserves(address[] memory _tokens) external view returns (uint256 _reserveA, uint256 _reserveB) {\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, 1);\r\n        if (IPairFactory(factory).isPair(_pair))\r\n            (_reserveA, _reserveB) = IVolatileRouter(pairTypes_[1]).getReserves(_pair, _tokens);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens required to add liquidity to a given pair\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to add liquidity for\r\n     * @param _amountDesireds The desired amounts of each token to add liquidity for\r\n     */\r\n    function quoteAddLiquidity(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds\r\n    ) external view returns (uint256[] memory _amountIn, uint256 liquidity) {\r\n        address _router = pairTypes_[_pairType];\r\n        bytes memory _returns = _router.functionStaticCall(\r\n            abi.encodeWithSelector(IPairRouter.quoteAddLiquidity.selector, _tokens, _amountDesireds)\r\n        );\r\n        (_amountIn, liquidity) = abi.decode(_returns, (uint256[], uint256));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens that will be received when removing liquidity from a given pair\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     */\r\n    function quoteRemoveLiquidity(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256 _liquidity\r\n    ) external view returns (uint256[] memory _amounts) {\r\n        address _router = pairTypes_[_pairType];\r\n        bytes memory _returns = _router.functionStaticCall(\r\n            abi.encodeWithSelector(IPairRouter.quoteRemoveLiquidity.selector, _tokens, _liquidity)\r\n        );\r\n        _amounts = abi.decode(_returns, (uint256[]));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of a specific token that will be received when removing liquidity from a given pair\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _token The token to receive\r\n     * @param _liquidity The amount of liquidity to remove\r\n     */\r\n    function quoteRemoveLiquidityOneToken(\r\n        uint8 _pairType,\r\n        address[] calldata _tokens,\r\n        address _token,\r\n        uint256 _liquidity\r\n    ) external view returns (uint256 _amount) {\r\n        address _router = pairTypes_[_pairType];\r\n        bytes memory _returns = _router.functionStaticCall(\r\n            abi.encodeWithSelector(IStablPairRouter.quoteRemoveLiquidityOneToken.selector, _tokens, _token, _liquidity)\r\n        );\r\n        _amount = abi.decode(_returns, (uint256));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens that will be removed when removing liquidity from a given pair\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _amounts The desired amounts of each token to remove liquidity for\r\n     */\r\n    function quoteRemoveLiquidityImbalance(\r\n        uint8 _pairType,\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts\r\n    ) external view returns (uint256 _amount) {\r\n        address _router = pairTypes_[_pairType];\r\n        bytes memory _returns = _router.functionStaticCall(\r\n            abi.encodeWithSelector(IStablPairRouter.quoteRemoveLiquidityImbalance.selector, _tokens, _amounts)\r\n        );\r\n        _amount = abi.decode(_returns, (uint256));\r\n    }\r\n\r\n    /**\r\n     * @dev Adds liquidity to a given pair\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to add liquidity for\r\n     * @param _amountDesireds The desired amounts of each token to add liquidity for\r\n     * @param _amountsMin The minimum amounts of each token to add liquidity for\r\n     * @param _minLiquidity The minimum liquidity to add\r\n     * @param _to The address to send the liquidity to\r\n     * @param _deadline The deadline for the transaction\r\n     * @return _amounts The amounts of tokens added\r\n     * @return _liquidity The amount of liquidity added\r\n     */\r\n    function addLiquidity(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory _amountsMin,\r\n        uint256 _minLiquidity,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external checkPairType(_pairType) returns (uint256[] memory _amounts, uint256 _liquidity) {\r\n        (_amounts, _liquidity) = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IPairRouter.addLiquidity.selector,\r\n                    _tokens,\r\n                    _amountDesireds,\r\n                    _amountsMin,\r\n                    _minLiquidity,\r\n                    _to,\r\n                    _deadline\r\n                )\r\n            ),\r\n            (uint256[], uint256)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Adds liquidity to a given pair with ETH\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to add liquidity for\r\n     * @param _amountDesireds The desired amounts of each token to add liquidity for\r\n     * @param _amountsMin The minimum amounts of each token to add liquidity for\r\n     * @param _minLiquidity The minimum liquidity to add\r\n     * @param _to The address to send the liquidity to\r\n     * @param _deadline The deadline for the transaction\r\n     * @return _amounts The amounts of tokens added\r\n     * @return _liquidity The amount of liquidity added\r\n     */\r\n    function addLiquidityETH(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory _amountsMin,\r\n        uint256 _minLiquidity,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable checkPairType(_pairType) returns (uint256[] memory _amounts, uint256 _liquidity) {\r\n        (_amounts, _liquidity) = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IPairRouter.addLiquidityETH.selector,\r\n                    _tokens,\r\n                    _amountDesireds,\r\n                    _amountsMin,\r\n                    _minLiquidity,\r\n                    _to,\r\n                    _deadline\r\n                )\r\n            ),\r\n            (uint256[], uint256)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity from a given pair\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _amountsMin The minimum amounts of each token to receive\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline for the transaction\r\n     * @return _amounts The amounts of tokens received\r\n     */\r\n    function removeLiquidity(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external checkPairType(_pairType) returns (uint256[] memory _amounts) {\r\n        _amounts = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IPairRouter.removeLiquidity.selector,\r\n                    _tokens,\r\n                    _liquidity,\r\n                    _amountsMin,\r\n                    _to,\r\n                    _deadline\r\n                )\r\n            ),\r\n            (uint256[])\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity from a given pair with ETH\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _amountsMin The minimum amounts of each token to receive\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline for the transaction\r\n     * @return _amounts The amounts of tokens received\r\n     */\r\n    function removeLiquidityETH(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external checkPairType(_pairType) returns (uint256[] memory _amounts) {\r\n        _amounts = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IPairRouter.removeLiquidityETH.selector,\r\n                    _tokens,\r\n                    _liquidity,\r\n                    _amountsMin,\r\n                    _to,\r\n                    _deadline\r\n                )\r\n            ),\r\n            (uint256[])\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity for a single token from a given pair\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _token The token to receive\r\n     * @param _minAmount The minimum amount of token to receive\r\n     * @param _to The address to send the token to\r\n     * @param _deadline The deadline for the transaction\r\n     * @return _amount The amount of token received\r\n     */\r\n    function removeLiquidityOneToken(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external checkPairType(_pairType) returns (uint256 _amount) {\r\n        _amount = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IStablPairRouter.removeLiquidityOneToken.selector,\r\n                    _tokens,\r\n                    _liquidity,\r\n                    _token,\r\n                    _minAmount,\r\n                    _to,\r\n                    _deadline\r\n                )\r\n            ),\r\n            (uint256)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity for a single token from a given pair with ETH\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _token The token to receive\r\n     * @param _minAmount The minimum amount of token to receive\r\n     * @param _to The address to send the token to\r\n     * @param _deadline The deadline for the transaction\r\n     * @return _amount The amount of token received\r\n     */\r\n    function removeLiquidityOneTokenETH(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external checkPairType(_pairType) returns (uint256 _amount) {\r\n        _amount = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IStablPairRouter.removeLiquidityOneTokenETH.selector,\r\n                    _tokens,\r\n                    _liquidity,\r\n                    _token,\r\n                    _minAmount,\r\n                    _to,\r\n                    _deadline\r\n                )\r\n            ),\r\n            (uint256)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity from a given pair with an imbalance of tokens\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _amounts The amounts of each token to remove\r\n     * @param _maxBurnAmount The maximum amount of liquidity to remove\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline for the transaction\r\n     * @return _amount The amount of liquidity removed\r\n     */\r\n    function removeLiquidityImbalance(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256[] calldata _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external checkPairType(_pairType) returns (uint256 _amount) {\r\n        _amount = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IStablPairRouter.removeLiquidityImbalance.selector,\r\n                    _tokens,\r\n                    _amounts,\r\n                    _maxBurnAmount,\r\n                    _to,\r\n                    _deadline\r\n                )\r\n            ),\r\n            (uint256)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity from a given pair with an imbalance of ETH and tokens\r\n     * @param _pairType The type of pair\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _amounts The amounts of each token to remove\r\n     * @param _maxBurnAmount The maximum amount of liquidity to remove\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline for the transaction\r\n     * @return _amount The amount of liquidity removed\r\n     */\r\n    function removeLiquidityImbalanceETH(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256[] calldata _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external checkPairType(_pairType) returns (uint256 _amount) {\r\n        _amount = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IStablPairRouter.removeLiquidityImbalanceETH.selector,\r\n                    _tokens,\r\n                    _amounts,\r\n                    _maxBurnAmount,\r\n                    _to,\r\n                    _deadline\r\n                )\r\n            ),\r\n            (uint256)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity from a given pair with a permit\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _amountsMin The minimum amounts of each token to remove\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline for the transaction\r\n     * @param _approveMax Whether to approve the maximum amount\r\n     * @param _v The v value of the permit signature\r\n     * @param _r The r value of the permit signature\r\n     * @param _s The s value of the permit signature\r\n     * @return _amounts The amounts of tokens removed\r\n     */\r\n    function removeLiquidityWithPermit(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external checkPairType(_pairType) returns (uint256[] memory _amounts) {\r\n        _amounts = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IPairRouter.removeLiquidityWithPermit.selector,\r\n                    _tokens,\r\n                    _liquidity,\r\n                    _amountsMin,\r\n                    _to,\r\n                    _deadline,\r\n                    _approveMax,\r\n                    _v,\r\n                    _r,\r\n                    _s\r\n                )\r\n            ),\r\n            (uint256[])\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity from a given pair with a permit\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _amountsMin The minimum amounts of each token to remove\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline for the transaction\r\n     * @param _approveMax Whether to approve the maximum amount\r\n     * @param _v The v value of the permit signature\r\n     * @param _r The r value of the permit signature\r\n     * @param _s The s value of the permit signature\r\n     * @return _amounts The amounts of tokens removed\r\n     */\r\n    function removeLiquidityETHWithPermit(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external checkPairType(_pairType) returns (uint256[] memory _amounts) {\r\n        _amounts = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IPairRouter.removeLiquidityETHWithPermit.selector,\r\n                    _tokens,\r\n                    _liquidity,\r\n                    _amountsMin,\r\n                    _to,\r\n                    _deadline,\r\n                    _approveMax,\r\n                    _v,\r\n                    _r,\r\n                    _s\r\n                )\r\n            ),\r\n            (uint256[])\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity for a single token with a permit\r\n     * @param _pairType The type of pair\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _token The token to remove liquidity for\r\n     * @param _minAmount The minimum amount of tokens to remove\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline for the transaction\r\n     * @param _approveMax Whether to approve the maximum amount\r\n     * @param _v The v value of the permit signature\r\n     * @param _r The r value of the permit signature\r\n     * @param _s The s value of the permit signature\r\n     * @return _tokenAmount The amount of tokens removed\r\n     */\r\n    function removeLiquidityOneTokenWithPermit(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256 _tokenAmount) {\r\n        require(pairTypes_[_pairType] != address(0), \"Router: invalid pair type\");\r\n        _tokenAmount = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IStablPairRouter.removeLiquidityOneTokenWithPermit.selector,\r\n                    _tokens,\r\n                    _liquidity,\r\n                    _token,\r\n                    _minAmount,\r\n                    _to,\r\n                    _deadline,\r\n                    _approveMax,\r\n                    _v,\r\n                    _r,\r\n                    _s\r\n                )\r\n            ),\r\n            (uint256)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity for a single token with a permit\r\n     * @param _pairType The type of pair\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _token The token to remove liquidity for\r\n     * @param _minAmount The minimum amount of tokens to remove\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline for the transaction\r\n     * @param _approveMax Whether to approve the maximum amount\r\n     * @param _v The v value of the permit signature\r\n     * @param _r The r value of the permit signature\r\n     * @param _s The s value of the permit signature\r\n     * @return _tokenAmount The amount of tokens removed\r\n     */\r\n    function removeLiquidityOneTokenETHWithPermit(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256 _tokenAmount) {\r\n        require(pairTypes_[_pairType] != address(0), \"Router: invalid pair type\");\r\n        _tokenAmount = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IStablPairRouter.removeLiquidityOneTokenETHWithPermit.selector,\r\n                    _tokens,\r\n                    _liquidity,\r\n                    _token,\r\n                    _minAmount,\r\n                    _to,\r\n                    _deadline,\r\n                    _approveMax,\r\n                    _v,\r\n                    _r,\r\n                    _s\r\n                )\r\n            ),\r\n            (uint256)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity imbalance for multiple tokens with a permit\r\n     * @param _pairType The type of pair\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _amounts The amounts of tokens to remove\r\n     * @param _maxBurnAmount The maximum amount of liquidity to remove\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline for the transaction\r\n     * @param _approveMax Whether to approve the maximum amount\r\n     * @param _v The v value of the permit signature\r\n     * @param _r The r value of the permit signature\r\n     * @param _s The s value of the permit signature\r\n     * @return _actualBurnAmount The actual amount of liquidity removed\r\n     */\r\n    function removeLiquidityImbalanceWithPermit(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256[] memory _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external checkPairType(_pairType) returns (uint256 _actualBurnAmount) {\r\n        _actualBurnAmount = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IStablPairRouter.removeLiquidityImbalanceWithPermit.selector,\r\n                    _tokens,\r\n                    _amounts,\r\n                    _maxBurnAmount,\r\n                    _to,\r\n                    _deadline,\r\n                    _approveMax,\r\n                    _v,\r\n                    _r,\r\n                    _s\r\n                )\r\n            ),\r\n            (uint256)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity imbalance for multiple tokens with a permit\r\n     * @param _pairType The type of pair\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _amounts The amounts of tokens to remove\r\n     * @param _maxBurnAmount The maximum amount of liquidity to remove\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline for the transaction\r\n     * @param _approveMax Whether to approve the maximum amount\r\n     * @param _v The v value of the permit signature\r\n     * @param _r The r value of the permit signature\r\n     * @param _s The s value of the permit signature\r\n     * @return _actualBurnAmount The actual amount of liquidity removed\r\n     */\r\n    function removeLiquidityImbalanceETHWithPermit(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256[] memory _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external checkPairType(_pairType) returns (uint256 _actualBurnAmount) {\r\n        _actualBurnAmount = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IStablPairRouter.removeLiquidityImbalanceETHWithPermit.selector,\r\n                    _tokens,\r\n                    _amounts,\r\n                    _maxBurnAmount,\r\n                    _to,\r\n                    _deadline,\r\n                    _approveMax,\r\n                    _v,\r\n                    _r,\r\n                    _s\r\n                )\r\n            ),\r\n            (uint256)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Swaps tokens through multiple pairs\r\n     * @param _routes The routes to swap through\r\n     * @param _amountIn The amount of tokens to swap\r\n     * @param _amountOutMin The minimum amount of tokens to receive\r\n     * @param _to The address to send the swapped tokens to\r\n     * @param _deadline The deadline for the transaction\r\n     * @return _amountOut The amount of tokens received\r\n     */\r\n    function swap(\r\n        Route[] memory _routes,\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 _amountOut) {\r\n        // Get the amounts of tokens to receive for each pair in the route\r\n        uint256[] memory _amounts = _getAmountsOut(_amountIn, _routes);\r\n        // Ensure that the amount of tokens received is greater than or equal to the minimum amount specified\r\n        require(_amounts[_amounts.length - 1] >= _amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n        // Transfer the input tokens from the sender to this contract\r\n        _routes[0].from.safeTransferFrom(msg.sender, address(this), _amountIn);\r\n        // Swap the tokens through each pair in the route\r\n        for (uint256 i = 0; i < _routes.length; i++) {\r\n            // Get the pair type for the current pair in the route\r\n            uint8 _pairType = IPair(_routes[i].pair).PAIR_TYPE();\r\n            // Set the receiver address for the current pair in the route\r\n            address _receiver = address(this);\r\n            if (i == _routes.length - 1) _receiver = _to;\r\n\r\n            // Call the swap function on the router contract for the current pair in the route\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IPairRouter.swap.selector,\r\n                    _routes[i],\r\n                    _amounts[i],\r\n                    _amounts[i + 1],\r\n                    _receiver,\r\n                    _deadline\r\n                )\r\n            );\r\n        }\r\n        // Set the amount of tokens received to the output amount\r\n        _amountOut = _amounts[_amounts.length - 1];\r\n    }\r\n\r\n    /**\r\n     * @dev Swaps ETH for tokens through multiple pairs\r\n     * @param _routes The routes to swap through\r\n     * @param _amountIn The amount of ETH to swap\r\n     * @param _amountOutMin The minimum amount of tokens to receive\r\n     * @param _to The address to send the swapped tokens to\r\n     * @param _deadline The deadline for the transaction\r\n     * @return _amountOut The amount of tokens received\r\n     */\r\n    function swapETH(\r\n        Route[] memory _routes,\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable returns (uint256 _amountOut) {\r\n        // Get the amounts of tokens to receive for each pair in the route\r\n        uint256[] memory _amounts = _getAmountsOut(_amountIn, _routes);\r\n        // Ensure that the amount of tokens received is greater than or equal to the minimum amount specified\r\n        require(_amounts[_amounts.length - 1] >= _amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n\r\n        // If the input token is WETH, ensure that the amount of ETH sent is equal to the amount to swap\r\n        if (_routes[0].from == address(weth_)) {\r\n            require(msg.value == _amountIn, \"Router: msg.value is not equal to _amountIn\");\r\n            // Deposit the ETH into WETH\r\n            weth_.deposit{ value: msg.value }();\r\n        } else {\r\n            require(msg.value == 0, \"Router: msg.value is not equal to 0\");\r\n            // Transfer the input tokens from the sender to this contract\r\n            _routes[0].from.safeTransferFrom(msg.sender, address(this), _amountIn);\r\n        }\r\n\r\n        // Swap the tokens through each pair in the route\r\n        for (uint256 i = 0; i < _routes.length; i++) {\r\n            // Get the pair type for the current pair in the route\r\n            uint8 _pairType = IPair(_routes[i].pair).PAIR_TYPE();\r\n            // Set the receiver address for the current pair in the route\r\n            address _receiver = address(this);\r\n            if (i == _routes.length - 1 && _routes[i].to != address(weth_)) _receiver = _to;\r\n\r\n            // Call the swap function on the router contract for the current pair in the route\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IPairRouter.swap.selector,\r\n                    _routes[i],\r\n                    _amounts[i],\r\n                    _amounts[i + 1],\r\n                    _receiver,\r\n                    _deadline\r\n                )\r\n            );\r\n        }\r\n        // Set the amount of tokens received to the output amount\r\n        _amountOut = _amounts[_amounts.length - 1];\r\n\r\n        // If the output token is WETH, withdraw the WETH and transfer the ETH to the recipient\r\n        if (_routes[_routes.length - 1].to == address(weth_)) {\r\n            weth_.withdraw(_amountOut);\r\n            _to.safeTransferETH(_amountOut);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the pair types for the router contract\r\n     * @param _pairRouter The address of the pair router contract\r\n     */\r\n    function setPairTypes(address _pairRouter) external onlyManager {\r\n        // Get the pair type for the pair router contract\r\n        uint8 _pairType = IPairRouter(_pairRouter).PAIR_TYPE();\r\n        // Set the pair type for the router contract\r\n        pairTypes_[_pairType] = _pairRouter;\r\n        // Emit an event indicating that the pair types have been set\r\n        emit SetPairTypes(_pairType, _pairRouter);\r\n    }\r\n}\r\n"
    },
    "contracts/RouterBeta.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\nimport \"./utils/TransferHelper.sol\";\r\n\r\nimport \"./interface/IWETH.sol\";\r\nimport \"./interface/IPair.sol\";\r\nimport \"./interface/IPairRouter.sol\";\r\nimport \"./interface/IPairFactory.sol\";\r\n\r\n/**\r\n * @title RouterBeta contract\r\n * @dev This contract handles the routing of tokens in the dForce AMM ecosystem\r\n */\r\ncontract RouterBeta is Initializable {\r\n    using Address for address;\r\n    using TransferHelper for address;\r\n\r\n    /**\r\n     * @dev Struct to represent a route between two tokens\r\n     */\r\n    struct Route {\r\n        address from; // Address of the token to convert from\r\n        address to; // Address of the token to convert to\r\n        address pair; // Address of the pair contract that connects the two tokens\r\n    }\r\n\r\n    /**\r\n     * @dev Address of the factory contract\r\n     */\r\n    address public factory;\r\n\r\n    /**\r\n     * @dev Address of the WETH contract\r\n     */\r\n    IWETH internal weth_;\r\n\r\n    /**\r\n     * @dev Mapping of pair types to their respective router contracts\r\n     */\r\n    mapping(uint8 => address) internal pairTypes_;\r\n\r\n    /**\r\n     * @dev Event emitted when a pair type is set\r\n     */\r\n    event SetPairTypes(uint8 pairType, address router);\r\n\r\n    /**\r\n     * @dev Constructor function for the Router contract\r\n     * @param _factory Address of the factory contract\r\n     * @param _weth Address of the WETH contract\r\n     */\r\n    constructor(address _factory, address _weth) public {\r\n        initialize(_factory, _weth);\r\n    }\r\n\r\n    /**\r\n     * @dev Initializes the Router contract\r\n     * @param _factory Address of the factory contract\r\n     * @param _weth Address of the WETH contract\r\n     */\r\n    function initialize(address _factory, address _weth) public initializer {\r\n        factory = _factory;\r\n        weth_ = IWETH(_weth);\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function to receive ETH from WETH contract\r\n     */\r\n    receive() external payable {\r\n        assert(msg.sender == address(weth_)); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to restrict access to only the manager\r\n     */\r\n    modifier onlyManager() {\r\n        require(msg.sender == IPairFactory(factory).manager(), \"Router: not manager\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to check if the given pair type is valid\r\n     * @param _pairType The pair type to check\r\n     */\r\n    modifier checkPairType(uint8 _pairType) {\r\n        require(pairTypes_[_pairType] != address(0), \"Router: invalid pair type\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the WETH contract\r\n     */\r\n    function weth() external view returns (address) {\r\n        return address(weth_);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the router contract for a given pair type\r\n     * @param _pairType The pair type\r\n     */\r\n    function pairTypes(uint8 _pairType) external view returns (address) {\r\n        return pairTypes_[_pairType];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens that will be received for a given input amount and route\r\n     * @param _amountIn The input amount\r\n     * @param _routes The route to take\r\n     * @return _amounts The amounts of tokens that will be received\r\n     */\r\n    function _getAmountsOut(\r\n        uint256 _amountIn,\r\n        Route[] memory _routes\r\n    ) internal view returns (uint256[] memory _amounts) {\r\n        _amounts = new uint256[](_routes.length + 1);\r\n        _amounts[0] = _amountIn;\r\n\r\n        for (uint256 i = 0; i < _routes.length; i++)\r\n            _amounts[i + 1] = IPair(_routes[i].pair).getAmountOut(_routes[i].from, _routes[i].to, _amounts[i]);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens that will be received for a given input amount and route\r\n     * @param _amountIn The input amount\r\n     * @param _routes The route to take\r\n     */\r\n    function getAmountsOutPath(\r\n        uint256 _amountIn,\r\n        Route[] memory _routes\r\n    ) external view returns (uint256[] memory _amounts) {\r\n        _amounts = _getAmountsOut(_amountIn, _routes);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens that will be received for a given input amount and route\r\n     * @param _amountIn The input amount\r\n     * @param _routes The route to take\r\n     */\r\n    function getAmountsOut(uint256 _amountIn, Route[] memory _routes) external view returns (uint256) {\r\n        require(_routes.length >= 1, \"Router: INVALID_PATH\");\r\n        uint256[] memory _amounts = _getAmountsOut(_amountIn, _routes);\r\n        return _amounts[_amounts.length - 1];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the pair for the given tokens and pair type\r\n     * @param _tokens The tokens to get the pair address for\r\n     * @param _type The pair type\r\n     * @return _pair The address of the pair\r\n     * @return _has Whether or not the pair exists\r\n     */\r\n    function pairFor(address[] memory _tokens, uint8 _type) external view returns (address _pair, bool _has) {\r\n        _pair = IPairFactory(factory).getPairAddress(_tokens, _type);\r\n        _has = IPairFactory(factory).isPair(_pair);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the reserves of the volatile pair for the given tokens\r\n     * @param _tokens The tokens to get the reserves for\r\n     * @return _reserveA The reserve of token A\r\n     * @return _reserveB The reserve of token B\r\n     */\r\n    function getReserves(address[] memory _tokens) external view returns (uint256 _reserveA, uint256 _reserveB) {\r\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, 1);\r\n        if (IPairFactory(factory).isPair(_pair))\r\n            (_reserveA, _reserveB) = IVolatileRouter(pairTypes_[1]).getReserves(_pair, _tokens);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens required to add liquidity to a given pair\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to add liquidity for\r\n     * @param _amountDesireds The desired amounts of each token to add liquidity for\r\n     */\r\n    function quoteAddLiquidity(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds\r\n    ) external view returns (uint256[] memory _amountIn, uint256 liquidity) {\r\n        address _router = pairTypes_[_pairType];\r\n        bytes memory _returns = _router.functionStaticCall(\r\n            abi.encodeWithSelector(IPairRouter.quoteAddLiquidity.selector, _tokens, _amountDesireds)\r\n        );\r\n        (_amountIn, liquidity) = abi.decode(_returns, (uint256[], uint256));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens that will be received when removing liquidity from a given pair\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     */\r\n    function quoteRemoveLiquidity(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256 _liquidity\r\n    ) external view returns (uint256[] memory _amounts) {\r\n        address _router = pairTypes_[_pairType];\r\n        bytes memory _returns = _router.functionStaticCall(\r\n            abi.encodeWithSelector(IPairRouter.quoteRemoveLiquidity.selector, _tokens, _liquidity)\r\n        );\r\n        _amounts = abi.decode(_returns, (uint256[]));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of a specific token that will be received when removing liquidity from a given pair\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _token The token to receive\r\n     * @param _liquidity The amount of liquidity to remove\r\n     */\r\n    function quoteRemoveLiquidityOneToken(\r\n        uint8 _pairType,\r\n        address[] calldata _tokens,\r\n        address _token,\r\n        uint256 _liquidity\r\n    ) external view returns (uint256 _amount) {\r\n        address _router = pairTypes_[_pairType];\r\n        bytes memory _returns = _router.functionStaticCall(\r\n            abi.encodeWithSelector(IStablPairRouter.quoteRemoveLiquidityOneToken.selector, _tokens, _token, _liquidity)\r\n        );\r\n        _amount = abi.decode(_returns, (uint256));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens that will be removed when removing liquidity from a given pair\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _amounts The desired amounts of each token to remove liquidity for\r\n     */\r\n    function quoteRemoveLiquidityImbalance(\r\n        uint8 _pairType,\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts\r\n    ) external view returns (uint256 _amount) {\r\n        address _router = pairTypes_[_pairType];\r\n        bytes memory _returns = _router.functionStaticCall(\r\n            abi.encodeWithSelector(IStablPairRouter.quoteRemoveLiquidityImbalance.selector, _tokens, _amounts)\r\n        );\r\n        _amount = abi.decode(_returns, (uint256));\r\n    }\r\n\r\n    /**\r\n     * @dev Adds liquidity to a given pair\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to add liquidity for\r\n     * @param _amountDesireds The desired amounts of each token to add liquidity for\r\n     * @param _amountsMin The minimum amounts of each token to add liquidity for\r\n     * @param _minLiquidity The minimum liquidity to add\r\n     * @param _to The address to send the liquidity to\r\n     * @param _deadline The deadline for the transaction\r\n     * @return _amounts The amounts of tokens added\r\n     * @return _liquidity The amount of liquidity added\r\n     */\r\n    function addLiquidity(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory _amountsMin,\r\n        uint256 _minLiquidity,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external checkPairType(_pairType) returns (uint256[] memory _amounts, uint256 _liquidity) {\r\n        (_amounts, _liquidity) = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IPairRouter.addLiquidity.selector,\r\n                    _tokens,\r\n                    _amountDesireds,\r\n                    _amountsMin,\r\n                    _minLiquidity,\r\n                    _to,\r\n                    _deadline\r\n                )\r\n            ),\r\n            (uint256[], uint256)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity from a given pair\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _amountsMin The minimum amounts of each token to receive\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline for the transaction\r\n     * @return _amounts The amounts of tokens received\r\n     */\r\n    function removeLiquidity(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external checkPairType(_pairType) returns (uint256[] memory _amounts) {\r\n        _amounts = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IPairRouter.removeLiquidity.selector,\r\n                    _tokens,\r\n                    _liquidity,\r\n                    _amountsMin,\r\n                    _to,\r\n                    _deadline\r\n                )\r\n            ),\r\n            (uint256[])\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity for a single token from a given pair\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _token The token to receive\r\n     * @param _minAmount The minimum amount of token to receive\r\n     * @param _to The address to send the token to\r\n     * @param _deadline The deadline for the transaction\r\n     * @return _amount The amount of token received\r\n     */\r\n    function removeLiquidityOneToken(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external checkPairType(_pairType) returns (uint256 _amount) {\r\n        _amount = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IStablPairRouter.removeLiquidityOneToken.selector,\r\n                    _tokens,\r\n                    _liquidity,\r\n                    _token,\r\n                    _minAmount,\r\n                    _to,\r\n                    _deadline\r\n                )\r\n            ),\r\n            (uint256)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity from a given pair with an imbalance of tokens\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _amounts The amounts of each token to remove\r\n     * @param _maxBurnAmount The maximum amount of liquidity to remove\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline for the transaction\r\n     * @return _amount The amount of liquidity removed\r\n     */\r\n    function removeLiquidityImbalance(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256[] calldata _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external checkPairType(_pairType) returns (uint256 _amount) {\r\n        _amount = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IStablPairRouter.removeLiquidityImbalance.selector,\r\n                    _tokens,\r\n                    _amounts,\r\n                    _maxBurnAmount,\r\n                    _to,\r\n                    _deadline\r\n                )\r\n            ),\r\n            (uint256)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity from a given pair with a permit\r\n     * @param _pairType The pair type\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _amountsMin The minimum amounts of each token to remove\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline for the transaction\r\n     * @param _approveMax Whether to approve the maximum amount\r\n     * @param _v The v value of the permit signature\r\n     * @param _r The r value of the permit signature\r\n     * @param _s The s value of the permit signature\r\n     * @return _amounts The amounts of tokens removed\r\n     */\r\n    function removeLiquidityWithPermit(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external checkPairType(_pairType) returns (uint256[] memory _amounts) {\r\n        _amounts = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IPairRouter.removeLiquidityWithPermit.selector,\r\n                    _tokens,\r\n                    _liquidity,\r\n                    _amountsMin,\r\n                    _to,\r\n                    _deadline,\r\n                    _approveMax,\r\n                    _v,\r\n                    _r,\r\n                    _s\r\n                )\r\n            ),\r\n            (uint256[])\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity for a single token with a permit\r\n     * @param _pairType The type of pair\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _token The token to remove liquidity for\r\n     * @param _minAmount The minimum amount of tokens to remove\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline for the transaction\r\n     * @param _approveMax Whether to approve the maximum amount\r\n     * @param _v The v value of the permit signature\r\n     * @param _r The r value of the permit signature\r\n     * @param _s The s value of the permit signature\r\n     * @return _tokenAmount The amount of tokens removed\r\n     */\r\n    function removeLiquidityOneTokenWithPermit(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256 _tokenAmount) {\r\n        require(pairTypes_[_pairType] != address(0), \"Router: invalid pair type\");\r\n        _tokenAmount = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IStablPairRouter.removeLiquidityOneTokenWithPermit.selector,\r\n                    _tokens,\r\n                    _liquidity,\r\n                    _token,\r\n                    _minAmount,\r\n                    _to,\r\n                    _deadline,\r\n                    _approveMax,\r\n                    _v,\r\n                    _r,\r\n                    _s\r\n                )\r\n            ),\r\n            (uint256)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity imbalance for multiple tokens with a permit\r\n     * @param _pairType The type of pair\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _amounts The amounts of tokens to remove\r\n     * @param _maxBurnAmount The maximum amount of liquidity to remove\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline for the transaction\r\n     * @param _approveMax Whether to approve the maximum amount\r\n     * @param _v The v value of the permit signature\r\n     * @param _r The r value of the permit signature\r\n     * @param _s The s value of the permit signature\r\n     * @return _actualBurnAmount The actual amount of liquidity removed\r\n     */\r\n    function removeLiquidityImbalanceWithPermit(\r\n        uint8 _pairType,\r\n        address[] memory _tokens,\r\n        uint256[] memory _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external checkPairType(_pairType) returns (uint256 _actualBurnAmount) {\r\n        _actualBurnAmount = abi.decode(\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IStablPairRouter.removeLiquidityImbalanceWithPermit.selector,\r\n                    _tokens,\r\n                    _amounts,\r\n                    _maxBurnAmount,\r\n                    _to,\r\n                    _deadline,\r\n                    _approveMax,\r\n                    _v,\r\n                    _r,\r\n                    _s\r\n                )\r\n            ),\r\n            (uint256)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Swaps tokens through multiple pairs\r\n     * @param _routes The routes to swap through\r\n     * @param _amountIn The amount of tokens to swap\r\n     * @param _amountOutMin The minimum amount of tokens to receive\r\n     * @param _to The address to send the swapped tokens to\r\n     * @param _deadline The deadline for the transaction\r\n     * @return _amountOut The amount of tokens received\r\n     */\r\n    function swap(\r\n        Route[] memory _routes,\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 _amountOut) {\r\n        // Get the amounts of tokens to receive for each pair in the route\r\n        uint256[] memory _amounts = _getAmountsOut(_amountIn, _routes);\r\n        // Ensure that the amount of tokens received is greater than or equal to the minimum amount specified\r\n        require(_amounts[_amounts.length - 1] >= _amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n        // Transfer the input tokens from the sender to this contract\r\n        _routes[0].from.safeTransferFrom(msg.sender, address(this), _amountIn);\r\n        // Swap the tokens through each pair in the route\r\n        for (uint256 i = 0; i < _routes.length; i++) {\r\n            // Get the pair type for the current pair in the route\r\n            uint8 _pairType = IPair(_routes[i].pair).PAIR_TYPE();\r\n            // Set the receiver address for the current pair in the route\r\n            address _receiver = address(this);\r\n            if (i == _routes.length - 1) _receiver = _to;\r\n\r\n            // Call the swap function on the router contract for the current pair in the route\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IPairRouter.swap.selector,\r\n                    _routes[i],\r\n                    _amounts[i],\r\n                    _amounts[i + 1],\r\n                    _receiver,\r\n                    _deadline\r\n                )\r\n            );\r\n        }\r\n        // Set the amount of tokens received to the output amount\r\n        _amountOut = _amounts[_amounts.length - 1];\r\n    }\r\n\r\n    /**\r\n     * @dev Swaps ETH for tokens through multiple pairs\r\n     * @param _routes The routes to swap through\r\n     * @param _amountIn The amount of ETH to swap\r\n     * @param _amountOutMin The minimum amount of tokens to receive\r\n     * @param _to The address to send the swapped tokens to\r\n     * @param _deadline The deadline for the transaction\r\n     * @return _amountOut The amount of tokens received\r\n     */\r\n    function swapETH(\r\n        Route[] memory _routes,\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable returns (uint256 _amountOut) {\r\n        // Get the amounts of tokens to receive for each pair in the route\r\n        uint256[] memory _amounts = _getAmountsOut(_amountIn, _routes);\r\n        // Ensure that the amount of tokens received is greater than or equal to the minimum amount specified\r\n        require(_amounts[_amounts.length - 1] >= _amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n\r\n        // If the input token is WETH, ensure that the amount of ETH sent is equal to the amount to swap\r\n        if (_routes[0].from == address(weth_)) {\r\n            require(msg.value == _amountIn, \"Router: msg.value is not equal to _amountIn\");\r\n            // Deposit the ETH into WETH\r\n            weth_.deposit{ value: msg.value }();\r\n        } else {\r\n            // Transfer the input tokens from the sender to this contract\r\n            _routes[0].from.safeTransferFrom(msg.sender, address(this), _amountIn);\r\n        }\r\n\r\n        // Swap the tokens through each pair in the route\r\n        for (uint256 i = 0; i < _routes.length; i++) {\r\n            // Get the pair type for the current pair in the route\r\n            uint8 _pairType = IPair(_routes[i].pair).PAIR_TYPE();\r\n            // Set the receiver address for the current pair in the route\r\n            address _receiver = address(this);\r\n            if (i == _routes.length - 1 && _routes[i].to != address(weth_)) _receiver = _to;\r\n\r\n            // Call the swap function on the router contract for the current pair in the route\r\n            pairTypes_[_pairType].functionDelegateCall(\r\n                abi.encodeWithSelector(\r\n                    IPairRouter.swap.selector,\r\n                    _routes[i],\r\n                    _amounts[i],\r\n                    _amounts[i + 1],\r\n                    _receiver,\r\n                    _deadline\r\n                )\r\n            );\r\n        }\r\n        // Set the amount of tokens received to the output amount\r\n        _amountOut = _amounts[_amounts.length - 1];\r\n\r\n        // If the output token is WETH, withdraw the WETH and transfer the ETH to the recipient\r\n        if (_routes[_routes.length - 1].to == address(weth_)) {\r\n            weth_.withdraw(_amountOut);\r\n            _to.safeTransferETH(_amountOut);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the pair types for the router contract\r\n     * @param _pairRouter The address of the pair router contract\r\n     */\r\n    function setPairTypes(address _pairRouter) external onlyManager {\r\n        // Get the pair type for the pair router contract\r\n        uint8 _pairType = IPairRouter(_pairRouter).PAIR_TYPE();\r\n        // Set the pair type for the router contract\r\n        pairTypes_[_pairType] = _pairRouter;\r\n        // Emit an event indicating that the pair types have been set\r\n        emit SetPairTypes(_pairType, _pairRouter);\r\n    }\r\n}\r\n"
    },
    "contracts/routers/StableRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../utils/TransferHelper.sol\";\r\n\r\nimport \"../interface/IPairRouter.sol\";\r\nimport \"../interface/IPairFactory.sol\";\r\nimport \"../interface/IPair.sol\";\r\nimport \"../interface/IWETH.sol\";\r\nimport \"../interface/IPairERC20.sol\";\r\n\r\n/**\r\n * @title StableRouter\r\n * @notice Router for stablecoin pairs\r\n * @dev This contract implements the IStablPairRouter interface\r\n */\r\ncontract StableRouter is IStablPairRouter {\r\n    using TransferHelper for address;\r\n\r\n    // The type of pair\r\n    uint8 internal constant PAIR_TYPE_ = 2;\r\n\r\n    // The address of the factory contract\r\n    address internal immutable factory_;\r\n    // The WETH contract\r\n    IWETH internal immutable weth_;\r\n\r\n    constructor(address _factory, address _weth) public {\r\n        factory_ = _factory;\r\n        weth_ = IWETH(_weth);\r\n    }\r\n\r\n    // Get the type of pair\r\n    function PAIR_TYPE() external view override returns (uint8) {\r\n        return PAIR_TYPE_;\r\n    }\r\n\r\n    // Get the address of the factory contract\r\n    function factory() external view returns (address) {\r\n        return factory_;\r\n    }\r\n\r\n    // Get the address of the WETH contract\r\n    function weth() external view returns (address) {\r\n        return address(weth_);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount of tokens needed to add liquidity to a pair\r\n     * @param _tokens The tokens to add liquidity for\r\n     * @param _amountDesireds The desired amounts of each token\r\n     * @return _amountIn The amounts of each token needed to add liquidity\r\n     * @return _liquidity The amount of liquidity that will be added\r\n     */\r\n    function quoteAddLiquidity(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amountDesireds\r\n    ) external view override returns (uint256[] memory _amountIn, uint256 _liquidity) {\r\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\r\n        bool _isPair = IPairFactory(factory_).isPair(_pair);\r\n        if (_isPair) {\r\n            _amountIn = _amountDesireds;\r\n            (bool _success, bytes memory _res) = _pair.staticcall(\r\n                abi.encodeWithSignature(\r\n                    \"calculateTokenAmount(address[],uint256[],bool)\",\r\n                    _tokens,\r\n                    _amountDesireds,\r\n                    true\r\n                )\r\n            );\r\n            if (_success) _liquidity = abi.decode(_res, (uint256));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount of tokens that will be received upon removing liquidity from a pair\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @return _amounts The amounts of each token that will be received\r\n     */\r\n    function quoteRemoveLiquidity(\r\n        address[] calldata _tokens,\r\n        uint256 _liquidity\r\n    ) external view override returns (uint256[] memory _amounts) {\r\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\r\n        if (IPairFactory(factory_).isPair(_pair))\r\n            _amounts = IStablePair(_pair).calculateRemoveLiquidity(_tokens, _liquidity);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount of a specific token that will be received upon removing liquidity from a pair\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _token The token to calculate the amount for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @return _amount The amount of the specified token that will be received\r\n     */\r\n    function quoteRemoveLiquidityOneToken(\r\n        address[] calldata _tokens,\r\n        address _token,\r\n        uint256 _liquidity\r\n    ) external view override returns (uint256 _amount) {\r\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\r\n        if (IPairFactory(factory_).isPair(_pair))\r\n            _amount = IStablePair(_pair).calculateRemoveLiquidityOneToken(_token, _liquidity);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount of liquidity that will be removed when removing an imbalanced amount of tokens from a pair\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _amounts The amounts of each token to remove\r\n     * @return _liquidity The amount of liquidity that will be removed\r\n     */\r\n    function quoteRemoveLiquidityImbalance(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts\r\n    ) external view override returns (uint256 _liquidity) {\r\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\r\n        if (IPairFactory(factory_).isPair(_pair))\r\n            _liquidity = IStablePair(_pair).calculateTokenAmount(_tokens, _amounts, false) + 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds liquidity to a pair\r\n     * @param _tokens The tokens to add liquidity for\r\n     * @param _amountDesireds The desired amounts of each token to add\r\n     * @param _amountMin Unused\r\n     * @param _minLiquidity The minimum amount of liquidity to add\r\n     * @param _to The address to send the liquidity to\r\n     * @param _deadline The deadline to add liquidity by\r\n     * @return _amounts The actual amounts of each token added\r\n     * @return _liquidity The amount of liquidity added\r\n     */\r\n    function addLiquidity(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory _amountMin, // Unused\r\n        uint256 _minLiquidity,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external override returns (uint256[] memory _amounts, uint256 _liquidity) {\r\n        _amountMin;\r\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\r\n        require(IPairFactory(factory_).isPair(_pair), \"StableRouter: is not pair\");\r\n\r\n        // Transfer tokens from sender to contract and approve for pair\r\n        _amounts = _amountDesireds;\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            _tokens[i].safeTransferFrom(msg.sender, address(this), _amounts[i]);\r\n            _tokens[i].safeApprove(_pair, _amounts[i]);\r\n        }\r\n\r\n        // Add liquidity to pair\r\n        _liquidity = IStablePair(_pair).addLiquidity(_tokens, _amounts, _minLiquidity, _to, _deadline);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds liquidity to a pair with ETH\r\n     * @param _tokens The tokens to add liquidity for\r\n     * @param _amountDesireds The desired amounts of each token to add\r\n     * @param _amountMin Unused\r\n     * @param _minLiquidity The minimum amount of liquidity to add\r\n     * @param _to The address to send the liquidity to\r\n     * @param _deadline The deadline to add liquidity by\r\n     * @return _amounts The actual amounts of each token added\r\n     * @return _liquidity The amount of liquidity added\r\n     */\r\n    function addLiquidityETH(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory _amountMin, // Unused\r\n        uint256 _minLiquidity,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable override returns (uint256[] memory _amounts, uint256 _liquidity) {\r\n        _amountMin;\r\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\r\n        require(IPairFactory(factory_).isPair(_pair), \"StableRouter: is not pair\");\r\n\r\n        // Transfer tokens from sender to contract and approve for pair\r\n        _amounts = _amountDesireds;\r\n        uint256 _amountETH;\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            _tokens[i].safeApprove(_pair, _amounts[i]);\r\n            if (_tokens[i] == address(weth_)) {\r\n                _amountETH = _amounts[i];\r\n                weth_.deposit{ value: _amounts[i] }();\r\n                continue;\r\n            }\r\n            _tokens[i].safeTransferFrom(msg.sender, address(this), _amounts[i]);\r\n        }\r\n\r\n        // Add liquidity to pair\r\n        _liquidity = IStablePair(_pair).addLiquidity(_tokens, _amounts, _minLiquidity, _to, _deadline);\r\n\r\n        if (msg.value > _amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - _amountETH);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove liquidity from a pair\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _amountsMin The minimum amounts of each token to receive\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline to remove liquidity by\r\n     * @return _pairTokens The tokens in the pair\r\n     * @return _amounts The actual amounts of each token received\r\n     */\r\n    function _removeLiquidity(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) internal returns (address[] memory _pairTokens, uint256[] memory _amounts) {\r\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\r\n        require(IPairFactory(factory_).isPair(_pair), \"StableRouter: is not pair\"); // send liquidity to pair\r\n\r\n        address _lpToken = IStablePair(_pair).lpToken();\r\n        _lpToken.safeTransferFrom(msg.sender, address(this), _liquidity);\r\n        _lpToken.safeApprove(_pair, _liquidity);\r\n\r\n        _amounts = IStablePair(_pair).removeLiquidity(_liquidity, _tokens, _amountsMin, _to, _deadline);\r\n        _pairTokens = IPair(_pair).tokens();\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens out of the contract with ETH\r\n     * @param _tokens The tokens to transfer out\r\n     * @param _amounts The amounts of each token to transfer out\r\n     * @param _to The address to send the tokens to\r\n     */\r\n    function _transferOutWithETH(address[] memory _tokens, uint256[] memory _amounts, address _to) internal {\r\n        uint256 _amountETH;\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            if (_tokens[i] == address(weth_)) {\r\n                _amountETH = _amounts[i];\r\n                weth_.withdraw(_amountETH);\r\n                // _to.safeTransferETH(_amounts[i]);\r\n                continue;\r\n            }\r\n            _tokens[i].safeTransfer(_to, _amounts[i]);\r\n        }\r\n        _to.safeTransferETH(_amountETH);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove liquidity from a pair\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _amountsMin The minimum amounts of each token to receive\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline to remove liquidity by\r\n     * @return _amounts The actual amounts of each token received\r\n     */\r\n    function removeLiquidity(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public override returns (uint256[] memory _amounts) {\r\n        (, _amounts) = _removeLiquidity(_tokens, _liquidity, _amountsMin, _to, _deadline);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove liquidity from a pair with ETH\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _amountsMin The minimum amounts of each token to receive\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline to remove liquidity by\r\n     * @return _amounts The actual amounts of each token received\r\n     */\r\n    function removeLiquidityETH(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public override returns (uint256[] memory _amounts) {\r\n        address[] memory _pairTokens;\r\n        (_pairTokens, _amounts) = _removeLiquidity(_tokens, _liquidity, _amountsMin, address(this), _deadline);\r\n        _transferOutWithETH(_pairTokens, _amounts, _to);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove liquidity from a pair for a single token\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _token The token to receive\r\n     * @param _minAmount The minimum amount of token to receive\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline to remove liquidity by\r\n     * @return _tokenAmount The actual amount of token received\r\n     */\r\n    function _removeLiquidityOneToken(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) internal returns (uint256 _tokenAmount) {\r\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\r\n        require(IPairFactory(factory_).isPair(_pair), \"StableRouter: is not pair\");\r\n\r\n        address _lpToken = IStablePair(_pair).lpToken();\r\n        _lpToken.safeTransferFrom(msg.sender, address(this), _liquidity);\r\n        _lpToken.safeApprove(_pair, _liquidity);\r\n\r\n        _tokenAmount = IStablePair(_pair).removeLiquidityOneToken(_liquidity, _token, _minAmount, _to, _deadline);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove liquidity for a single token from a pair\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _token The token to receive\r\n     * @param _minAmount The minimum amount of token to receive\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline to remove liquidity by\r\n     * @return _tokenAmount The actual amount of token received\r\n     */\r\n    function removeLiquidityOneToken(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public override returns (uint256 _tokenAmount) {\r\n        _tokenAmount = _removeLiquidityOneToken(_tokens, _liquidity, _token, _minAmount, _to, _deadline);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove liquidity for a single token from a pair with ETH\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _token The token to receive (must be WETH)\r\n     * @param _minAmount The minimum amount of token to receive\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline to remove liquidity by\r\n     * @return _tokenAmount The actual amount of token received\r\n     */\r\n    function removeLiquidityOneTokenETH(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public override returns (uint256 _tokenAmount) {\r\n        require(_token == address(weth_), \"StableRouter: token must be WETH\");\r\n\r\n        _tokenAmount = _removeLiquidityOneToken(_tokens, _liquidity, _token, _minAmount, address(this), _deadline);\r\n\r\n        weth_.withdraw(_tokenAmount);\r\n        _to.safeTransferETH(_tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove liquidity imbalance for multiple tokens from a pair\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _amounts The amounts of tokens to remove liquidity for\r\n     * @param _maxBurnAmount The maximum amount of liquidity to remove\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline to remove liquidity by\r\n     * @return _actualBurnAmount The actual amount of liquidity burned\r\n     */\r\n    function _removeLiquidityImbalance(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) internal returns (uint256 _actualBurnAmount) {\r\n        // Get the pair address from the factory\r\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\r\n        // Ensure that the pair exists\r\n        require(IPairFactory(factory_).isPair(_pair), \"StableRouter: is not pair\");\r\n\r\n        // Get the LP token address\r\n        address _lpToken = IStablePair(_pair).lpToken();\r\n        // Transfer the LP tokens from the sender to this contract\r\n        _lpToken.safeTransferFrom(msg.sender, address(this), _maxBurnAmount);\r\n        // Approve the LP tokens for the pair\r\n        _lpToken.safeApprove(_pair, _maxBurnAmount);\r\n\r\n        // Remove the liquidity imbalance\r\n        _actualBurnAmount = IStablePair(_pair).removeLiquidityImbalance(\r\n            _tokens,\r\n            _amounts,\r\n            _maxBurnAmount,\r\n            _to,\r\n            _deadline\r\n        );\r\n\r\n        // If the actual burn amount is less than the maximum burn amount, transfer the remaining LP tokens back to the sender\r\n        if (_maxBurnAmount > _actualBurnAmount) {\r\n            _lpToken.safeApprove(_pair, 0);\r\n            _lpToken.safeTransfer(msg.sender, _maxBurnAmount - _actualBurnAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Remove liquidity imbalance for multiple tokens from a pair\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _amounts The amounts of tokens to remove liquidity for\r\n     * @param _maxBurnAmount The maximum amount of liquidity to remove\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline to remove liquidity by\r\n     * @return _actualBurnAmount The actual amount of liquidity burned\r\n     */\r\n    function removeLiquidityImbalance(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public override returns (uint256 _actualBurnAmount) {\r\n        _actualBurnAmount = _removeLiquidityImbalance(_tokens, _amounts, _maxBurnAmount, _to, _deadline);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove liquidity imbalance for multiple tokens from a pair with ETH\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _amounts The amounts of tokens to remove liquidity for\r\n     * @param _maxBurnAmount The maximum amount of liquidity to remove\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline to remove liquidity by\r\n     * @return _actualBurnAmount The actual amount of liquidity burned\r\n     */\r\n    function removeLiquidityImbalanceETH(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public override returns (uint256 _actualBurnAmount) {\r\n        // Remove liquidity imbalance for multiple tokens from a pair\r\n        _actualBurnAmount = _removeLiquidityImbalance(_tokens, _amounts, _maxBurnAmount, address(this), _deadline);\r\n        // Transfer tokens out with ETH\r\n        _transferOutWithETH(_tokens, _amounts, _to);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the LP tokens for the pair using permit\r\n     * @param _pair The address of the pair\r\n     * @param _liquidity The amount of liquidity to approve\r\n     * @param _deadline The deadline to approve by\r\n     * @param _approveMax Whether to approve the maximum amount of liquidity\r\n     * @param _v The v value of the permit signature\r\n     * @param _r The r value of the permit signature\r\n     * @param _s The s value of the permit signature\r\n     */\r\n    function _withPermit(\r\n        address _pair,\r\n        uint256 _liquidity,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) internal {\r\n        // Determine the value to approve\r\n        uint256 _value = _approveMax ? uint256(-1) : _liquidity;\r\n        // Get the LP token address\r\n        address _lpToken = IStablePair(_pair).lpToken();\r\n        // Approve the LP tokens using permit\r\n        IPairERC20(_lpToken).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove liquidity with permit\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _amountsMin The minimum amounts of tokens to receive\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline to remove liquidity by\r\n     * @param _approveMax Whether to approve the maximum amount of liquidity\r\n     * @param _v The v value of the permit signature\r\n     * @param _r The r value of the permit signature\r\n     * @param _s The s value of the permit signature\r\n     * @return _amounts The actual amounts of tokens received\r\n     */\r\n    function removeLiquidityWithPermit(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external override returns (uint256[] memory _amounts) {\r\n        // Approve the LP tokens for the pair using permit\r\n        _withPermit(\r\n            IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_),\r\n            _liquidity,\r\n            _deadline,\r\n            _approveMax,\r\n            _v,\r\n            _r,\r\n            _s\r\n        );\r\n\r\n        // Remove liquidity for multiple tokens from a pair\r\n        _amounts = removeLiquidity(_tokens, _liquidity, _amountsMin, _to, _deadline);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove liquidity with permit\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _amountsMin The minimum amounts of tokens to receive\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline to remove liquidity by\r\n     * @param _approveMax Whether to approve the maximum amount of liquidity\r\n     * @param _v The v value of the permit signature\r\n     * @param _r The r value of the permit signature\r\n     * @param _s The s value of the permit signature\r\n     * @return _amounts The actual amounts of tokens received\r\n     */\r\n    function removeLiquidityETHWithPermit(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external override returns (uint256[] memory _amounts) {\r\n        // Approve the LP tokens for the pair using permit\r\n        _withPermit(\r\n            IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_),\r\n            _liquidity,\r\n            _deadline,\r\n            _approveMax,\r\n            _v,\r\n            _r,\r\n            _s\r\n        );\r\n\r\n        // Remove liquidity for ETH from a pair\r\n        _amounts = removeLiquidityETH(_tokens, _liquidity, _amountsMin, _to, _deadline);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove liquidity for a single token with permit\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _token The token to receive\r\n     * @param _minAmount The minimum amount of tokens to receive\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline to remove liquidity by\r\n     * @param _approveMax Whether to approve the maximum amount of liquidity\r\n     * @param _v The v value of the permit signature\r\n     * @param _r The r value of the permit signature\r\n     * @param _s The s value of the permit signature\r\n     * @return _tokenAmount The actual amount of tokens received\r\n     */\r\n    function removeLiquidityOneTokenWithPermit(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external override returns (uint256 _tokenAmount) {\r\n        // Approve the LP tokens for the pair using permit\r\n        _withPermit(\r\n            IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_),\r\n            _liquidity,\r\n            _deadline,\r\n            _approveMax,\r\n            _v,\r\n            _r,\r\n            _s\r\n        );\r\n\r\n        // Remove liquidity for a single token from a pair\r\n        _tokenAmount = removeLiquidityOneToken(_tokens, _liquidity, _token, _minAmount, _to, _deadline);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove liquidity for a single token with permit and receive ETH\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _liquidity The amount of liquidity to remove\r\n     * @param _token The token to receive\r\n     * @param _minAmount The minimum amount of tokens to receive\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline to remove liquidity by\r\n     * @param _approveMax Whether to approve the maximum amount of liquidity\r\n     * @param _v The v value of the permit signature\r\n     * @param _r The r value of the permit signature\r\n     * @param _s The s value of the permit signature\r\n     * @return _tokenAmount The actual amount of tokens received\r\n     */\r\n    function removeLiquidityOneTokenETHWithPermit(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external override returns (uint256 _tokenAmount) {\r\n        // Approve the LP tokens for the pair using permit\r\n        _withPermit(\r\n            IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_),\r\n            _liquidity,\r\n            _deadline,\r\n            _approveMax,\r\n            _v,\r\n            _r,\r\n            _s\r\n        );\r\n\r\n        // Remove liquidity for a single token from a pair and receive ETH\r\n        _tokenAmount = removeLiquidityOneTokenETH(_tokens, _liquidity, _token, _minAmount, _to, _deadline);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove liquidity with permit when the amount of tokens to remove is imbalanced\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _amounts The amounts of tokens to remove\r\n     * @param _maxBurnAmount The maximum amount of liquidity to burn\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline to remove liquidity by\r\n     * @param _approveMax Whether to approve the maximum amount of liquidity\r\n     * @param _v The v value of the permit signature\r\n     * @param _r The r value of the permit signature\r\n     * @param _s The s value of the permit signature\r\n     * @return _actualBurnAmount The actual amount of liquidity burned\r\n     */\r\n    function removeLiquidityImbalanceWithPermit(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external override returns (uint256 _actualBurnAmount) {\r\n        // Approve the LP tokens for the pair using permit\r\n        _withPermit(\r\n            IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_),\r\n            _maxBurnAmount,\r\n            _deadline,\r\n            _approveMax,\r\n            _v,\r\n            _r,\r\n            _s\r\n        );\r\n\r\n        // Remove liquidity with imbalanced amounts of tokens from a pair\r\n        _actualBurnAmount = removeLiquidityImbalance(_tokens, _amounts, _maxBurnAmount, _to, _deadline);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove liquidity with permit when the amount of tokens to remove is imbalanced and receive ETH\r\n     * @param _tokens The tokens to remove liquidity for\r\n     * @param _amounts The amounts of tokens to remove\r\n     * @param _maxBurnAmount The maximum amount of liquidity to burn\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline to remove liquidity by\r\n     * @param _approveMax Whether to approve the maximum amount of liquidity\r\n     * @param _v The v value of the permit signature\r\n     * @param _r The r value of the permit signature\r\n     * @param _s The s value of the permit signature\r\n     * @return _actualBurnAmount The actual amount of liquidity burned\r\n     */\r\n    function removeLiquidityImbalanceETHWithPermit(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external override returns (uint256 _actualBurnAmount) {\r\n        // Approve the LP tokens for the pair using permit\r\n        _withPermit(\r\n            IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_),\r\n            _maxBurnAmount,\r\n            _deadline,\r\n            _approveMax,\r\n            _v,\r\n            _r,\r\n            _s\r\n        );\r\n\r\n        // Remove liquidity with imbalanced amounts of tokens from a pair and receive ETH\r\n        _actualBurnAmount = removeLiquidityImbalanceETH(_tokens, _amounts, _maxBurnAmount, _to, _deadline);\r\n    }\r\n\r\n    /**\r\n     * @dev Swap tokens through a route\r\n     * @param _route The route to swap through\r\n     * @param _amountIn The amount of tokens to swap in\r\n     * @param _amountOutMin The minimum amount of tokens to receive\r\n     * @param _to The address to send the tokens to\r\n     * @param _deadline The deadline to swap by\r\n     * @return _amountOut The actual amount of tokens received\r\n     */\r\n    function swap(\r\n        Route memory _route,\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable override returns (uint256 _amountOut) {\r\n        // Ensure that the pair exists\r\n        require(IPairFactory(factory_).isPair(_route.pair), \"StableRouter: is not pair\");\r\n\r\n        // Approve the pair to spend the input token\r\n        _route.from.safeApprove(_route.pair, _amountIn);\r\n\r\n        // Swap the tokens through the route\r\n        _amountOut = IStablePair(_route.pair).swap(_route.from, _route.to, _amountIn, _amountOutMin, _to, _deadline);\r\n    }\r\n}\r\n"
    },
    "contracts/routers/VolatileRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\n\r\nimport \"../utils/TransferHelper.sol\";\r\nimport \"../utils/Math.sol\";\r\n\r\nimport \"../interface/IPairRouter.sol\";\r\nimport \"../interface/IPairFactory.sol\";\r\nimport \"../interface/IPair.sol\";\r\nimport \"../interface/IWETH.sol\";\r\nimport \"../interface/IPairERC20.sol\";\r\n\r\n/**\r\n * @title VolatileRouter\r\n * @notice Router contract for volatile pairs\r\n */\r\n\r\ncontract VolatileRouter is IVolatileRouter {\r\n    using SafeMath for uint256;\r\n    using TransferHelper for address;\r\n\r\n    // Pair type for volatile pairs\r\n    uint8 internal constant PAIR_TYPE_ = 1;\r\n    // Minimum liquidity for volatile pairs\r\n    uint256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\r\n\r\n    // Address of the factory contract\r\n    address internal immutable factory_;\r\n    // Wrapped Ether contract\r\n    IWETH internal immutable weth_;\r\n\r\n    /**\r\n     * @dev Constructor function for VolatileRouter\r\n     * @param _factory Address of the factory contract\r\n     * @param _weth Address of the Wrapped Ether contract\r\n     */\r\n    constructor(address _factory, address _weth) public {\r\n        factory_ = _factory;\r\n        weth_ = IWETH(_weth);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to ensure that the deadline has not passed\r\n     * @param _deadline Deadline timestamp\r\n     */\r\n    modifier ensure(uint256 _deadline) {\r\n        require(_deadline >= block.timestamp, \"VolatileRouter: EXPIRED\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the pair type for volatile pairs\r\n     * @return Pair type\r\n     */\r\n    function PAIR_TYPE() external view override returns (uint8) {\r\n        return PAIR_TYPE_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the factory contract\r\n     * @return Factory contract address\r\n     */\r\n    function factory() external view returns (address) {\r\n        return factory_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the Wrapped Ether contract\r\n     * @return Wrapped Ether contract address\r\n     */\r\n    function weth() external view returns (address) {\r\n        return address(weth_);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the reserves of the given pair and tokens\r\n     * @param _pair Address of the pair contract\r\n     * @param _tokens Array of token addresses\r\n     * @return _reserveA Reserve of token A\r\n     * @return _reserveB Reserve of token B\r\n     */\r\n    function getReserves(\r\n        address _pair,\r\n        address[] memory _tokens\r\n    ) external view override returns (uint256 _reserveA, uint256 _reserveB) {\r\n        (_reserveA, _reserveB) = _getReserves(_pair, _tokens);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the reserves of the given pair and tokens\r\n     * @param _pair Address of the pair contract\r\n     * @param _tokens Array of token addresses\r\n     * @return _reserveA Reserve of token A\r\n     * @return _reserveB Reserve of token B\r\n     */\r\n    function _getReserves(\r\n        address _pair,\r\n        address[] memory _tokens\r\n    ) internal view returns (uint256 _reserveA, uint256 _reserveB) {\r\n        address _token0 = IVolatilePair(_pair).token0();\r\n        (uint112 _reserve0, uint112 _reserve1, ) = IVolatilePair(_pair).getReserves();\r\n        (_reserveA, _reserveB) = _tokens[0] == _token0\r\n            ? (uint256(_reserve0), uint256(_reserve1))\r\n            : (uint256(_reserve1), uint256(_reserve0));\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the optimal amount of token B to add to a pair given an amount of token A\r\n     * @param _amountA Amount of token A to add\r\n     * @param _reserveA Reserve of token A in the pair\r\n     * @param _reserveB Reserve of token B in the pair\r\n     * @return _amountB Amount of token B to add\r\n     */\r\n    function _quoteLiquidity(\r\n        uint256 _amountA,\r\n        uint256 _reserveA,\r\n        uint256 _reserveB\r\n    ) internal pure returns (uint256 _amountB) {\r\n        require(_amountA > 0, \"VolatileRouter: INSUFFICIENT_AMOUNT\");\r\n        require(_reserveA > 0 && _reserveB > 0, \"VolatileRouter: INSUFFICIENT_LIQUIDITY\");\r\n        _amountB = _amountA.mul(_reserveB) / _reserveA;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the optimal amount of token A and token B to add to a pair given desired amounts of each\r\n     * @param _tokens Array of token addresses\r\n     * @param _amountDesireds Array of desired amounts of each token\r\n     * @return _amountsIn Array of amounts of each token to add\r\n     * @return _liquidity Amount of liquidity to add\r\n     */\r\n    function quoteAddLiquidity(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amountDesireds\r\n    ) external view override returns (uint256[] memory _amountsIn, uint256 _liquidity) {\r\n        _amountsIn = new uint256[](_amountDesireds.length);\r\n        // create the pair if it doesn't exist yet\r\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\r\n        if (!IPairFactory(factory_).isPair(_pair)) return (_amountsIn, _liquidity);\r\n\r\n        (uint256 _reserveA, uint256 _reserveB) = (0, 0);\r\n        uint256 _totalSupply = 0;\r\n        if (_pair != address(0)) {\r\n            _totalSupply = IPairERC20(_pair).totalSupply();\r\n            (_reserveA, _reserveB) = _getReserves(_pair, _tokens);\r\n        }\r\n\r\n        if (_reserveA == 0 && _reserveB == 0) {\r\n            _amountsIn = _amountDesireds;\r\n            _liquidity = Math.sqrt(_amountsIn[0].mul(_amountsIn[1])).sub(MINIMUM_LIQUIDITY);\r\n        } else {\r\n            uint256 amountBOptimal = _quoteLiquidity(_amountDesireds[0], _reserveA, _reserveB);\r\n            if (amountBOptimal <= _amountDesireds[1]) {\r\n                (_amountsIn[0], _amountsIn[1]) = (_amountDesireds[0], amountBOptimal);\r\n                _liquidity = Math.min(\r\n                    _amountsIn[0].mul(_totalSupply).div(_reserveA),\r\n                    _amountsIn[1].mul(_totalSupply).div(_reserveB)\r\n                );\r\n            } else {\r\n                uint256 amountAOptimal = _quoteLiquidity(_amountDesireds[1], _reserveB, _reserveA);\r\n                (_amountsIn[0], _amountsIn[1]) = (amountAOptimal, _amountDesireds[1]);\r\n                _liquidity = Math.min(\r\n                    _amountsIn[0].mul(_totalSupply).div(_reserveA),\r\n                    _amountsIn[1].mul(_totalSupply).div(_reserveB)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount of tokens to receive upon removing liquidity from a pair\r\n     * @param _tokens Array of token addresses\r\n     * @param _liquidity Amount of liquidity to remove\r\n     * @return _amounts Array of amounts of each token to receive\r\n     */\r\n    function quoteRemoveLiquidity(\r\n        address[] calldata _tokens,\r\n        uint256 _liquidity\r\n    ) external view override returns (uint256[] memory _amounts) {\r\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\r\n        _amounts = new uint256[](2);\r\n        if (!IPairFactory(factory_).isPair(_pair)) {\r\n            return _amounts;\r\n        }\r\n\r\n        (uint256 _reserveA, uint256 _reserveB) = _getReserves(_pair, _tokens);\r\n        uint256 _totalSupply = IPairERC20(_pair).totalSupply();\r\n        if (_totalSupply > 0) {\r\n            _amounts[0] = _liquidity.mul(_reserveA) / _totalSupply; // calculate the amount of token A to receive\r\n            _amounts[1] = _liquidity.mul(_reserveB) / _totalSupply; // calculate the amount of token B to receive\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Adds liquidity to a pair of tokens\r\n     * @param _tokens Array of token addresses\r\n     * @param _amountDesireds Array of desired amounts of each token\r\n     * @param _amountsMin Array of minimum amounts of each token\r\n     * @return _amountA Amount of token A added to the liquidity pool\r\n     * @return _amountB Amount of token B added to the liquidity pool\r\n     */\r\n    function _addLiquidity(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory _amountsMin\r\n    ) internal returns (uint256 _amountA, uint256 _amountB) {\r\n        require(_amountDesireds[0] >= _amountsMin[0], \"VolatileRouter: token[0] desired invalid\");\r\n        require(_amountDesireds[1] >= _amountsMin[1], \"VolatileRouter: token[1] desired invalid\");\r\n\r\n        // create the pair if it doesn't exist yet\r\n        (uint256 _reserveA, uint256 _reserveB) = (0, 0);\r\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\r\n        if (!IPairFactory(factory_).isPair(_pair)) {\r\n            _pair = IPairFactory(factory_).createPair(_tokens, PAIR_TYPE_, new bytes(0));\r\n        } else {\r\n            (_reserveA, _reserveB) = _getReserves(_pair, _tokens);\r\n        }\r\n\r\n        require(_pair != address(0), \"VolatileRouter: pair does not exist\");\r\n        if (_reserveA == 0 && _reserveB == 0) {\r\n            (_amountA, _amountB) = (_amountDesireds[0], _amountDesireds[1]);\r\n        } else {\r\n            uint256 _amountBOptimal = _quoteLiquidity(_amountDesireds[0], _reserveA, _reserveB);\r\n            if (_amountBOptimal <= _amountDesireds[1]) {\r\n                require(_amountBOptimal >= _amountsMin[1], \"VolatileRouter: INSUFFICIENT_B_AMOUNT\");\r\n                (_amountA, _amountB) = (_amountDesireds[0], _amountBOptimal);\r\n            } else {\r\n                uint256 _amountAOptimal = _quoteLiquidity(_amountDesireds[1], _reserveB, _reserveA);\r\n                assert(_amountAOptimal <= _amountDesireds[0]);\r\n                require(_amountAOptimal >= _amountsMin[0], \"VolatileRouter: INSUFFICIENT_A_AMOUNT\");\r\n                (_amountA, _amountB) = (_amountAOptimal, _amountDesireds[1]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Adds liquidity to a pair of tokens\r\n     * @param _tokens Array of token addresses\r\n     * @param _amountDesireds Array of desired amounts of each token\r\n     * @param _amountsMin Array of minimum amounts of each token\r\n     * @param _minLiquidity Minimum amount of liquidity to mint\r\n     * @param _to Address to receive the minted liquidity\r\n     * @param _deadline Timestamp after which the transaction will revert\r\n     * @return _amounts Amounts of tokens added to the liquidity pool\r\n     * @return _liquidity Amount of liquidity minted\r\n     */\r\n    function addLiquidity(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory _amountsMin,\r\n        uint256 _minLiquidity,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external override ensure(_deadline) returns (uint256[] memory _amounts, uint256 _liquidity) {\r\n        _amounts = _amountDesireds;\r\n        (_amounts[0], _amounts[1]) = _addLiquidity(_tokens, _amountDesireds, _amountsMin);\r\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            // Transfer tokens from sender to pair\r\n            _tokens[i].safeTransferFrom(msg.sender, _pair, _amounts[i]);\r\n        }\r\n        // Mint liquidity and transfer to recipient\r\n        _liquidity = IVolatilePair(_pair).mint(_to);\r\n        require(_liquidity >= _minLiquidity, \"VolatileRouter: Couldn't mint min requested\");\r\n    }\r\n\r\n    /**\r\n     * @dev Adds liquidity to a pair of tokens\r\n     * @param _tokens Array of token addresses\r\n     * @param _amountDesireds Array of desired amounts of each token\r\n     * @param _amountsMin Array of minimum amounts of each token\r\n     * @param _minLiquidity Minimum amount of liquidity to mint\r\n     * @param _to Address to receive the minted liquidity\r\n     * @param _deadline Timestamp after which the transaction will revert\r\n     * @return _amounts Amounts of tokens added to the liquidity pool\r\n     * @return _liquidity Amount of liquidity minted\r\n     */\r\n    function addLiquidityETH(\r\n        address[] memory _tokens,\r\n        uint256[] memory _amountDesireds,\r\n        uint256[] memory _amountsMin,\r\n        uint256 _minLiquidity,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable override ensure(_deadline) returns (uint256[] memory _amounts, uint256 _liquidity) {\r\n        _amounts = _amountDesireds;\r\n        (_amounts[0], _amounts[1]) = _addLiquidity(_tokens, _amountDesireds, _amountsMin);\r\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\r\n        uint256 _amountETH;\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            if (_tokens[i] == address(weth_)) {\r\n                _amountETH = _amounts[i];\r\n                weth_.deposit{ value: _amounts[i] }();\r\n                assert(weth_.transfer(_pair, _amounts[i]));\r\n                continue;\r\n            }\r\n\r\n            _tokens[i].safeTransferFrom(msg.sender, _pair, _amounts[i]);\r\n        }\r\n        _liquidity = IVolatilePair(_pair).mint(_to);\r\n        require(_liquidity >= _minLiquidity, \"VolatileRouter: Couldn't mint min requested\");\r\n\r\n        if (msg.value > _amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - _amountETH);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity from a pair of tokens\r\n     * @param _tokens Array of token addresses\r\n     * @param _liquidity Amount of liquidity to remove\r\n     * @param _amountsMin Array of minimum amounts of each token to receive\r\n     * @param _to Address to receive the tokens\r\n     * @return _amounts Amounts of tokens received\r\n     */\r\n    function _removeLiquidity(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to\r\n    ) internal returns (uint256[] memory _amounts) {\r\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\r\n        require(IPairFactory(factory_).isPair(_pair), \"VolatileRouter: is not pair\");\r\n\r\n        IPairERC20(_pair).transferFrom(msg.sender, _pair, _liquidity);\r\n        (uint256 _amount0, uint256 _amount1) = IVolatilePair(_pair).burn(_to);\r\n\r\n        address _token0 = IVolatilePair(_pair).token0();\r\n        _amounts = new uint256[](_amountsMin.length);\r\n        (_amounts[0], _amounts[1]) = _token0 == _tokens[0] ? (_amount0, _amount1) : (_amount1, _amount0);\r\n\r\n        for (uint256 i = 0; i < _amounts.length; i++) {\r\n            require(_amounts[i] >= _amountsMin[i], \"VolatileRouter: _amount < _amountsMin\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity from a pair of tokens\r\n     * @param _tokens Array of token addresses\r\n     * @param _liquidity Amount of liquidity to remove\r\n     * @param _amountsMin Array of minimum amounts of each token to receive\r\n     * @param _to Address to receive the tokens\r\n     * @param _deadline Timestamp after which the transaction will revert\r\n     * @return _amounts Amounts of tokens received\r\n     */\r\n    function removeLiquidity(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public override ensure(_deadline) returns (uint256[] memory _amounts) {\r\n        _amounts = _removeLiquidity(_tokens, _liquidity, _amountsMin, _to);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity from a pair of tokens with ETH\r\n     * @param _tokens Array of token addresses\r\n     * @param _liquidity Amount of liquidity to remove\r\n     * @param _amountsMin Array of minimum amounts of each token to receive\r\n     * @param _to Address to receive the tokens\r\n     * @param _deadline Timestamp after which the transaction will revert\r\n     * @return _amounts Amounts of tokens received\r\n     */\r\n    function removeLiquidityETH(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public override ensure(_deadline) returns (uint256[] memory _amounts) {\r\n        _amounts = _removeLiquidity(_tokens, _liquidity, _amountsMin, address(this));\r\n        uint256 _amountETH;\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            if (_tokens[i] == address(weth_)) {\r\n                _amountETH = _amounts[i];\r\n                weth_.withdraw(_amountETH);\r\n                // _to.safeTransferETH(_amounts[i]);\r\n                continue;\r\n            }\r\n            _tokens[i].safeTransfer(_to, _amounts[i]);\r\n        }\r\n        _to.safeTransferETH(_amountETH);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds permit functionality to removeLiquidity and removeLiquidityETH functions\r\n     * @param _pair Address of the pair\r\n     * @param _liquidity Amount of liquidity to remove\r\n     * @param _deadline Timestamp after which the transaction will revert\r\n     * @param _approveMax Whether to approve the maximum amount or not\r\n     * @param _v ECDSA signature parameter v\r\n     * @param _r ECDSA signature parameter r\r\n     * @param _s ECDSA signature parameter s\r\n     */\r\n    function _withPermit(\r\n        address _pair,\r\n        uint256 _liquidity,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) internal {\r\n        uint256 _value = _approveMax ? uint256(-1) : _liquidity;\r\n        IPairERC20(_pair).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity from a pair of tokens with permit functionality\r\n     * @param _tokens Array of token addresses\r\n     * @param _liquidity Amount of liquidity to remove\r\n     * @param _amountMin Array of minimum amounts of each token to receive\r\n     * @param _to Address to receive the tokens\r\n     * @param _deadline Timestamp after which the transaction will revert\r\n     * @param _approveMax Whether to approve the maximum amount or not\r\n     * @param _v ECDSA signature parameter v\r\n     * @param _r ECDSA signature parameter r\r\n     * @param _s ECDSA signature parameter s\r\n     * @return _amounts Amounts of tokens received\r\n     */\r\n    function removeLiquidityWithPermit(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external override returns (uint256[] memory _amounts) {\r\n        _withPermit(\r\n            IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_),\r\n            _liquidity,\r\n            _deadline,\r\n            _approveMax,\r\n            _v,\r\n            _r,\r\n            _s\r\n        );\r\n        _amounts = removeLiquidity(_tokens, _liquidity, _amountMin, _to, _deadline);\r\n        return _amounts;\r\n    }\r\n\r\n    /**\r\n     * @dev Removes liquidity from a pair of tokens with ETH and permit functionality\r\n     * @param _tokens Array of token addresses\r\n     * @param _liquidity Amount of liquidity to remove\r\n     * @param _amountsMin Array of minimum amounts of each token to receive\r\n     * @param _to Address to receive the tokens\r\n     * @param _deadline Timestamp after which the transaction will revert\r\n     * @param _approveMax Whether to approve the maximum amount or not\r\n     * @param _v ECDSA signature parameter v\r\n     * @param _r ECDSA signature parameter r\r\n     * @param _s ECDSA signature parameter s\r\n     * @return _amounts Amounts of tokens received\r\n     */\r\n    function removeLiquidityETHWithPermit(\r\n        address[] memory _tokens,\r\n        uint256 _liquidity,\r\n        uint256[] memory _amountsMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external override returns (uint256[] memory _amounts) {\r\n        _withPermit(\r\n            IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_),\r\n            _liquidity,\r\n            _deadline,\r\n            _approveMax,\r\n            _v,\r\n            _r,\r\n            _s\r\n        );\r\n        _amounts = removeLiquidityETH(_tokens, _liquidity, _amountsMin, _to, _deadline);\r\n        return _amounts;\r\n    }\r\n\r\n    /**\r\n     * @dev Swaps tokens according to the given route\r\n     * @param _route Route containing the pair and the token to swap from\r\n     * @param _amountIn Amount of tokens to swap\r\n     * @param _amountOut Expected amount of tokens to receive\r\n     * @param _to Address to receive the swapped tokens\r\n     */\r\n    function _swap(Route memory _route, uint256 _amountIn, uint256 _amountOut, address _to) internal {\r\n        require(IPairFactory(factory_).isPair(_route.pair), \"VolatileRouter: is not pair\");\r\n        address _token0 = IVolatilePair(_route.pair).token0();\r\n        (uint256 _amount0Out, uint256 _amount1Out) = _route.from == _token0\r\n            ? (uint256(0), _amountOut)\r\n            : (_amountOut, uint256(0));\r\n\r\n        _route.from.safeTransfer(_route.pair, _amountIn);\r\n\r\n        IVolatilePair(_route.pair).swap(_amount0Out, _amount1Out, _to, new bytes(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Swaps tokens according to the given route\r\n     * @param _route Route containing the pair and the token to swap from\r\n     * @param _amountIn Amount of tokens to swap\r\n     * @param _amountOut Expected amount of tokens to receive\r\n     * @param _to Address to receive the swapped tokens\r\n     * @param _deadline Timestamp after which the transaction will revert\r\n     * @return Amount of tokens received\r\n     */\r\n    function swap(\r\n        Route memory _route,\r\n        uint256 _amountIn,\r\n        uint256 _amountOut,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable override ensure(_deadline) returns (uint256) {\r\n        _swap(_route, _amountIn, _amountOut, _to);\r\n\r\n        return _amountOut;\r\n    }\r\n}\r\n"
    },
    "contracts/StablePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\nimport \"./utils/SwapUtils.sol\";\r\nimport \"./utils/AmplificationUtils.sol\";\r\nimport \"./utils/ERC20Call.sol\";\r\nimport \"./interface/IPairERC20.sol\";\r\nimport \"./interface/IPairFactory.sol\";\r\nimport \"./interface/IPair.sol\";\r\n\r\n/**\r\n * @title Swap - A StableSwap implementation in solidity.\r\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\r\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\r\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\r\n * Users can burn pool tokens and withdraw their share of token(s).\r\n *\r\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\r\n * distributed to the LPs.\r\n *\r\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\r\n * stops the ratio of the tokens in the pool from changing.\r\n * Users can always withdraw their tokens via multi-asset withdraws.\r\n *\r\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\r\n * deployment size.\r\n */\r\ncontract StablePair is Initializable, IStablePair {\r\n    using SwapUtils for SwapUtils.Swap;\r\n    using AmplificationUtils for SwapUtils.Swap;\r\n    using ERC20Call for address;\r\n\r\n    // The type of the pair\r\n    uint8 public constant override PAIR_TYPE = 2;\r\n    // Whether the pair is authorized\r\n    bool public constant override AUTH = true;\r\n\r\n    // The factory that created this pair\r\n    address public factory;\r\n\r\n    // A lock to prevent reentrancy\r\n    uint256 private unlocked_;\r\n\r\n    // Struct storing data responsible for automatic market maker functionalities. In order to\r\n    // access this data, this contract uses SwapUtils library. For more details, see SwapUtils.sol\r\n    SwapUtils.Swap public swapStorage;\r\n\r\n    // Maps token address to an index in the pool. Used to prevent duplicate tokens in the pool.\r\n    // getTokenIndex function also relies on this mapping to retrieve token index.\r\n    mapping(address => uint8) internal tokenIndexes_;\r\n\r\n    /*** EVENTS ***/\r\n\r\n    // events replicated from SwapUtils to make the ABI easier for dumb\r\n    // clients\r\n    /**\r\n     * @dev Event emitted when a token swap occurs.\r\n     * @param buyer The address of the buyer.\r\n     * @param tokensSold The amount of tokens sold.\r\n     * @param tokensBought The amount of tokens bought.\r\n     * @param soldId The ID of the sold token.\r\n     * @param boughtId The ID of the bought token.\r\n     */\r\n    event TokenSwap(address indexed buyer, uint256 tokensSold, uint256 tokensBought, uint128 soldId, uint128 boughtId);\r\n\r\n    /**\r\n     * @dev Event emitted when liquidity is added to the pool.\r\n     * @param provider The address of the liquidity provider.\r\n     * @param tokenAmounts The amounts of tokens added.\r\n     * @param fees The fees paid for adding liquidity.\r\n     * @param invariant The invariant of the pool.\r\n     * @param lpTokenSupply The total supply of LP tokens.\r\n     */\r\n    event AddLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n\r\n    /**\r\n     * @dev Event emitted when liquidity is removed from the pool.\r\n     * @param provider The address of the liquidity provider.\r\n     * @param tokenAmounts The amounts of tokens removed.\r\n     * @param lpTokenSupply The total supply of LP tokens.\r\n     */\r\n    event RemoveLiquidity(address indexed provider, uint256[] tokenAmounts, uint256 lpTokenSupply);\r\n\r\n    /**\r\n     * @dev Event emitted when a single asset is removed from the pool.\r\n     * @param provider The address of the liquidity provider.\r\n     * @param lpTokenAmount The amount of LP tokens burned.\r\n     * @param lpTokenSupply The total supply of LP tokens.\r\n     * @param boughtId The ID of the bought token.\r\n     * @param tokensBought The amount of tokens bought.\r\n     */\r\n    event RemoveLiquidityOne(\r\n        address indexed provider,\r\n        uint256 lpTokenAmount,\r\n        uint256 lpTokenSupply,\r\n        uint256 boughtId,\r\n        uint256 tokensBought\r\n    );\r\n\r\n    /**\r\n     * @dev Event emitted when liquidity is removed from the pool in an imbalanced way.\r\n     * @param provider The address of the liquidity provider.\r\n     * @param tokenAmounts The amounts of tokens removed.\r\n     * @param fees The fees paid for removing liquidity.\r\n     * @param invariant The invariant of the pool.\r\n     * @param lpTokenSupply The total supply of LP tokens.\r\n     */\r\n    event RemoveLiquidityImbalance(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n\r\n    /**\r\n     * @dev Event emitted when the swap fees are updated.\r\n     * @param tokens The tokens in the pool.\r\n     * @param swapFees The new swap fees.\r\n     */\r\n    event SwapFee(address[] tokens, uint256[] swapFees);\r\n\r\n    /**\r\n     * @dev Event emitted when the admin fee is updated.\r\n     * @param newAdminFee The new admin fee.\r\n     */\r\n    event NewAdminFee(uint256 newAdminFee);\r\n\r\n    /**\r\n     * @dev Event emitted when the swap fee is updated.\r\n     * @param newSwapFee The new swap fee.\r\n     */\r\n    event NewSwapFee(uint256 newSwapFee);\r\n\r\n    /**\r\n     * @dev Event emitted when the withdraw fee is updated.\r\n     * @param newWithdrawFee The new withdraw fee.\r\n     */\r\n    event NewWithdrawFee(uint256 newWithdrawFee);\r\n\r\n    /**\r\n     * @dev Event emitted when the amplification coefficient is ramped.\r\n     * @param oldA The old amplification coefficient.\r\n     * @param newA The new amplification coefficient.\r\n     * @param initialTime The initial time.\r\n     * @param futureTime The future time.\r\n     */\r\n    event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\r\n\r\n    /**\r\n     * @dev Event emitted when the amplification coefficient ramp is stopped.\r\n     * @param currentA The current amplification coefficient.\r\n     * @param time The time.\r\n     */\r\n    event StopRampA(uint256 currentA, uint256 time);\r\n\r\n    /**\r\n     * @dev Initializes this StablePair contract with the given parameters.\r\n     * @param _tokens an array of ERC20s this pool will accept\r\n     * @param _data encoded parameters for the StablePair contract\r\n     */\r\n    function initialize(address[] calldata _tokens, bytes calldata _data) external override initializer {\r\n        factory = msg.sender;\r\n        unlocked_ = 1;\r\n        string memory _lpTokenName = \"dForce AMM Stable - \";\r\n        string memory _lpTokenSymbol = \"sAMM-\";\r\n        string memory _separator = \"-\";\r\n        uint8[] memory _decimals = new uint8[](_tokens.length);\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            _decimals[i] = IPairERC20(_tokens[i]).decimals();\r\n            string memory _tokenSymbol = _tokens[i].callSymbol();\r\n            if (i == _tokens.length - 1) _separator = \"\";\r\n            _lpTokenName = string(abi.encodePacked(_lpTokenName, _tokenSymbol, _separator));\r\n            _lpTokenSymbol = string(abi.encodePacked(_lpTokenSymbol, _tokenSymbol, _separator));\r\n        }\r\n\r\n        (uint256 _swapFee, uint256 _adminFeeRate, uint256 _a, address _lpTokenTargetAddress) = abi.decode(\r\n            _data,\r\n            (uint256, uint256, uint256, address)\r\n        );\r\n        __SwapV2_init(\r\n            _tokens,\r\n            _decimals,\r\n            _lpTokenName,\r\n            _lpTokenSymbol,\r\n            _a,\r\n            _swapFee,\r\n            _adminFeeRate,\r\n            _lpTokenTargetAddress\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Initializes this Swap contract with the given parameters.\r\n     * This will also clone a LPToken contract that represents users'\r\n     * LP positions. The owner of LPToken will be this contract - which means\r\n     * only this contract is allowed to mint/burn tokens.\r\n     *\r\n     * @param _pooledTokens an array of ERC20s this pool will accept\r\n     * @param _decimals the decimals to use for each pooled token,\r\n     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\r\n     * @param _lpTokenName the long-form name of the token to be deployed\r\n     * @param _lpTokenSymbol the short symbol for the token to be deployed\r\n     * @param _a the amplification coefficient * n * (n - 1). See the\r\n     * StableSwap paper for details\r\n     * @param _fee default swap fee to be initialized with\r\n     * @param _adminFee default adminFee to be initialized with\r\n     * @param _lpTokenTargetAddress the address of an existing LPToken contract to use as a target\r\n     */\r\n    function __SwapV2_init(\r\n        address[] memory _pooledTokens,\r\n        uint8[] memory _decimals,\r\n        string memory _lpTokenName,\r\n        string memory _lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        address _lpTokenTargetAddress\r\n    ) internal virtual {\r\n        // Check _pooledTokens and precisions parameter\r\n        require(_pooledTokens.length > 1, \"StablePair: _pooledTokens.length <= 1\");\r\n        require(_pooledTokens.length <= 32, \"StablePair: _pooledTokens.length > 32\");\r\n        require(_pooledTokens.length == _decimals.length, \"StablePair: _pooledTokens decimals mismatch\");\r\n\r\n        uint256[] memory _precisionMultipliers = new uint256[](_decimals.length);\r\n        IERC20[] memory _poolTokens = new IERC20[](_decimals.length);\r\n\r\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\r\n            if (i > 0) {\r\n                // Check if index is already used. Check if 0th element is a duplicate.\r\n                require(\r\n                    tokenIndexes_[_pooledTokens[i]] == 0 && _pooledTokens[0] != _pooledTokens[i],\r\n                    \"StablePair: Duplicate tokens\"\r\n                );\r\n            }\r\n            require(\r\n                _pooledTokens[i] != address(0) && _pooledTokens[i] != address(this),\r\n                \"StablePair: The 0 address isn't an ERC-20\"\r\n            );\r\n            require(_decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS, \"StablePair: Token decimals exceeds max\");\r\n            _precisionMultipliers[i] = 10 ** (uint256(SwapUtils.POOL_PRECISION_DECIMALS) - uint256(_decimals[i]));\r\n            _poolTokens[i] = IERC20(_pooledTokens[i]);\r\n            tokenIndexes_[_pooledTokens[i]] = i;\r\n        }\r\n\r\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\r\n        require(_a < AmplificationUtils.MAX_A, \"StablePair: _a exceeds maximum\");\r\n        require(_fee < SwapUtils.MAX_SWAP_FEE, \"StablePair: _fee exceeds maximum\");\r\n        require(_adminFee < SwapUtils.MAX_ADMIN_FEE, \"StablePair: _adminFee exceeds maximum\");\r\n\r\n        // Clone and initialize a LPToken contract\r\n        LPToken _lpToken = LPToken(Clones.clone(_lpTokenTargetAddress));\r\n        require(_lpToken.initialize(_lpTokenName, _lpTokenSymbol), \"StablePair: could not init lpToken clone\");\r\n\r\n        // Initialize swapStorage struct\r\n        swapStorage.lpToken = _lpToken;\r\n        swapStorage.pooledTokens = _poolTokens;\r\n        swapStorage.tokenPrecisionMultipliers = _precisionMultipliers;\r\n        swapStorage.balances = new uint256[](_pooledTokens.length);\r\n        swapStorage.initialA = _a * AmplificationUtils.A_PRECISION;\r\n        swapStorage.futureA = _a * AmplificationUtils.A_PRECISION;\r\n        // swapStorage.initialATime = 0;\r\n        // swapStorage.futureATime = 0;\r\n        swapStorage.swapFee = _fee;\r\n        swapStorage.adminFee = _adminFee;\r\n    }\r\n\r\n    /*** MODIFIERS ***/\r\n\r\n    /**\r\n     * @notice Modifier to check sender against factory manager.\r\n     */\r\n    modifier onlyManager() {\r\n        require(IPairFactory(factory).manager() == msg.sender, \"StablePair: : not manager\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice contract function lock modifier.\r\n     */\r\n    modifier lock() {\r\n        require(unlocked_ == 1, \"StablePair: LOCKED\");\r\n        unlocked_ = 0;\r\n        _;\r\n        unlocked_ = 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Modifier to check _deadline against current timestamp\r\n     * @param _deadline latest timestamp to accept this transaction\r\n     */\r\n    modifier deadlineCheck(uint256 _deadline) {\r\n        require(block.timestamp <= _deadline, \"StablePair: Deadline not met\");\r\n        _;\r\n    }\r\n\r\n    /*** VIEW FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Return A, the amplification coefficient * n * (n - 1)\r\n     * @dev See the StableSwap paper for details\r\n     * @return A parameter\r\n     */\r\n    function getA() external view virtual returns (uint256) {\r\n        return swapStorage.getA();\r\n    }\r\n\r\n    /**\r\n     * @notice Return A in its raw precision form\r\n     * @dev See the StableSwap paper for details\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function getAPrecise() external view virtual returns (uint256) {\r\n        return swapStorage.getAPrecise();\r\n    }\r\n\r\n    /**\r\n     * @notice Return address of the pooled token at given index. Reverts if _tokenIndex is out of range.\r\n     * @param _index the index of the token\r\n     * @return address of the token at given index\r\n     */\r\n    function getToken(uint8 _index) public view virtual returns (address) {\r\n        require(_index < swapStorage.pooledTokens.length, \"StablePair: Out of range\");\r\n        return address(swapStorage.pooledTokens[_index]);\r\n    }\r\n\r\n    /**\r\n     * @notice Query all token addresses in pair.\r\n     * @return _tokens all token addresses\r\n     */\r\n    function tokens() external view override returns (address[] memory _tokens) {\r\n        _tokens = new address[](swapStorage.pooledTokens.length);\r\n        for (uint256 i = 0; i < _tokens.length; i++) _tokens[i] = address(swapStorage.pooledTokens[i]);\r\n    }\r\n\r\n    /**\r\n     * @notice Query lpToken addresse.\r\n     * @return lpToken addresse\r\n     */\r\n    function lpToken() external view override returns (address) {\r\n        return address(swapStorage.lpToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Return the index of the given token address. Reverts if no matching\r\n     * token is found.\r\n     * @param _tokenAddress address of the token\r\n     * @return the index of the given token address\r\n     */\r\n    function getTokenIndex(address _tokenAddress) public view virtual returns (uint8) {\r\n        uint8 _index = tokenIndexes_[_tokenAddress];\r\n        require(getToken(_index) == _tokenAddress, \"StablePair: Token does not exist\");\r\n        return _index;\r\n    }\r\n\r\n    /**\r\n     * @notice Return current balance of the pooled token at given index\r\n     * @param _index the index of the token\r\n     * @return current balance of the pooled token at given index with token's native precision\r\n     */\r\n    function getTokenBalance(uint8 _index) external view virtual returns (uint256) {\r\n        require(_index < swapStorage.pooledTokens.length, \"StablePair: Index out of range\");\r\n        return swapStorage.balances[_index];\r\n    }\r\n\r\n    /**\r\n     * @notice Return current balances of the pooled tokens\r\n     * @return current balances of the pooled tokens\r\n     */\r\n    function getTokenBalances() external view virtual returns (uint256[] memory) {\r\n        return swapStorage.balances;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the virtual price, to help calculate profit\r\n     * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\r\n     */\r\n    function getVirtualPrice() external view virtual returns (uint256) {\r\n        return swapStorage.getVirtualPrice();\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate amount of tokens you receive on swap\r\n     * @param _tokenFrom the token address the user wants to sell\r\n     * @param _tokenTo the token address the user wants to buy\r\n     * @param _dx the amount of tokens the user wants to sell. If the token charges\r\n     * a fee on transfers, use the amount that gets transferred after the fee.\r\n     * @return amount of tokens the user will receive\r\n     */\r\n    function getAmountOut(address _tokenFrom, address _tokenTo, uint256 _dx) external view override returns (uint256) {\r\n        return swapStorage.calculateSwap(tokenIndexes_[_tokenFrom], tokenIndexes_[_tokenTo], _dx);\r\n    }\r\n\r\n    /**\r\n     * @notice Convert the array index, according to tokenIndexes_.\r\n     * @param _tokens an array of all token addresses for the pair,\r\n     * @param _amounts an array of token amounts, corresponding to param _tokens.\r\n     * @return _newAmounts amount of tokens after conversion\r\n     */\r\n    function _convertIndex(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts\r\n    ) internal view returns (uint256[] memory _newAmounts) {\r\n        _newAmounts = new uint256[](_amounts.length);\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            _newAmounts[getTokenIndex(_tokens[i])] = _amounts[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate prices from deposits or\r\n     * withdrawals, excluding fees but including slippage. This is\r\n     * helpful as an input into the various \"min\" parameters on calls\r\n     * to fight front-running\r\n     *\r\n     * @dev This shouldn't be used outside frontends for user estimates.\r\n     *\r\n     * @param _tokens an array of all token addresses for the pair,\r\n     * @param _amounts an array of token amounts to deposit or withdrawal,\r\n     * corresponding to param _tokens. The amount should be in each\r\n     * pooled token's native precision. If a token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @param _deposit whether this is a deposit or a withdrawal\r\n     * @return token amount the user will receive\r\n     */\r\n    function calculateTokenAmount(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts,\r\n        bool _deposit\r\n    ) external view virtual override returns (uint256) {\r\n        return swapStorage.calculateTokenAmount(_convertIndex(_tokens, _amounts), _deposit);\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate amount of each underlying\r\n     * tokens that is returned upon burning given amount of LP tokens\r\n     * @param _tokens token address list\r\n     * @param _amount the amount of LP tokens that would be burned on withdrawal\r\n     * @return array of token balances that the user will receive\r\n     */\r\n    function calculateRemoveLiquidity(\r\n        address[] calldata _tokens,\r\n        uint256 _amount\r\n    ) external view virtual override returns (uint256[] memory) {\r\n        uint256[] memory _amounts = swapStorage.calculateRemoveLiquidity(_amount);\r\n        uint256[] memory _actualAmounts = new uint256[](_amounts.length);\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            _actualAmounts[i] = _amounts[getTokenIndex(_tokens[i])];\r\n        }\r\n        return _actualAmounts;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the amount of underlying token available to withdraw\r\n     * when withdrawing via only single token\r\n     * @param _token address of tokens that will be withdrawn\r\n     * @param _tokenAmount the amount of LP token to burn\r\n     * @return calculated amount of underlying token\r\n     * available to withdraw\r\n     */\r\n    function calculateRemoveLiquidityOneToken(\r\n        address _token,\r\n        uint256 _tokenAmount\r\n    ) external view virtual override returns (uint256) {\r\n        return swapStorage.calculateWithdrawOneToken(_tokenAmount, tokenIndexes_[_token]);\r\n    }\r\n\r\n    /**\r\n     * @notice This function reads the accumulated amount of admin fees of the token with given index\r\n     * @param _index Index of the pooled token\r\n     * @return admin's token balance in the token's precision\r\n     */\r\n    function getAdminBalance(uint256 _index) external view virtual returns (uint256) {\r\n        return swapStorage.getAdminBalance(_index);\r\n    }\r\n\r\n    /*** STATE MODIFYING FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Calculate amount of tokens you receive on swap\r\n     * @param _tokenFrom the token address the user wants to sell\r\n     * @param _tokenTo the token address the user wants to buy\r\n     * @param _dx the amount of tokens the user wants to swap from\r\n     * @param _minDy the min amount the user would like to receive, or revert.\r\n     * @param _receiver recipient address\r\n     * @param _deadline latest timestamp to accept this transaction\r\n     */\r\n    function swap(\r\n        address _tokenFrom,\r\n        address _tokenTo,\r\n        uint256 _dx,\r\n        uint256 _minDy,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external override lock deadlineCheck(_deadline) returns (uint256) {\r\n        return swapStorage.swap(tokenIndexes_[_tokenFrom], tokenIndexes_[_tokenTo], _dx, _minDy, _receiver);\r\n    }\r\n\r\n    /**\r\n     * @notice Add liquidity to the pool with the given amounts of tokens\r\n     * @param _tokens token address list\r\n     * @param _amounts the amounts of each token to add, in their native precision,corresponding to param _tokens\r\n     * @param _minToMint the minimum LP tokens adding this amount of liquidity\r\n     * should mint, otherwise revert. Handy for front-running mitigation\r\n     * @param _receiver recipient address\r\n     * @param _deadline latest timestamp to accept this transaction\r\n     * @return amount of LP token user minted and received\r\n     */\r\n    function addLiquidity(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts,\r\n        uint256 _minToMint,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external override lock deadlineCheck(_deadline) returns (uint256) {\r\n        return swapStorage.addLiquidity(_convertIndex(_tokens, _amounts), _minToMint, _receiver);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @dev Liquidity can always be removed, even when the pool is paused.\r\n     * @param _amount the amount of LP tokens to burn\r\n     * @param _tokens token address list\r\n     * @param _minAmounts the minimum amounts of each token in the pool\r\n     *        acceptable for this burn. Useful as a front-running mitigation\r\n     * @param _receiver recipient address\r\n     * @param _deadline latest timestamp to accept this transaction\r\n     * @return amounts of tokens user received\r\n     */\r\n    function removeLiquidity(\r\n        uint256 _amount,\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _minAmounts,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external virtual override lock deadlineCheck(_deadline) returns (uint256[] memory) {\r\n        return swapStorage.removeLiquidity(_amount, _convertIndex(_tokens, _minAmounts), _receiver);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @param _tokenAmount the amount of the token you want to receive\r\n     * @param _token address of the token you want to receive\r\n     * @param _minAmount the minimum amount to withdraw, otherwise revert\r\n     * @param _receiver recipient address\r\n     * @param _deadline latest timestamp to accept this transaction\r\n     * @return amount of chosen token user received\r\n     */\r\n    function removeLiquidityOneToken(\r\n        uint256 _tokenAmount,\r\n        address _token,\r\n        uint256 _minAmount,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external override lock deadlineCheck(_deadline) returns (uint256) {\r\n        return swapStorage.removeLiquidityOneToken(_tokenAmount, tokenIndexes_[_token], _minAmount, _receiver);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool, weighted differently than the\r\n     * pool's current balances. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @param _tokens token address list\r\n     * @param _amounts how much of each token to withdraw\r\n     * @param _maxBurnAmount the max LP token provider is willing to pay to\r\n     * remove liquidity. Useful as a front-running mitigation.\r\n     * @param _receiver recipient address\r\n     * @param _deadline latest timestamp to accept this transaction\r\n     * @return amount of LP tokens burned\r\n     */\r\n    function removeLiquidityImbalance(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts,\r\n        uint256 _maxBurnAmount,\r\n        address _receiver,\r\n        uint256 _deadline\r\n    ) external override lock deadlineCheck(_deadline) returns (uint256) {\r\n        return swapStorage.removeLiquidityImbalance(_convertIndex(_tokens, _amounts), _maxBurnAmount, _receiver);\r\n    }\r\n\r\n    /*** ADMIN FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Withdraw all admin fees to the contract factory manager\r\n     */\r\n    function claimFees() external returns (uint256[] memory) {\r\n        return swapStorage.withdrawAdminFees(IPairFactory(factory).manager());\r\n    }\r\n\r\n    /**\r\n     * @notice Update the admin fee. Admin fee takes portion of the swap fee.\r\n     * @param _newAdminFee new admin fee to be applied on future transactions\r\n     */\r\n    function setAdminFeeRate(uint256 _newAdminFee) external onlyManager {\r\n        swapStorage.setAdminFee(_newAdminFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the swap fee to be applied on swaps\r\n     * @param _newSwapFee new swap fee to be applied on future transactions\r\n     */\r\n    function setSwapFee(uint256 _newSwapFee) external onlyManager {\r\n        swapStorage.setSwapFee(_newSwapFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Start ramping up or down A parameter towards given futureA and futureTime\r\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\r\n     * the limit range.\r\n     * @param _futureA the new A to ramp towards\r\n     * @param _futureTime timestamp when the new A should be reached\r\n     */\r\n    function rampA(uint256 _futureA, uint256 _futureTime) external onlyManager {\r\n        swapStorage.rampA(_futureA, _futureTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\r\n     */\r\n    function stopRampA() external onlyManager {\r\n        swapStorage.stopRampA();\r\n    }\r\n}\r\n"
    },
    "contracts/test/Create2Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"../VolatilePair.sol\";\r\n\r\ncontract Create2Test {\r\n    function getCreate2Address(\r\n        address _factory,\r\n        address[] memory _tokens,\r\n        bool _stable,\r\n        uint256 _fee\r\n    ) public pure returns (address) {\r\n        bytes32 salt = keccak256(abi.encodePacked(_tokens, _stable, _fee));\r\n\r\n        return\r\n            address(\r\n                uint160(\r\n                    uint256(\r\n                        keccak256(\r\n                            abi.encodePacked(\r\n                                bytes1(0xff),\r\n                                _factory,\r\n                                salt,\r\n                                keccak256(abi.encodePacked(type(VolatilePair).creationCode))\r\n                            )\r\n                        )\r\n                    )\r\n                )\r\n            );\r\n    }\r\n}\r\n"
    },
    "contracts/test/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 {\r\n    using SafeMathUpgradeable for uint256;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n    uint256 public totalSupply;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    function __ERC20_init(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        uint8 decimals_\r\n    ) internal {\r\n        name = name_;\r\n        symbol = symbol_;\r\n        decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, allowance[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            msg.sender,\r\n            spender,\r\n            allowance[msg.sender][spender].add(addedValue)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            msg.sender,\r\n            spender,\r\n            allowance[msg.sender][spender].sub(subtractedValue)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        balanceOf[sender] = balanceOf[sender].sub(amount);\r\n        balanceOf[recipient] = balanceOf[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        totalSupply = totalSupply.add(amount);\r\n        balanceOf[account] = balanceOf[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        balanceOf[account] = balanceOf[account].sub(amount);\r\n        totalSupply = totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\r\n     * allowance if caller is not the `account`.\r\n     *\r\n     * See {ERC20-_burn} and {ERC20-allowance}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller other than `msg.sender` must have allowance for ``accounts``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal virtual {\r\n        if (msg.sender != account)\r\n            _approve(\r\n                account,\r\n                msg.sender,\r\n                allowance[account][msg.sender].sub(amount)\r\n            );\r\n\r\n        _burn(account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        allowance[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    uint256[50] private __gap;\r\n}\r\n"
    },
    "contracts/test/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract MockERC20 is ERC20 {\r\n    constructor(string memory name_, string memory symbol_) public ERC20(name_, symbol_) {}\r\n\r\n    function allocateTo(address _usr, uint256 _value) public {\r\n        _mint(_usr, _value);\r\n    }\r\n}\r\n"
    },
    "contracts/test/MockRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"../interface/IPairCallee.sol\";\r\nimport \"../interface/IPair.sol\";\r\nimport \"../interface/IPairFactory.sol\";\r\nimport \"../interface/IPairERC20.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract MockRouter is IPairCallee {\r\n    address private immutable factory;\r\n\r\n    constructor(address _factory) public {\r\n        factory = _factory;\r\n    }\r\n\r\n    function callSwap(\r\n        address _pair,\r\n        bool _order,\r\n        uint256 _amount,\r\n        bytes memory _data\r\n    ) external {\r\n        address _token0 = IVolatilePair(_pair).token0();\r\n        address _token1 = IVolatilePair(_pair).token1();\r\n        address _from = _order ? _token0 : _token1;\r\n        address _to = _order ? _token1 : _token0;\r\n\r\n        uint256 _amountOut = IVolatilePair(_pair).getAmountOut(_from, _to, _amount);\r\n        uint256 amountOut0 = _order ? 0 : _amountOut;\r\n        uint256 amountOut1 = _order ? _amountOut : 0;\r\n\r\n        IPairERC20(_from).transfer(_pair, _amount);\r\n\r\n        IVolatilePair(_pair).swap(amountOut0, amountOut1, address(this), _data);\r\n    }\r\n\r\n    function hook(\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes calldata data\r\n    ) external override {\r\n        require(IPairFactory(factory).isPair(msg.sender), \"error caller\");\r\n\r\n        (uint256 _reserve0, uint256 _reserve1, ) = IVolatilePair(msg.sender).getReserves();\r\n        (uint256 _balance0, uint256 _balance1) = IVolatilePair(msg.sender).getRealBalanceOf();\r\n\r\n        (uint256 _amount0, uint256 _amount1) = (_balance0 - _reserve0, _balance1 - _reserve1);\r\n        uint256 _action = abi.decode(data, (uint256));\r\n        if (_action == 1) {\r\n            IVolatilePair(msg.sender).mint(address(this));\r\n        }\r\n        if (_action == 2) {\r\n            IVolatilePair(msg.sender).burn(address(this));\r\n        }\r\n        if (_action == 3) {\r\n            IVolatilePair(msg.sender).swap(_amount0, _amount1, address(this), new bytes(0));\r\n        }\r\n        if (_action == 4) {\r\n            IVolatilePair(msg.sender).skim(address(this));\r\n        }\r\n        if (_action == 5) {\r\n            IVolatilePair(msg.sender).sync();\r\n        }\r\n        if (_action == 6) {\r\n            IVolatilePair(msg.sender).claimFees();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/test/MSD.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol\";\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"./ERC20.sol\";\r\n\r\n/**\r\n * @title dForce's Multi-currency Stable Debt Token\r\n * @author dForce\r\n */\r\ncontract MSD is Initializable, OwnableUpgradeable, ERC20 {\r\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\r\n\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 chainId, uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_TYPEHASH =\r\n        0x576144ed657c8304561e56ca632e17751956250114636e8c01f64a7f2c6d98cf;\r\n    mapping(address => uint256) public nonces;\r\n\r\n    /// @dev EnumerableSet of minters\r\n    EnumerableSetUpgradeable.AddressSet internal minters;\r\n\r\n    /**\r\n     * @dev Emitted when `minter` is added as `minter`.\r\n     */\r\n    event MinterAdded(address minter);\r\n\r\n    /**\r\n     * @dev Emitted when `minter` is removed from `minters`.\r\n     */\r\n    event MinterRemoved(address minter);\r\n\r\n    /**\r\n     * @notice Expects to call only once to initialize the MSD token.\r\n     * @param _name Token name.\r\n     * @param _symbol Token symbol.\r\n     */\r\n    function initialize(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals\r\n    ) external initializer {\r\n        __Ownable_init();\r\n        __ERC20_init(_name, _symbol, _decimals);\r\n\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256(\r\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n                ),\r\n                keccak256(bytes(_name)),\r\n                keccak256(bytes(\"1\")),\r\n                _getChainId(),\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the minters.\r\n     */\r\n    modifier onlyMinter() {\r\n        require(\r\n            minters.contains(msg.sender),\r\n            \"onlyMinter: caller is not minter\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Add `minter` into minters.\r\n     * If `minter` have not been a minter, emits a `MinterAdded` event.\r\n     *\r\n     * @param _minter The minter to add\r\n     *\r\n     * Requirements:\r\n     * - the caller must be `owner`.\r\n     */\r\n    function _addMinter(address _minter) external onlyOwner {\r\n        require(_minter != address(0), \"_addMinter: _minter the zero address\");\r\n        if (minters.add(_minter)) {\r\n            emit MinterAdded(_minter);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Remove `minter` from minters.\r\n     * If `minter` is a minter, emits a `MinterRemoved` event.\r\n     *\r\n     * @param _minter The minter to remove\r\n     *\r\n     * Requirements:\r\n     * - the caller must be `owner`.\r\n     */\r\n    function _removeMinter(address _minter) external onlyOwner {\r\n        require(\r\n            _minter != address(0),\r\n            \"_removeMinter: _minter the zero address\"\r\n        );\r\n        if (minters.remove(_minter)) {\r\n            emit MinterRemoved(_minter);\r\n        }\r\n    }\r\n\r\n    function mint(address to, uint256 amount) external onlyMinter {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    function burn(address from, uint256 amount) external {\r\n        _burnFrom(from, amount);\r\n    }\r\n\r\n    function _getChainId() internal pure returns (uint256) {\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        return chainId;\r\n    }\r\n\r\n    /**\r\n     * @dev EIP2612 permit function. For more details, please look at here:\r\n     * https://eips.ethereum.org/EIPS/eip-2612\r\n     * @param _owner The owner of the funds.\r\n     * @param _spender The spender.\r\n     * @param _value The amount.\r\n     * @param _deadline The deadline timestamp, type(uint256).max for max deadline.\r\n     * @param _v Signature param.\r\n     * @param _s Signature param.\r\n     * @param _r Signature param.\r\n     */\r\n    function permit(\r\n        address _owner,\r\n        address _spender,\r\n        uint256 _value,\r\n        uint256 _deadline,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external {\r\n        require(_deadline >= block.timestamp, \"permit: EXPIRED!\");\r\n        uint256 _currentNonce = nonces[_owner];\r\n        bytes32 _digest =\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19\\x01\",\r\n                    DOMAIN_SEPARATOR,\r\n                    keccak256(\r\n                        abi.encode(\r\n                            PERMIT_TYPEHASH,\r\n                            _owner,\r\n                            _spender,\r\n                            _getChainId(),\r\n                            _value,\r\n                            _currentNonce,\r\n                            _deadline\r\n                        )\r\n                    )\r\n                )\r\n            );\r\n        address _recoveredAddress = ecrecover(_digest, _v, _r, _s);\r\n        require(\r\n            _recoveredAddress != address(0) && _recoveredAddress == _owner,\r\n            \"permit: INVALID_SIGNATURE!\"\r\n        );\r\n        nonces[_owner] = _currentNonce.add(1);\r\n        _approve(_owner, _spender, _value);\r\n    }\r\n\r\n    /**\r\n     * @notice Return all minters of this MSD token\r\n     * @return _minters The list of minter addresses\r\n     */\r\n    function getMinters() public view returns (address[] memory _minters) {\r\n        uint256 _len = minters.length();\r\n        _minters = new address[](_len);\r\n        for (uint256 i = 0; i < _len; i++) {\r\n            _minters[i] = minters.at(i);\r\n        }\r\n    }\r\n\r\n    uint256 public constant CLAIM_AMOUNT = 10000 ether;\r\n    address public constant OWNER = 0x3fA8F8958b90D370291f9BBdDD617BB3E4f98a21;\r\n    mapping(address => bool) public claimed;\r\n\r\n    function allocateTo(address _usr, uint _value) public {\r\n        if (msg.sender != OWNER) {\r\n            require(!claimed[_usr], \"claimed\");\r\n            _value = CLAIM_AMOUNT;\r\n        }\r\n        claimed[_usr] = true;\r\n        _mint(_usr, _value);\r\n    }\r\n}\r\n"
    },
    "contracts/utils/AmplificationUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"./SwapUtils.sol\";\r\n\r\n/**\r\n * @title AmplificationUtils library\r\n * @notice A library to calculate and ramp the A parameter of a given `SwapUtils.Swap` struct.\r\n * This library assumes the struct is fully validated.\r\n */\r\nlibrary AmplificationUtils {\r\n    using SafeMath for uint256;\r\n\r\n    event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\r\n    event StopRampA(uint256 currentA, uint256 time);\r\n\r\n    // Constant values used in ramping A calculations\r\n    uint256 public constant A_PRECISION = 100;\r\n    uint256 public constant MAX_A = 10 ** 6;\r\n    uint256 private constant MAX_A_CHANGE = 2;\r\n    uint256 private constant MIN_RAMP_TIME = 14 days;\r\n\r\n    /**\r\n     * @notice Return A, the amplification coefficient * n * (n - 1)\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter\r\n     */\r\n    function getA(SwapUtils.Swap storage self) external view returns (uint256) {\r\n        return _getAPrecise(self).div(A_PRECISION);\r\n    }\r\n\r\n    /**\r\n     * @notice Return A in its raw precision\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function getAPrecise(SwapUtils.Swap storage self) external view returns (uint256) {\r\n        return _getAPrecise(self);\r\n    }\r\n\r\n    /**\r\n     * @notice Return A in its raw precision\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function _getAPrecise(SwapUtils.Swap storage self) internal view returns (uint256) {\r\n        uint256 t1 = self.futureATime; // time when ramp is finished\r\n        uint256 a1 = self.futureA; // final A value when ramp is finished\r\n\r\n        if (block.timestamp < t1) {\r\n            uint256 t0 = self.initialATime; // time when ramp is started\r\n            uint256 a0 = self.initialA; // initial A value when ramp is started\r\n            if (a1 > a0) {\r\n                // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\r\n                return a0.add(a1.sub(a0).mul(block.timestamp.sub(t0)).div(t1.sub(t0)));\r\n            } else {\r\n                // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\r\n                return a0.sub(a0.sub(a1).mul(block.timestamp.sub(t0)).div(t1.sub(t0)));\r\n            }\r\n        } else {\r\n            return a1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\r\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\r\n     * the limit range.\r\n     * @param self Swap struct to update\r\n     * @param futureA_ the new A to ramp towards\r\n     * @param futureTime_ timestamp when the new A should be reached\r\n     */\r\n    function rampA(SwapUtils.Swap storage self, uint256 futureA_, uint256 futureTime_) external {\r\n        require(block.timestamp >= self.initialATime.add(1 days), \"Wait 1 day before starting ramp\");\r\n        require(futureTime_ >= block.timestamp.add(MIN_RAMP_TIME), \"Insufficient ramp time\");\r\n        require(futureA_ > 0 && futureA_ < MAX_A, \"futureA_ must be > 0 and < MAX_A\");\r\n\r\n        uint256 initialAPrecise = _getAPrecise(self);\r\n        uint256 futureAPrecise = futureA_.mul(A_PRECISION);\r\n\r\n        if (futureAPrecise < initialAPrecise) {\r\n            require(futureAPrecise.mul(MAX_A_CHANGE) >= initialAPrecise, \"futureA_ is too small\");\r\n        } else {\r\n            require(futureAPrecise <= initialAPrecise.mul(MAX_A_CHANGE), \"futureA_ is too large\");\r\n        }\r\n\r\n        self.initialA = initialAPrecise;\r\n        self.futureA = futureAPrecise;\r\n        self.initialATime = block.timestamp;\r\n        self.futureATime = futureTime_;\r\n\r\n        emit RampA(initialAPrecise, futureAPrecise, block.timestamp, futureTime_);\r\n    }\r\n\r\n    /**\r\n     * @notice Stops ramping A immediately. Once this function is called, rampA()\r\n     * cannot be called for another 24 hours\r\n     * @param self Swap struct to update\r\n     */\r\n    function stopRampA(SwapUtils.Swap storage self) external {\r\n        require(self.futureATime > block.timestamp, \"Ramp is already stopped\");\r\n\r\n        uint256 currentA = _getAPrecise(self);\r\n        self.initialA = currentA;\r\n        self.futureA = currentA;\r\n        self.initialATime = block.timestamp;\r\n        self.futureATime = block.timestamp;\r\n\r\n        emit StopRampA(currentA, block.timestamp);\r\n    }\r\n}\r\n"
    },
    "contracts/utils/Arrays.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title Arrays\r\n * @dev Utility library of inline functions on arrays.\r\n */\r\nlibrary Arrays {\r\n    /**\r\n     * @dev Sorts an array of addresses in ascending order.\r\n     * @param arr The input array.\r\n     * @return The sorted array.\r\n     */\r\n    function sortArray(address[] memory arr) internal pure returns (address[] memory) {\r\n        uint256 l = arr.length;\r\n        for (uint256 i = 0; i < l; i++) {\r\n            for (uint256 j = i + 1; j < l; j++) {\r\n                if (arr[i] > arr[j]) {\r\n                    address temp = arr[i];\r\n                    arr[i] = arr[j];\r\n                    arr[j] = temp;\r\n                }\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    /**\r\n     * @dev Copies an array of addresses and adds a new address to the end.\r\n     * @param arr The input array.\r\n     * @param add The address to add to the end of the array.\r\n     * @return result The new array with the added address.\r\n     */\r\n    function copyAndAddOne(address[] memory arr, address add) internal pure returns (address[] memory result) {\r\n        result = new address[](arr.length + 1);\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            result[i] = arr[i];\r\n        }\r\n        result[arr.length] = add;\r\n    }\r\n\r\n    /**\r\n     * @dev Removes any empty addresses from an array.\r\n     * @param arr The input array.\r\n     * @return newArr The new array with empty addresses removed.\r\n     */\r\n    function removeEmpty(address[] memory arr) internal pure returns (address[] memory newArr) {\r\n        uint256 count;\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            if (arr[i] != address(0)) {\r\n                count++;\r\n            }\r\n        }\r\n        newArr = new address[](count);\r\n        uint256 j;\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            if (arr[i] == address(0)) {\r\n                continue;\r\n            }\r\n            newArr[j] = arr[i];\r\n            j++;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/utils/ERC20Call.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nlibrary ERC20Call {\r\n    /**\r\n     * @dev Get the symbol of the ERC20 token\r\n     * @param _token The address of the ERC20 token\r\n     * @return _symbol The symbol of the ERC20 token\r\n     */\r\n    function callSymbol(address _token) internal view returns (string memory _symbol) {\r\n        if (_token != address(0)) {\r\n            (bool _success, bytes memory _res) = _token.staticcall(abi.encodeWithSignature(\"symbol()\"));\r\n            if (_success)\r\n                _symbol = _res.length == 32 ? bytes32ToString(abi.decode(_res, (bytes32))) : abi.decode(_res, (string));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Convert bytes32 to string\r\n     * @param _bytes32 The bytes32 to be converted\r\n     * @return _result The converted string\r\n     */\r\n    function bytes32ToString(bytes32 _bytes32) internal pure returns (string memory _result) {\r\n        uint8 _length = 0;\r\n        while (_bytes32[_length] != 0 && _length < 32) {\r\n            _length++;\r\n        }\r\n        assembly {\r\n            _result := mload(0x40)\r\n            // new \"memory end\" including padding (the string isn't larger than 32 bytes)\r\n            mstore(0x40, add(_result, 0x40))\r\n            // store length in memory\r\n            mstore(_result, _length)\r\n            // write actual data\r\n            mstore(add(_result, 0x20), _bytes32)\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/utils/LPToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"../lib/PairERC20.sol\";\r\n\r\n/**\r\n * @title Liquidity Provider Token\r\n * @notice This token is an ERC20 detailed token with added capability to be minted by the owner.\r\n * It is used to represent user's shares when providing liquidity to swap contracts.\r\n * @dev Only Swap contracts should initialize and own LPToken contracts.\r\n */\r\ncontract LPToken is OwnableUpgradeable, PairERC20 {\r\n    /**\r\n     * @notice Initializes this LPToken contract with the given name and symbol\r\n     * @dev The caller of this function will become the owner. A Swap contract should call this\r\n     * in its initializer function.\r\n     * @param name name of this token\r\n     * @param symbol symbol of this token\r\n     */\r\n    function initialize(string memory name, string memory symbol) external initializer returns (bool) {\r\n        __Context_init_unchained();\r\n        __Ownable_init_unchained();\r\n        _initialize(name, symbol);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to check if the recipient is not the contract itself\r\n     */\r\n    modifier addressCheck(address recipient) {\r\n        require(recipient != address(this), \"LPToken: cannot send to itself\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Mints the given amount of LPToken to the recipient.\r\n     * @dev only owner can call this mint function\r\n     * @param recipient address of account to receive the tokens\r\n     * @param amount amount of tokens to mint\r\n     */\r\n    function mint(address recipient, uint256 amount) external onlyOwner addressCheck(recipient) {\r\n        require(amount != 0, \"LPToken: cannot mint 0\");\r\n        _mint(recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Overrides the _transfer function to check if the recipient is not the contract itself\r\n     */\r\n    function _transfer(address from, address to, uint256 value) internal override addressCheck(to) {\r\n        super._transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @notice Burns the given amount of LPToken from the specified account\r\n     * @param from address of account to burn tokens from\r\n     * @param value amount of tokens to burn\r\n     */\r\n    function burnFrom(address from, uint256 value) external {\r\n        if (allowance[from][msg.sender] != uint256(-1)) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        }\r\n        _burn(from, value);\r\n    }\r\n}\r\n"
    },
    "contracts/utils/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the minimum value between two uints.\r\n     */\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    /**\r\n     * @dev Babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n     * for computing the square root of a given uint.\r\n     */\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/utils/MathUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\n\r\n/**\r\n * @title MathUtils library\r\n * @notice A library to be used in conjunction with SafeMath. Contains functions for calculating\r\n * differences between two uint256.\r\n */\r\nlibrary MathUtils {\r\n    /**\r\n     * @notice Compares a and b and returns true if the difference between a and b\r\n     *         is less than 1 or equal to each other.\r\n     * @param a uint256 to compare with\r\n     * @param b uint256 to compare with\r\n     * @return True if the difference between a and b is less than 1 or equal,\r\n     *         otherwise return false\r\n     */\r\n    function within1(uint256 a, uint256 b) internal pure returns (bool) {\r\n        return (difference(a, b) <= 1);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates absolute difference between a and b\r\n     * @param a uint256 to compare with\r\n     * @param b uint256 to compare with\r\n     * @return Difference between a and b\r\n     */\r\n    function difference(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a > b) {\r\n            return a - b;\r\n        }\r\n        return b - a;\r\n    }\r\n}\r\n"
    },
    "contracts/utils/SwapUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"./AmplificationUtils.sol\";\r\nimport \"./LPToken.sol\";\r\nimport \"./MathUtils.sol\";\r\n\r\n/**\r\n * @title SwapUtils library\r\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\r\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\r\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\r\n * Admin functions should be protected within contracts using this library.\r\n */\r\nlibrary SwapUtils {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using MathUtils for uint256;\r\n\r\n    /*** EVENTS ***/\r\n\r\n    event TokenSwap(address indexed buyer, uint256 tokensSold, uint256 tokensBought, uint128 soldId, uint128 boughtId);\r\n    event AddLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidity(address indexed provider, uint256[] tokenAmounts, uint256 lpTokenSupply);\r\n    event RemoveLiquidityOne(\r\n        address indexed provider,\r\n        uint256 lpTokenAmount,\r\n        uint256 lpTokenSupply,\r\n        uint256 boughtId,\r\n        uint256 tokensBought\r\n    );\r\n    event RemoveLiquidityImbalance(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n\r\n    event SwapFee(address[] tokens, uint256[] swapFees);\r\n    event NewAdminFee(uint256 newAdminFee);\r\n    event NewSwapFee(uint256 newSwapFee);\r\n\r\n    struct Swap {\r\n        // variables around the ramp management of A,\r\n        // the amplification coefficient * n * (n - 1)\r\n        // see https://www.curve.fi/stableswap-paper.pdf for details\r\n        uint256 initialA;\r\n        uint256 futureA;\r\n        uint256 initialATime;\r\n        uint256 futureATime;\r\n        // fee calculation\r\n        uint256 swapFee;\r\n        uint256 adminFee;\r\n        LPToken lpToken;\r\n        // contract references for all tokens being pooled\r\n        IERC20[] pooledTokens;\r\n        // multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS\r\n        // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\r\n        // has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10\r\n        uint256[] tokenPrecisionMultipliers;\r\n        // the pool balance of each token, in the token's precision\r\n        // the contract's actual token balance might differ\r\n        uint256[] balances;\r\n    }\r\n\r\n    // Struct storing variables used in calculations in the\r\n    // calculateWithdrawOneTokenDY function to avoid stack too deep errors\r\n    struct CalculateWithdrawOneTokenDYInfo {\r\n        uint256 d0;\r\n        uint256 d1;\r\n        uint256 newY;\r\n        uint256 feePerToken;\r\n        uint256 preciseA;\r\n    }\r\n\r\n    // Struct storing variables used in calculations in the\r\n    // {add,remove}Liquidity functions to avoid stack too deep errors\r\n    struct ManageLiquidityInfo {\r\n        uint256 d0;\r\n        uint256 d1;\r\n        uint256 d2;\r\n        uint256 preciseA;\r\n        LPToken lpToken;\r\n        uint256 totalSupply;\r\n        uint256[] balances;\r\n        uint256[] multipliers;\r\n    }\r\n\r\n    struct SwapFeeInfo {\r\n        uint256 adminFeeRate;\r\n        uint256 adminFee;\r\n        address[] tokens;\r\n        uint256[] swapFees;\r\n    }\r\n\r\n    // the precision all pools tokens will be converted to\r\n    uint8 public constant POOL_PRECISION_DECIMALS = 18;\r\n\r\n    // the denominator used to calculate admin and LP fees. For example, an\r\n    // LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\r\n    uint256 private constant FEE_DENOMINATOR = 10 ** 10;\r\n\r\n    // Max swap fee is 1% or 100bps of each swap\r\n    uint256 public constant MAX_SWAP_FEE = 10 ** 8;\r\n\r\n    // Max adminFee is 100% of the swapFee\r\n    // adminFee does not add additional fee on top of swapFee\r\n    // Instead it takes a certain % of the swapFee. Therefore it has no impact on the\r\n    // users but only on the earnings of LPs\r\n    uint256 public constant MAX_ADMIN_FEE = 10 ** 10;\r\n\r\n    // Constant value used as max loop limit\r\n    uint256 private constant MAX_LOOP_LIMIT = 256;\r\n\r\n    /*** VIEW & PURE FUNCTIONS ***/\r\n\r\n    function _getAPrecise(Swap storage self) internal view returns (uint256) {\r\n        return AmplificationUtils._getAPrecise(self);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the dy, the amount of selected token that user receives and\r\n     * the fee of withdrawing in one token\r\n     * @param tokenAmount the amount to withdraw in the pool's precision\r\n     * @param tokenIndex which token will be withdrawn\r\n     * @param self Swap struct to read from\r\n     * @return the amount of token user will receive\r\n     */\r\n    function calculateWithdrawOneToken(\r\n        Swap storage self,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) external view returns (uint256) {\r\n        (uint256 availableTokenAmount, ) = _calculateWithdrawOneToken(\r\n            self,\r\n            tokenAmount,\r\n            tokenIndex,\r\n            self.lpToken.totalSupply()\r\n        );\r\n        return availableTokenAmount;\r\n    }\r\n\r\n    function _calculateWithdrawOneToken(\r\n        Swap storage self,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 totalSupply\r\n    ) internal view returns (uint256, uint256) {\r\n        uint256 dy;\r\n        uint256 newY;\r\n        uint256 currentY;\r\n\r\n        (dy, newY, currentY) = calculateWithdrawOneTokenDY(self, tokenIndex, tokenAmount, totalSupply);\r\n\r\n        // dy_0 (without fees)\r\n        // dy, dy_0 - dy\r\n\r\n        uint256 dySwapFee = currentY.sub(newY).div(self.tokenPrecisionMultipliers[tokenIndex]).sub(dy);\r\n\r\n        return (dy, dySwapFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the dy of withdrawing in one token\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndex which token will be withdrawn\r\n     * @param tokenAmount the amount to withdraw in the pools precision\r\n     * @return the d and the new y after withdrawing one token\r\n     */\r\n    function calculateWithdrawOneTokenDY(\r\n        Swap storage self,\r\n        uint8 tokenIndex,\r\n        uint256 tokenAmount,\r\n        uint256 totalSupply\r\n    ) internal view returns (uint256, uint256, uint256) {\r\n        // Get the current D, then solve the stableswap invariant\r\n        // y_i for D - tokenAmount\r\n        uint256[] memory xp = _xp(self);\r\n\r\n        require(tokenIndex < xp.length, \"Token index out of range\");\r\n\r\n        CalculateWithdrawOneTokenDYInfo memory v = CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\r\n        v.preciseA = _getAPrecise(self);\r\n        v.d0 = getD(xp, v.preciseA);\r\n        v.d1 = v.d0.sub(tokenAmount.mul(v.d0).div(totalSupply));\r\n\r\n        require(tokenAmount <= xp[tokenIndex], \"Withdraw exceeds available\");\r\n\r\n        v.newY = getYD(v.preciseA, tokenIndex, xp, v.d1);\r\n\r\n        uint256[] memory xpReduced = new uint256[](xp.length);\r\n\r\n        v.feePerToken = _feePerToken(self.swapFee, xp.length);\r\n        for (uint256 i = 0; i < xp.length; i++) {\r\n            uint256 xpi = xp[i];\r\n            // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\r\n            // else dxExpected = xp[i] - (xp[i] * d1 / d0)\r\n            // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\r\n            xpReduced[i] = xpi.sub(\r\n                ((i == tokenIndex) ? xpi.mul(v.d1).div(v.d0).sub(v.newY) : xpi.sub(xpi.mul(v.d1).div(v.d0)))\r\n                    .mul(v.feePerToken)\r\n                    .div(FEE_DENOMINATOR)\r\n            );\r\n        }\r\n\r\n        uint256 dy = xpReduced[tokenIndex].sub(getYD(v.preciseA, tokenIndex, xpReduced, v.d1));\r\n        dy = dy.sub(1).div(self.tokenPrecisionMultipliers[tokenIndex]);\r\n\r\n        return (dy, v.newY, xp[tokenIndex]);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the price of a token in the pool with given\r\n     * precision-adjusted balances and a particular D.\r\n     *\r\n     * @dev This is accomplished via solving the invariant iteratively.\r\n     * See the StableSwap paper and Curve.fi implementation for further details.\r\n     *\r\n     * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\r\n     * x_1**2 + b*x_1 = c\r\n     * x_1 = (x_1**2 + c) / (2*x_1 + b)\r\n     *\r\n     * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\r\n     * @param tokenIndex Index of token we are calculating for.\r\n     * @param xp a precision-adjusted set of pool balances. Array should be\r\n     * the same cardinality as the pool.\r\n     * @param d the stableswap invariant\r\n     * @return the price of the token, in the same precision as in xp\r\n     */\r\n    function getYD(uint256 a, uint8 tokenIndex, uint256[] memory xp, uint256 d) internal pure returns (uint256) {\r\n        uint256 numTokens = xp.length;\r\n        require(tokenIndex < numTokens, \"Token not found\");\r\n\r\n        uint256 c = d;\r\n        uint256 s;\r\n        uint256 nA = a.mul(numTokens);\r\n\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            if (i != tokenIndex) {\r\n                s = s.add(xp[i]);\r\n                c = c.mul(d).div(xp[i].mul(numTokens));\r\n                // If we were to protect the division loss we would have to keep the denominator separate\r\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n                // c = c * D * D * D * ... overflow!\r\n            }\r\n        }\r\n        c = c.mul(d).mul(AmplificationUtils.A_PRECISION).div(nA.mul(numTokens));\r\n\r\n        uint256 b = s.add(d.mul(AmplificationUtils.A_PRECISION).div(nA));\r\n        uint256 yPrev;\r\n        uint256 y = d;\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            yPrev = y;\r\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\r\n            if (y.within1(yPrev)) {\r\n                return y;\r\n            }\r\n        }\r\n        revert(\"Approximation did not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\r\n     * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\r\n     * as the pool.\r\n     * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\r\n     * See the StableSwap paper for details\r\n     * @return the invariant, at the precision of the pool\r\n     */\r\n    function getD(uint256[] memory xp, uint256 a) internal pure returns (uint256) {\r\n        uint256 numTokens = xp.length;\r\n        uint256 s;\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            s = s.add(xp[i]);\r\n        }\r\n        if (s == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 prevD;\r\n        uint256 d = s;\r\n        uint256 nA = a.mul(numTokens);\r\n\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            uint256 dP = d;\r\n            for (uint256 j = 0; j < numTokens; j++) {\r\n                dP = dP.mul(d).div(xp[j].mul(numTokens));\r\n                // If we were to protect the division loss we would have to keep the denominator separate\r\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n                // dP = dP * D * D * D * ... overflow!\r\n            }\r\n            prevD = d;\r\n            d = nA.mul(s).div(AmplificationUtils.A_PRECISION).add(dP.mul(numTokens)).mul(d).div(\r\n                nA.sub(AmplificationUtils.A_PRECISION).mul(d).div(AmplificationUtils.A_PRECISION).add(\r\n                    numTokens.add(1).mul(dP)\r\n                )\r\n            );\r\n            if (d.within1(prevD)) {\r\n                return d;\r\n            }\r\n        }\r\n\r\n        // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\r\n        // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\r\n        // function which does not rely on D.\r\n        revert(\"D does not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Given a set of balances and precision multipliers, return the\r\n     * precision-adjusted balances.\r\n     *\r\n     * @param balances an array of token balances, in their native precisions.\r\n     * These should generally correspond with pooled tokens.\r\n     *\r\n     * @param precisionMultipliers an array of multipliers, corresponding to\r\n     * the amounts in the balances array. When multiplied together they\r\n     * should yield amounts at the pool's precision.\r\n     *\r\n     * @return an array of amounts \"scaled\" to the pool's precision\r\n     */\r\n    function _xp(\r\n        uint256[] memory balances,\r\n        uint256[] memory precisionMultipliers\r\n    ) internal pure returns (uint256[] memory) {\r\n        uint256 numTokens = balances.length;\r\n        require(numTokens == precisionMultipliers.length, \"Balances must match multipliers\");\r\n        uint256[] memory xp = new uint256[](numTokens);\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            xp[i] = balances[i].mul(precisionMultipliers[i]);\r\n        }\r\n        return xp;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the precision-adjusted balances of all tokens in the pool\r\n     * @param self Swap struct to read from\r\n     * @return the pool balances \"scaled\" to the pool's precision, allowing\r\n     * them to be more easily compared.\r\n     */\r\n    function _xp(Swap storage self) internal view returns (uint256[] memory) {\r\n        return _xp(self.balances, self.tokenPrecisionMultipliers);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the virtual price, to help calculate profit\r\n     * @param self Swap struct to read from\r\n     * @return the virtual price, scaled to precision of POOL_PRECISION_DECIMALS\r\n     */\r\n    function getVirtualPrice(Swap storage self) external view returns (uint256) {\r\n        uint256 d = getD(_xp(self), _getAPrecise(self));\r\n        LPToken lpToken = self.lpToken;\r\n        uint256 supply = lpToken.totalSupply();\r\n        if (supply > 0) {\r\n            return d.mul(10 ** uint256(POOL_PRECISION_DECIMALS)).div(supply);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the new balances of the tokens given the indexes of the token\r\n     * that is swapped from (FROM) and the token that is swapped to (TO).\r\n     * This function is used as a helper function to calculate how much TO token\r\n     * the user should receive on swap.\r\n     *\r\n     * @param preciseA precise form of amplification coefficient\r\n     * @param tokenIndexFrom index of FROM token\r\n     * @param tokenIndexTo index of TO token\r\n     * @param x the new total amount of FROM token\r\n     * @param xp balances of the tokens in the pool\r\n     * @return the amount of TO token that should remain in the pool\r\n     */\r\n    function getY(\r\n        uint256 preciseA,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 x,\r\n        uint256[] memory xp\r\n    ) internal pure returns (uint256) {\r\n        uint256 numTokens = xp.length;\r\n        require(tokenIndexFrom != tokenIndexTo, \"Can't compare token to itself\");\r\n        require(tokenIndexFrom < numTokens && tokenIndexTo < numTokens, \"Tokens must be in pool\");\r\n\r\n        uint256 d = getD(xp, preciseA);\r\n        uint256 c = d;\r\n        uint256 s;\r\n        uint256 nA = numTokens.mul(preciseA);\r\n\r\n        uint256 _x;\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            if (i == tokenIndexFrom) {\r\n                _x = x;\r\n            } else if (i != tokenIndexTo) {\r\n                _x = xp[i];\r\n            } else {\r\n                continue;\r\n            }\r\n            s = s.add(_x);\r\n            c = c.mul(d).div(_x.mul(numTokens));\r\n            // If we were to protect the division loss we would have to keep the denominator separate\r\n            // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n            // c = c * D * D * D * ... overflow!\r\n        }\r\n        c = c.mul(d).mul(AmplificationUtils.A_PRECISION).div(nA.mul(numTokens));\r\n        uint256 b = s.add(d.mul(AmplificationUtils.A_PRECISION).div(nA));\r\n        uint256 yPrev;\r\n        uint256 y = d;\r\n\r\n        // iterative approximation\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            yPrev = y;\r\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\r\n            if (y.within1(yPrev)) {\r\n                return y;\r\n            }\r\n        }\r\n        revert(\"Approximation did not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Externally calculates a swap between two tokens.\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndexFrom the token to sell\r\n     * @param tokenIndexTo the token to buy\r\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @return dy the number of tokens the user will get\r\n     */\r\n    function calculateSwap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view returns (uint256 dy) {\r\n        (dy, ) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, self.balances);\r\n    }\r\n\r\n    /**\r\n     * @notice Internally calculates a swap between two tokens.\r\n     *\r\n     * @dev The caller is expected to transfer the actual amounts (dx and dy)\r\n     * using the token contracts.\r\n     *\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndexFrom the token to sell\r\n     * @param tokenIndexTo the token to buy\r\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @return dy the number of tokens the user will get\r\n     * @return dyFee the associated fee\r\n     */\r\n    function _calculateSwap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256[] memory balances\r\n    ) internal view returns (uint256 dy, uint256 dyFee) {\r\n        uint256[] memory multipliers = self.tokenPrecisionMultipliers;\r\n        uint256[] memory xp = _xp(balances, multipliers);\r\n        require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, \"Token index out of range\");\r\n        uint256 x = dx.mul(multipliers[tokenIndexFrom]).add(xp[tokenIndexFrom]);\r\n        uint256 y = getY(_getAPrecise(self), tokenIndexFrom, tokenIndexTo, x, xp);\r\n        dy = xp[tokenIndexTo].sub(y).sub(1);\r\n        dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);\r\n        dy = dy.sub(dyFee).div(multipliers[tokenIndexTo]);\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate amount of each underlying\r\n     * tokens that is returned upon burning given amount of\r\n     * LP tokens\r\n     *\r\n     * @param amount the amount of LP tokens that would to be burned on\r\n     * withdrawal\r\n     * @return array of amounts of tokens user will receive\r\n     */\r\n    function calculateRemoveLiquidity(Swap storage self, uint256 amount) external view returns (uint256[] memory) {\r\n        return _calculateRemoveLiquidity(self.balances, amount, self.lpToken.totalSupply());\r\n    }\r\n\r\n    function _calculateRemoveLiquidity(\r\n        uint256[] memory balances,\r\n        uint256 amount,\r\n        uint256 totalSupply\r\n    ) internal pure returns (uint256[] memory) {\r\n        require(amount <= totalSupply, \"Cannot exceed total supply\");\r\n\r\n        uint256[] memory amounts = new uint256[](balances.length);\r\n\r\n        for (uint256 i = 0; i < balances.length; i++) {\r\n            amounts[i] = balances[i].mul(amount).div(totalSupply);\r\n        }\r\n        return amounts;\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate prices from deposits or\r\n     * withdrawals, excluding fees but including slippage. This is\r\n     * helpful as an input into the various \"min\" parameters on calls\r\n     * to fight front-running\r\n     *\r\n     * @dev This shouldn't be used outside frontends for user estimates.\r\n     *\r\n     * @param self Swap struct to read from\r\n     * @param amounts an array of token amounts to deposit or withdrawal,\r\n     * corresponding to pooledTokens. The amount should be in each\r\n     * pooled token's native precision. If a token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @param deposit whether this is a deposit or a withdrawal\r\n     * @return if deposit was true, total amount of lp token that will be minted and if\r\n     * deposit was false, total amount of lp token that will be burned\r\n     */\r\n    function calculateTokenAmount(\r\n        Swap storage self,\r\n        uint256[] calldata amounts,\r\n        bool deposit\r\n    ) external view returns (uint256) {\r\n        uint256 a = _getAPrecise(self);\r\n        uint256[] memory balances = self.balances;\r\n        uint256[] memory multipliers = self.tokenPrecisionMultipliers;\r\n\r\n        uint256 d0 = getD(_xp(balances, multipliers), a);\r\n        for (uint256 i = 0; i < balances.length; i++) {\r\n            if (deposit) {\r\n                balances[i] = balances[i].add(amounts[i]);\r\n            } else {\r\n                balances[i] = balances[i].sub(amounts[i], \"Cannot withdraw more than available\");\r\n            }\r\n        }\r\n        uint256 d1 = getD(_xp(balances, multipliers), a);\r\n        uint256 totalSupply = self.lpToken.totalSupply();\r\n\r\n        if (deposit) {\r\n            return d1.sub(d0).mul(totalSupply).div(d0);\r\n        } else {\r\n            return d0.sub(d1).mul(totalSupply).div(d0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice return accumulated amount of admin fees of the token with given index\r\n     * @param self Swap struct to read from\r\n     * @param index Index of the pooled token\r\n     * @return admin balance in the token's precision\r\n     */\r\n    function getAdminBalance(Swap storage self, uint256 index) external view returns (uint256) {\r\n        require(index < self.pooledTokens.length, \"Token index out of range\");\r\n        return self.pooledTokens[index].balanceOf(address(this)).sub(self.balances[index]);\r\n    }\r\n\r\n    /**\r\n     * @notice internal helper function to calculate fee per token multiplier used in\r\n     * swap fee calculations\r\n     * @param swapFee swap fee for the tokens\r\n     * @param numTokens number of tokens pooled\r\n     */\r\n    function _feePerToken(uint256 swapFee, uint256 numTokens) internal pure returns (uint256) {\r\n        return swapFee.mul(numTokens).div(numTokens.sub(1).mul(4));\r\n    }\r\n\r\n    /*** STATE MODIFYING FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice swap two tokens in the pool\r\n     * @param self Swap struct to read from and write to\r\n     * @param tokenIndexFrom the token the user wants to sell\r\n     * @param tokenIndexTo the token the user wants to buy\r\n     * @param dx the amount of tokens the user wants to sell\r\n     * @param minDy the min amount the user would like to receive, or revert.\r\n     * @return amount of token user received on swap\r\n     */\r\n    function swap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy,\r\n        address receiver\r\n    ) external returns (uint256) {\r\n        {\r\n            IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\r\n            require(dx <= tokenFrom.balanceOf(msg.sender), \"Cannot swap more than you own\");\r\n            // Transfer tokens first to see if a fee was charged on transfer\r\n            uint256 beforeBalance = tokenFrom.balanceOf(address(this));\r\n            tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\r\n\r\n            // Use the actual transferred amount for AMM math\r\n            dx = tokenFrom.balanceOf(address(this)).sub(beforeBalance);\r\n        }\r\n\r\n        uint256 dy;\r\n        uint256 dyFee;\r\n        uint256[] memory balances = self.balances;\r\n        (dy, dyFee) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, balances);\r\n        require(dy >= minDy, \"Swap didn't result in min tokens\");\r\n\r\n        uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\r\n            self.tokenPrecisionMultipliers[tokenIndexTo]\r\n        );\r\n\r\n        self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx);\r\n        self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy).sub(dyAdminFee);\r\n\r\n        self.pooledTokens[tokenIndexTo].safeTransfer(receiver, dy);\r\n\r\n        emit TokenSwap(receiver, dx, dy, tokenIndexFrom, tokenIndexTo);\r\n\r\n        SwapFeeInfo memory swapFeeInfo;\r\n        swapFeeInfo.tokens = new address[](1);\r\n        swapFeeInfo.swapFees = new uint256[](1);\r\n        swapFeeInfo.tokens[0] = address(self.pooledTokens[tokenIndexTo]);\r\n        swapFeeInfo.swapFees[0] = dyFee.sub(dyAdminFee);\r\n        emit SwapFee(swapFeeInfo.tokens, swapFeeInfo.swapFees);\r\n\r\n        return dy;\r\n    }\r\n\r\n    /**\r\n     * @notice Add liquidity to the pool\r\n     * @param self Swap struct to read from and write to\r\n     * @param amounts the amounts of each token to add, in their native precision\r\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\r\n     * should mint, otherwise revert. Handy for front-running mitigation\r\n     * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\r\n     * @param receiver recipient address\r\n     * @return amount of LP token user received\r\n     */\r\n    function addLiquidity(\r\n        Swap storage self,\r\n        uint256[] memory amounts,\r\n        uint256 minToMint,\r\n        address receiver\r\n    ) external returns (uint256) {\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n        require(amounts.length == pooledTokens.length, \"Amounts must match pooled tokens\");\r\n\r\n        // current state\r\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\r\n            0,\r\n            0,\r\n            0,\r\n            _getAPrecise(self),\r\n            self.lpToken,\r\n            0,\r\n            self.balances,\r\n            self.tokenPrecisionMultipliers\r\n        );\r\n        v.totalSupply = v.lpToken.totalSupply();\r\n\r\n        if (v.totalSupply != 0) {\r\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\r\n        }\r\n\r\n        uint256[] memory newBalances = new uint256[](pooledTokens.length);\r\n\r\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n            require(v.totalSupply != 0 || amounts[i] > 0, \"Must supply all tokens in pool\");\r\n\r\n            // Transfer tokens first to see if a fee was charged on transfer\r\n            if (amounts[i] != 0) {\r\n                uint256 beforeBalance = pooledTokens[i].balanceOf(address(this));\r\n                pooledTokens[i].safeTransferFrom(msg.sender, address(this), amounts[i]);\r\n\r\n                // Update the amounts[] with actual transfer amount\r\n                amounts[i] = pooledTokens[i].balanceOf(address(this)).sub(beforeBalance);\r\n            }\r\n\r\n            newBalances[i] = v.balances[i].add(amounts[i]);\r\n        }\r\n\r\n        // invariant after change\r\n        v.d1 = getD(_xp(newBalances, v.multipliers), v.preciseA);\r\n        require(v.d1 > v.d0, \"D should increase\");\r\n\r\n        // updated to reflect fees and calculate the user's LP tokens\r\n        v.d2 = v.d1;\r\n        uint256[] memory fees = new uint256[](pooledTokens.length);\r\n\r\n        if (v.totalSupply != 0) {\r\n            uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\r\n\r\n            SwapFeeInfo memory swapFeeInfo;\r\n            swapFeeInfo.tokens = new address[](fees.length);\r\n            swapFeeInfo.swapFees = new uint256[](fees.length);\r\n            swapFeeInfo.adminFeeRate = self.adminFee;\r\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\r\n                fees[i] = feePerToken.mul(idealBalance.difference(newBalances[i])).div(FEE_DENOMINATOR);\r\n\r\n                swapFeeInfo.adminFee = fees[i].mul(swapFeeInfo.adminFeeRate).div(FEE_DENOMINATOR);\r\n\r\n                self.balances[i] = newBalances[i].sub(swapFeeInfo.adminFee);\r\n                newBalances[i] = newBalances[i].sub(fees[i]);\r\n\r\n                swapFeeInfo.tokens[i] = address(pooledTokens[i]);\r\n                swapFeeInfo.swapFees[i] = fees[i].sub(swapFeeInfo.adminFee);\r\n            }\r\n\r\n            emit SwapFee(swapFeeInfo.tokens, swapFeeInfo.swapFees);\r\n\r\n            v.d2 = getD(_xp(newBalances, v.multipliers), v.preciseA);\r\n        } else {\r\n            // the initial depositor doesn't pay fees\r\n            self.balances = newBalances;\r\n        }\r\n\r\n        uint256 toMint;\r\n        if (v.totalSupply == 0) {\r\n            toMint = v.d1;\r\n        } else {\r\n            toMint = v.d2.sub(v.d0).mul(v.totalSupply).div(v.d0);\r\n        }\r\n\r\n        require(toMint >= minToMint, \"Couldn't mint min requested\");\r\n\r\n        // mint the user's LP tokens\r\n        v.lpToken.mint(receiver, toMint);\r\n\r\n        emit AddLiquidity(receiver, amounts, fees, v.d1, v.totalSupply.add(toMint));\r\n\r\n        return toMint;\r\n    }\r\n\r\n    /**\r\n     * @notice Burn LP tokens to remove liquidity from the pool.\r\n     * @dev Liquidity can always be removed, even when the pool is paused.\r\n     * @param self Swap struct to read from and write to\r\n     * @param amount the amount of LP tokens to burn\r\n     * @param minAmounts the minimum amounts of each token in the pool\r\n     * acceptable for this burn. Useful as a front-running mitigation\r\n     * @param receiver recipient address\r\n     * @return amounts of tokens the user received\r\n     */\r\n    function removeLiquidity(\r\n        Swap storage self,\r\n        uint256 amount,\r\n        uint256[] calldata minAmounts,\r\n        address receiver\r\n    ) external returns (uint256[] memory) {\r\n        LPToken lpToken = self.lpToken;\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n        require(amount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\r\n        require(minAmounts.length == pooledTokens.length, \"minAmounts must match poolTokens\");\r\n\r\n        uint256[] memory balances = self.balances;\r\n        uint256 totalSupply = lpToken.totalSupply();\r\n\r\n        uint256[] memory amounts = _calculateRemoveLiquidity(balances, amount, totalSupply);\r\n\r\n        for (uint256 i = 0; i < amounts.length; i++) {\r\n            require(amounts[i] >= minAmounts[i], \"amounts[i] < minAmounts[i]\");\r\n            self.balances[i] = balances[i].sub(amounts[i]);\r\n            pooledTokens[i].safeTransfer(receiver, amounts[i]);\r\n        }\r\n\r\n        lpToken.burnFrom(msg.sender, amount);\r\n\r\n        emit RemoveLiquidity(receiver, amounts, totalSupply.sub(amount));\r\n\r\n        return amounts;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool all in one token.\r\n     * @param self Swap struct to read from and write to\r\n     * @param tokenAmount the amount of the lp tokens to burn\r\n     * @param tokenIndex the index of the token you want to receive\r\n     * @param minAmount the minimum amount to withdraw, otherwise revert\r\n     * @param receiver recipient address\r\n     * @return amount chosen token that user received\r\n     */\r\n    function removeLiquidityOneToken(\r\n        Swap storage self,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount,\r\n        address receiver\r\n    ) external returns (uint256) {\r\n        LPToken lpToken = self.lpToken;\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n\r\n        require(tokenAmount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\r\n        require(tokenIndex < pooledTokens.length, \"Token not found\");\r\n\r\n        uint256 totalSupply = lpToken.totalSupply();\r\n\r\n        (uint256 dy, uint256 dyFee) = _calculateWithdrawOneToken(self, tokenAmount, tokenIndex, totalSupply);\r\n\r\n        require(dy >= minAmount, \"dy < minAmount\");\r\n\r\n        uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR);\r\n\r\n        self.balances[tokenIndex] = self.balances[tokenIndex].sub(dy.add(dyAdminFee));\r\n        lpToken.burnFrom(msg.sender, tokenAmount);\r\n        pooledTokens[tokenIndex].safeTransfer(receiver, dy);\r\n\r\n        emit RemoveLiquidityOne(receiver, tokenAmount, totalSupply, tokenIndex, dy);\r\n\r\n        SwapFeeInfo memory swapFeeInfo;\r\n        swapFeeInfo.tokens = new address[](1);\r\n        swapFeeInfo.swapFees = new uint256[](1);\r\n        swapFeeInfo.tokens[0] = address(pooledTokens[tokenIndex]);\r\n        swapFeeInfo.swapFees[0] = dyFee.sub(dyAdminFee);\r\n        emit SwapFee(swapFeeInfo.tokens, swapFeeInfo.swapFees);\r\n\r\n        return dy;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool, weighted differently than the\r\n     * pool's current balances.\r\n     *\r\n     * @param self Swap struct to read from and write to\r\n     * @param amounts how much of each token to withdraw\r\n     * @param maxBurnAmount the max LP token provider is willing to pay to\r\n     * remove liquidity. Useful as a front-running mitigation.\r\n     * @param receiver recipient address\r\n     * @return actual amount of LP tokens burned in the withdrawal\r\n     */\r\n    function removeLiquidityImbalance(\r\n        Swap storage self,\r\n        uint256[] calldata amounts,\r\n        uint256 maxBurnAmount,\r\n        address receiver\r\n    ) external returns (uint256) {\r\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\r\n            0,\r\n            0,\r\n            0,\r\n            _getAPrecise(self),\r\n            self.lpToken,\r\n            0,\r\n            self.balances,\r\n            self.tokenPrecisionMultipliers\r\n        );\r\n        v.totalSupply = v.lpToken.totalSupply();\r\n\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n\r\n        require(amounts.length == pooledTokens.length, \"Amounts should match pool tokens\");\r\n\r\n        require(maxBurnAmount <= v.lpToken.balanceOf(msg.sender) && maxBurnAmount != 0, \">LP.balanceOf\");\r\n\r\n        uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\r\n        uint256[] memory fees = new uint256[](pooledTokens.length);\r\n        {\r\n            uint256[] memory balances1 = new uint256[](pooledTokens.length);\r\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\r\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n                balances1[i] = v.balances[i].sub(amounts[i], \"Cannot withdraw more than available\");\r\n            }\r\n            v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\r\n\r\n            SwapFeeInfo memory swapFeeInfo;\r\n            swapFeeInfo.tokens = new address[](fees.length);\r\n            swapFeeInfo.swapFees = new uint256[](fees.length);\r\n            swapFeeInfo.adminFeeRate = self.adminFee;\r\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\r\n                uint256 difference = idealBalance.difference(balances1[i]);\r\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\r\n\r\n                swapFeeInfo.adminFee = fees[i].mul(swapFeeInfo.adminFeeRate).div(FEE_DENOMINATOR);\r\n\r\n                self.balances[i] = balances1[i].sub(swapFeeInfo.adminFee);\r\n                balances1[i] = balances1[i].sub(fees[i]);\r\n\r\n                swapFeeInfo.tokens[i] = address(pooledTokens[i]);\r\n                swapFeeInfo.swapFees[i] = fees[i].sub(swapFeeInfo.adminFee);\r\n            }\r\n\r\n            emit SwapFee(swapFeeInfo.tokens, swapFeeInfo.swapFees);\r\n\r\n            v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\r\n        }\r\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\r\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\r\n        tokenAmount = tokenAmount.add(1);\r\n\r\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\r\n\r\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\r\n\r\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n            pooledTokens[i].safeTransfer(receiver, amounts[i]);\r\n        }\r\n\r\n        emit RemoveLiquidityImbalance(receiver, amounts, fees, v.d1, v.totalSupply.sub(tokenAmount));\r\n\r\n        return tokenAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice withdraw all admin fees to a given address\r\n     * @param self Swap struct to withdraw fees from\r\n     * @param to Address to send the fees to\r\n     */\r\n    function withdrawAdminFees(Swap storage self, address to) external returns (uint256[] memory) {\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n        uint256[] memory amounts = new uint256[](pooledTokens.length);\r\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n            IERC20 token = pooledTokens[i];\r\n            uint256 balance = token.balanceOf(address(this)).sub(self.balances[i]);\r\n            amounts[i] = balance;\r\n            if (balance != 0) {\r\n                token.safeTransfer(to, balance);\r\n            }\r\n        }\r\n        return amounts;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the admin fee\r\n     * @dev adminFee cannot be higher than 100% of the swap fee\r\n     * @param self Swap struct to update\r\n     * @param newAdminFee new admin fee to be applied on future transactions\r\n     */\r\n    function setAdminFee(Swap storage self, uint256 newAdminFee) external {\r\n        require(newAdminFee <= MAX_ADMIN_FEE, \"Fee is too high\");\r\n        self.adminFee = newAdminFee;\r\n\r\n        emit NewAdminFee(newAdminFee);\r\n    }\r\n\r\n    /**\r\n     * @notice update the swap fee\r\n     * @dev fee cannot be higher than 1% of each swap\r\n     * @param self Swap struct to update\r\n     * @param newSwapFee new swap fee to be applied on future transactions\r\n     */\r\n    function setSwapFee(Swap storage self, uint256 newSwapFee) external {\r\n        require(newSwapFee <= MAX_SWAP_FEE, \"Fee is too high\");\r\n        self.swapFee = newSwapFee;\r\n\r\n        emit NewSwapFee(newSwapFee);\r\n    }\r\n}\r\n"
    },
    "contracts/utils/TransferHelper.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Library for safely executing transfers and approvals of ERC20 tokens and ETH.\r\n */\r\nlibrary TransferHelper {\r\n    /**\r\n     * @dev Safely approves `value` tokens for `to` by calling the `approve` function on `token`.\r\n     * @param token The address of the ERC20 token.\r\n     * @param to The address to approve tokens for.\r\n     * @param value The number of tokens to approve.\r\n     */\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: APPROVE_FAILED\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `value` tokens to `to` by calling the `transfer` function on `token`.\r\n     * @param token The address of the ERC20 token.\r\n     * @param to The address to transfer tokens to.\r\n     * @param value The number of tokens to transfer.\r\n     */\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FAILED\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `value` tokens from `from` to `to` by calling the `transferFrom` function on `token`.\r\n     * @param token The address of the ERC20 token.\r\n     * @param from The address to transfer tokens from.\r\n     * @param to The address to transfer tokens to.\r\n     * @param value The number of tokens to transfer.\r\n     */\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FROM_FAILED\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `value` ETH to `to`.\r\n     * @param to The address to transfer ETH to.\r\n     * @param value The amount of ETH to transfer.\r\n     */\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success, ) = to.call{ value: value }(new bytes(0));\r\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\r\n    }\r\n}\r\n"
    },
    "contracts/utils/UQ112x112.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\n\r\n// range: [0, 2**112 - 1]\r\n// resolution: 1 / 2**112\r\n\r\nlibrary UQ112x112 {\r\n    uint224 constant Q112 = 2 ** 112;\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 y) internal pure returns (uint224 z) {\r\n        z = uint224(y) * Q112; // never overflows\r\n    }\r\n\r\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\r\n        z = x / uint224(y);\r\n    }\r\n}\r\n"
    },
    "contracts/VolatilePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nimport \"./lib/PairERC20.sol\";\r\nimport { IVolatilePair } from \"./interface/IPair.sol\";\r\n\r\nimport \"./utils/UQ112x112.sol\";\r\nimport \"./utils/ERC20Call.sol\";\r\nimport \"./utils/Math.sol\";\r\n\r\nimport \"./interface/IPairCallee.sol\";\r\nimport \"./interface/IPairFactory.sol\";\r\n\r\n/**\r\n * @title VolatilePair\r\n * @dev This contract implements the VolatilePair interface and inherits from the PairERC20 contract.\r\n * It also uses the Initializable contract from the OpenZeppelin library.\r\n */\r\ncontract VolatilePair is Initializable, PairERC20, IVolatilePair {\r\n    using SafeMath for uint256;\r\n    using UQ112x112 for uint224;\r\n    using ERC20Call for address;\r\n\r\n    // Minimum liquidity required to add to the pool\r\n    uint256 public constant MINIMUM_LIQUIDITY = 10**3;\r\n    // Selector for transfer function\r\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\r\n\r\n    // Address of the factory that created the pair\r\n    address public factory;\r\n    // Address of token0\r\n    address public override token0;\r\n    // Address of token1\r\n    address public override token1;\r\n\r\n    // Reserve of token0\r\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\r\n    // Reserve of token1\r\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\r\n    // Block timestamp of the last liquidity event\r\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\r\n\r\n    uint256 public price0CumulativeLast;\r\n    uint256 public price1CumulativeLast;\r\n    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\r\n\r\n    // This variable is used to prevent reentrancy attacks\r\n    uint256 private unlocked;\r\n\r\n    // The type of the pair, 1 for volatile pair\r\n    uint8 public constant override PAIR_TYPE = 1;\r\n\r\n    // Whether or not the pair requires authorization\r\n    bool public constant override AUTH = false;\r\n\r\n    // The denominator used for calculating fees\r\n    uint256 public constant FEE_DENOMINATOR = 10**10;\r\n\r\n    // The maximum swap fee rate\r\n    uint256 public constant MAX_SWAP_FEE = 10**8;\r\n\r\n    // The maximum admin fee rate\r\n    uint256 public constant MAX_ADMIN_FEE = 10**10;\r\n\r\n    // The current swap fee rate\r\n    uint256 public swapFeeRate;\r\n\r\n    // The current admin fee rate\r\n    uint256 public adminFeeRate;\r\n\r\n    // The total admin fee for token0\r\n    uint256 public totalAdminFee0;\r\n\r\n    // The total admin fee for token1\r\n    uint256 public totalAdminFee1;\r\n\r\n    /**\r\n     * @dev Emitted when liquidity is added to the pool\r\n     * @param sender The address of the sender\r\n     * @param amount0 The amount of token0 added\r\n     * @param amount1 The amount of token1 added\r\n     */\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n\r\n    /**\r\n     * @dev Emitted when liquidity is removed from the pool\r\n     * @param sender The address of the sender\r\n     * @param amount0 The amount of token0 removed\r\n     * @param amount1 The amount of token1 removed\r\n     * @param to The address that receives the tokens\r\n     */\r\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\r\n\r\n    /**\r\n     * @dev Emitted when a swap occurs\r\n     * @param sender The address of the sender\r\n     * @param amount0In The amount of token0 being swapped in\r\n     * @param amount1In The amount of token1 being swapped in\r\n     * @param amount0Out The amount of token0 being swapped out\r\n     * @param amount1Out The amount of token1 being swapped out\r\n     * @param to The address that receives the swapped tokens\r\n     */\r\n    event Swap(\r\n        address indexed sender,\r\n        uint256 amount0In,\r\n        uint256 amount1In,\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address indexed to\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the swap fee rate is updated\r\n     * @param tokens The addresses of the tokens in the pair\r\n     * @param swapFees The new swap fee rates for each token\r\n     */\r\n    event SwapFee(address[] tokens, uint256[] swapFees);\r\n\r\n    /**\r\n     * @dev Emitted when the reserves are synced\r\n     * @param reserve0 The reserve of token0\r\n     * @param reserve1 The reserve of token1\r\n     */\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    /**\r\n     * @dev Emitted when admin fees are claimed\r\n     * @param token0 The address of token0\r\n     * @param token1 The address of token1\r\n     * @param amount0 The amount of token0 claimed\r\n     * @param amount1 The amount of token1 claimed\r\n     */\r\n    event ClaimFees(address token0, address token1, uint256 amount0, uint256 amount1);\r\n\r\n    /**\r\n     * @dev Emitted when the swap fee rate is updated\r\n     * @param oldSwapFeeRate The old swap fee rate\r\n     * @param newSwapFeeRate The new swap fee rate\r\n     */\r\n    event SetSwapFeeRate(uint256 oldSwapFeeRate, uint256 newSwapFeeRate);\r\n\r\n    /**\r\n     * @dev Emitted when the admin fee rate is updated\r\n     * @param oldAdminFeeRate The old admin fee rate\r\n     * @param newAdminFeeRate The new admin fee rate\r\n     */\r\n    event SetAdminFeeRate(uint256 oldAdminFeeRate, uint256 newAdminFeeRate);\r\n\r\n    /**\r\n     * @dev Initializes the VolatilePair contract\r\n     * @param _tokens The addresses of the tokens in the pair\r\n     * @param _data The encoded swap fee rate and admin fee rate\r\n     */\r\n    function initialize(address[] memory _tokens, bytes memory _data) external override initializer {\r\n        factory = msg.sender;\r\n        unlocked = 1;\r\n        require(_tokens.length == 2, \"VolatilePair: This type of pair must have only two tokens when created\");\r\n        require(_tokens[0] != _tokens[1], \"VolatilePair: Token cannot be the same\");\r\n        (token0, token1) = (_tokens[0], _tokens[1]);\r\n        (uint256 _swapfeeRate, uint256 _adminFeeRate) = abi.decode(_data, (uint256, uint256));\r\n\r\n        require(_swapfeeRate <= MAX_SWAP_FEE, \"VolatilePair: SwapFee is greater than the maximum value\");\r\n        require(_adminFeeRate <= MAX_ADMIN_FEE, \"VolatilePair: AdminFee is greater than the maximum value\");\r\n        (swapFeeRate, adminFeeRate) = (_swapfeeRate, _adminFeeRate);\r\n\r\n        _initialize(\r\n            string(abi.encodePacked(\"dForce AMM Volatile - \", _tokens[0].callSymbol(), \"-\", _tokens[1].callSymbol())),\r\n            string(abi.encodePacked(\"vAMM-\", _tokens[0].callSymbol(), \"-\", _tokens[1].callSymbol()))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to prevent reentrancy\r\n     */\r\n    modifier lock() {\r\n        require(unlocked == 1, \"VolatilePair: LOCKED\");\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to restrict access to only the manager\r\n     */\r\n    modifier onlyManager() {\r\n        require(msg.sender == IPairFactory(factory).manager(), \"VolatilePair: not manager\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the tokens in the pair\r\n     */\r\n    function tokens() external view override returns (address[] memory) {\r\n        return _tokens();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the reserves and the timestamp of the last block when they were updated\r\n     */\r\n    function getReserves()\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            uint112,\r\n            uint112,\r\n            uint32\r\n        )\r\n    {\r\n        return _getReserves();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the real balance of each token in the pair, excluding the admin fee\r\n     */\r\n    function getRealBalanceOf() external view override returns (uint256, uint256) {\r\n        return _getRealBalanceOf();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of output tokens given an input amount of a token\r\n     * @param _from The address of the input token\r\n     * @param _to The address of the output token\r\n     * @param _amount The input amount of the token\r\n     */\r\n    function getAmountOut(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external view override returns (uint256) {\r\n        _to;\r\n        (uint256 _reserveA, uint256 _reserveB) = _from == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n        return _getAmountOut(_amount, _reserveA, _reserveB);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the tokens in the pair\r\n     */\r\n    function _tokens() internal view returns (address[] memory _tokenList) {\r\n        _tokenList = new address[](2);\r\n        _tokenList[0] = token0;\r\n        _tokenList[1] = token1;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the reserves and the timestamp of the last block when they were updated\r\n     */\r\n    function _getReserves()\r\n        internal\r\n        view\r\n        returns (\r\n            uint112 _reserve0,\r\n            uint112 _reserve1,\r\n            uint32 _blockTimestampLast\r\n        )\r\n    {\r\n        _reserve0 = reserve0;\r\n        _reserve1 = reserve1;\r\n        _blockTimestampLast = blockTimestampLast;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the real balance of each token in the pair, excluding the admin fee\r\n     */\r\n    function _getRealBalanceOf() internal view returns (uint256, uint256) {\r\n        return (\r\n            IERC20(token0).balanceOf(address(this)).sub(totalAdminFee0),\r\n            IERC20(token1).balanceOf(address(this)).sub(totalAdminFee1)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of output tokens given an input amount of a token\r\n     * @param _amountIn The input amount of the token\r\n     * @param _reserveIn The reserve of the input token\r\n     * @param _reserveOut The reserve of the output token\r\n     */\r\n    function _getAmountOut(\r\n        uint256 _amountIn,\r\n        uint256 _reserveIn,\r\n        uint256 _reserveOut\r\n    ) internal view returns (uint256 _amountOut) {\r\n        require(_amountIn > 0, \"VolatilePair: INSUFFICIENT_INPUT_AMOUNT\");\r\n        require(_reserveIn > 0 && _reserveOut > 0, \"VolatilePair: INSUFFICIENT_LIQUIDITY\");\r\n        uint256 _amountInWithFee = _amountIn.mul(FEE_DENOMINATOR - swapFeeRate);\r\n        uint256 _numerator = _amountInWithFee.mul(_reserveOut);\r\n        uint256 _denominator = _reserveIn.mul(FEE_DENOMINATOR).add(_amountInWithFee);\r\n        _amountOut = _numerator / _denominator;\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers tokens\r\n     * @param _token The address of the token to transfer\r\n     * @param _to The address to transfer the tokens to\r\n     * @param _value The amount of tokens to transfer\r\n     */\r\n    function _safeTransfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 _value\r\n    ) private {\r\n        (bool _success, bytes memory _data) = _token.call(abi.encodeWithSelector(SELECTOR, _to, _value));\r\n        require(_success && (_data.length == 0 || abi.decode(_data, (bool))), \"VolatilePair: TRANSFER_FAILED\");\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the reserves and price accumulators for the pair\r\n     * @param _balance0 The current balance of token0 in the pair\r\n     * @param _balance1 The current balance of token1 in the pair\r\n     * @param _reserve0 The current reserve of token0 in the pair\r\n     * @param _reserve1 The current reserve of token1 in the pair\r\n     */\r\n    function _update(\r\n        uint256 _balance0,\r\n        uint256 _balance1,\r\n        uint112 _reserve0,\r\n        uint112 _reserve1\r\n    ) private {\r\n        require(_balance0 <= uint112(-1) && _balance1 <= uint112(-1), \"VolatilePair: OVERFLOW\");\r\n        uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\r\n        uint32 _timeElapsed = _blockTimestamp - blockTimestampLast; // overflow is desired\r\n        if (_timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\r\n            // Calculate the price accumulators for token0 and token1\r\n            // * never overflows, and + overflow is desired\r\n            price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * _timeElapsed;\r\n            price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * _timeElapsed;\r\n        }\r\n        reserve0 = uint112(_balance0);\r\n        reserve1 = uint112(_balance1);\r\n        blockTimestampLast = _blockTimestamp;\r\n        emit Sync(reserve0, reserve1);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the admin fee for the pair\r\n     * @param _amountIn0 The input amount of token0\r\n     * @param _amountIn1 The input amount of token1\r\n     * @return _swapFee0 The swap fee for token0\r\n     * @return _swapFee1 The swap fee for token1\r\n     */\r\n    function _updateAdminFee(uint256 _amountIn0, uint256 _amountIn1)\r\n        internal\r\n        returns (uint256 _swapFee0, uint256 _swapFee1)\r\n    {\r\n        uint256 _totalFee0 = _amountIn0.mul(swapFeeRate).div(FEE_DENOMINATOR);\r\n        uint256 _totalFee1 = _amountIn1.mul(swapFeeRate).div(FEE_DENOMINATOR);\r\n\r\n        {\r\n            uint256 _adminFee0 = _totalFee0.mul(adminFeeRate).div(FEE_DENOMINATOR);\r\n            uint256 _adminFee1 = _totalFee1.mul(adminFeeRate).div(FEE_DENOMINATOR);\r\n\r\n            _swapFee0 = _totalFee0 - _adminFee0;\r\n            _swapFee1 = _totalFee1 - _adminFee1;\r\n\r\n            totalAdminFee0 += _adminFee0;\r\n            totalAdminFee1 += _adminFee1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Mint liquidity tokens to the caller and add corresponding reserves\r\n     * @param _to The address to mint liquidity tokens to\r\n     * @return _liquidity The amount of liquidity tokens minted\r\n     */\r\n    function mint(address _to) external override lock returns (uint256 _liquidity) {\r\n        (uint112 _reserve0, uint112 _reserve1, ) = _getReserves(); // gas savings\r\n        (uint256 _balance0, uint256 _balance1) = _getRealBalanceOf();\r\n        uint256 _amount0 = _balance0.sub(_reserve0);\r\n        uint256 _amount1 = _balance1.sub(_reserve1);\r\n\r\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\r\n        if (_totalSupply == 0) {\r\n            _liquidity = Math.sqrt(_amount0.mul(_amount1)).sub(MINIMUM_LIQUIDITY);\r\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\r\n        } else {\r\n            _liquidity = Math.min(_amount0.mul(_totalSupply) / _reserve0, _amount1.mul(_totalSupply) / _reserve1);\r\n        }\r\n        require(_liquidity > 0, \"VolatilePair: INSUFFICIENT_LIQUIDITY_MINTED\");\r\n        _mint(_to, _liquidity);\r\n\r\n        _update(_balance0, _balance1, _reserve0, _reserve1);\r\n        emit Mint(msg.sender, _amount0, _amount1); // Emit a Mint event with the amount of token0 and token1 minted\r\n    }\r\n\r\n    /**\r\n     * @dev Burn liquidity tokens from the caller and remove corresponding reserves\r\n     * @param _to The address to send the tokens to\r\n     * @return _amount0 The amount of token0 burned\r\n     * @return _amount1 The amount of token1 burned\r\n     */\r\n    function burn(address _to) external override lock returns (uint256 _amount0, uint256 _amount1) {\r\n        (uint112 _reserve0, uint112 _reserve1, ) = _getReserves(); // gas savings\r\n        address _token0 = token0; // gas savings\r\n        address _token1 = token1; // gas savings\r\n        (uint256 _balance0, uint256 _balance1) = _getRealBalanceOf();\r\n        uint256 _liquidity = balanceOf[address(this)];\r\n\r\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\r\n        _amount0 = _liquidity.mul(_balance0) / _totalSupply; // using balances ensures pro-rata distribution\r\n        _amount1 = _liquidity.mul(_balance1) / _totalSupply; // using balances ensures pro-rata distribution\r\n        require(_amount0 > 0 && _amount1 > 0, \"VolatilePair: INSUFFICIENT_LIQUIDITY_BURNED\");\r\n        _burn(address(this), _liquidity);\r\n        _safeTransfer(_token0, _to, _amount0);\r\n        _safeTransfer(_token1, _to, _amount1);\r\n\r\n        (_balance0, _balance1) = _getRealBalanceOf();\r\n        _update(_balance0, _balance1, _reserve0, _reserve1);\r\n        emit Burn(msg.sender, _amount0, _amount1, _to); // Emit a Burn event with the amount of token0 and token1 burned and the address they were sent to\r\n    }\r\n\r\n    /**\r\n     * @dev Low-level function for swapping tokens\r\n     * @param _amount0Out The amount of token0 to receive\r\n     * @param _amount1Out The amount of token1 to receive\r\n     * @param _to The address to send the tokens to\r\n     * @param _data Additional data with no specified format, sent in call to `_to`\r\n     */\r\n    function swap(\r\n        uint256 _amount0Out,\r\n        uint256 _amount1Out,\r\n        address _to,\r\n        bytes calldata _data\r\n    ) external override lock {\r\n        require(_amount0Out > 0 || _amount1Out > 0, \"VolatilePair: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n        (uint112 _reserve0, uint112 _reserve1, ) = _getReserves(); // gas savings\r\n        require(_amount0Out < _reserve0 && _amount1Out < _reserve1, \"VolatilePair: INSUFFICIENT_LIQUIDITY\");\r\n\r\n        uint256 _balance0;\r\n        uint256 _balance1;\r\n        {\r\n            // scope for _token{0,1}, avoids stack too deep errors\r\n            address _token0 = token0;\r\n            address _token1 = token1;\r\n            require(_to != _token0 && _to != _token1, \"VolatilePair: INVALID_TO\");\r\n            if (_amount0Out > 0) _safeTransfer(_token0, _to, _amount0Out); // optimistically transfer tokens\r\n            if (_amount1Out > 0) _safeTransfer(_token1, _to, _amount1Out); // optimistically transfer tokens\r\n            if (_data.length > 0) IPairCallee(_to).hook(msg.sender, _amount0Out, _amount1Out, _data);\r\n            (_balance0, _balance1) = _getRealBalanceOf();\r\n        }\r\n        uint256 _amount0In = _balance0 > _reserve0 - _amount0Out ? _balance0 - (_reserve0 - _amount0Out) : 0;\r\n        uint256 _amount1In = _balance1 > _reserve1 - _amount1Out ? _balance1 - (_reserve1 - _amount1Out) : 0;\r\n        require(_amount0In > 0 || _amount1In > 0, \"VolatilePair: INSUFFICIENT_INPUT_AMOUNT\");\r\n        {\r\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\r\n            uint256 _balance0Adjusted = _balance0.mul(FEE_DENOMINATOR).sub(_amount0In.mul(swapFeeRate));\r\n            uint256 _balance1Adjusted = _balance1.mul(FEE_DENOMINATOR).sub(_amount1In.mul(swapFeeRate));\r\n            require(\r\n                _balance0Adjusted.mul(_balance1Adjusted) >= uint256(_reserve0).mul(_reserve1).mul(FEE_DENOMINATOR**2),\r\n                \"VolatilePair: K\"\r\n            );\r\n\r\n            //update totalAdminFee and balance\r\n            (uint256 _swapFee0, uint256 _swapFee1) = _updateAdminFee(_amount0In, _amount1In);\r\n\r\n            uint256[] memory _swapFees = new uint256[](2);\r\n            (_swapFees[0], _swapFees[1]) = (_swapFee0, _swapFee1);\r\n            emit SwapFee(_tokens(), _swapFees);\r\n        }\r\n\r\n        (_balance0, _balance1) = _getRealBalanceOf();\r\n        _update(_balance0, _balance1, _reserve0, _reserve1);\r\n\r\n        emit Swap(msg.sender, _amount0In, _amount1In, _amount0Out, _amount1Out, _to);\r\n    }\r\n\r\n    /**\r\n     * @dev Skim the excess tokens from the contract and send them to the specified address\r\n     * @param _to The address to send the excess tokens to\r\n     */\r\n    function skim(address _to) external override lock {\r\n        address _token0 = token0; // gas savings\r\n        address _token1 = token1; // gas savings\r\n        (uint256 _balance0, uint256 _balance1) = _getRealBalanceOf();\r\n        _safeTransfer(_token0, _to, _balance0.sub(reserve0)); // Transfer the excess token0 balance to the specified address\r\n        _safeTransfer(_token1, _to, _balance1.sub(reserve1)); // Transfer the excess token1 balance to the specified address\r\n    }\r\n\r\n    /**\r\n     * @dev Update reserves to match balances\r\n     */\r\n    function sync() external override lock {\r\n        (uint256 _balance0, uint256 _balance1) = _getRealBalanceOf();\r\n        _update(_balance0, _balance1, reserve0, reserve1);\r\n    }\r\n\r\n    /**\r\n     * @dev Claim admin fees\r\n     * @return _adminFees An array of admin fees\r\n     */\r\n    function claimFees() external override returns (uint256[] memory _adminFees) {\r\n        address _manager = IPairFactory(factory).manager();\r\n        _adminFees = new uint256[](2);\r\n\r\n        (_adminFees[0], _adminFees[1]) = (totalAdminFee0, totalAdminFee1);\r\n        (totalAdminFee0, totalAdminFee1) = (0, 0);\r\n\r\n        _safeTransfer(token0, _manager, _adminFees[0]);\r\n        _safeTransfer(token1, _manager, _adminFees[1]);\r\n        emit ClaimFees(token0, token1, _adminFees[0], _adminFees[1]);\r\n    }\r\n\r\n    /**\r\n     * @dev Set swap fee rate\r\n     * @param _swapFeeRate The new swap fee rate\r\n     */\r\n    function setSwapFeeRate(uint256 _swapFeeRate) external onlyManager {\r\n        require(_swapFeeRate <= MAX_SWAP_FEE, \"VolatilePair: SwapFee is greater than the maximum value\");\r\n        uint256 _old = swapFeeRate;\r\n        swapFeeRate = _swapFeeRate;\r\n        emit SetSwapFeeRate(_old, _swapFeeRate);\r\n    }\r\n\r\n    /**\r\n     * @dev Set admin fee rate\r\n     * @param _adminFeeRate The new admin fee rate\r\n     */\r\n    function setAdminFeeRate(uint256 _adminFeeRate) external onlyManager {\r\n        require(_adminFeeRate <= MAX_ADMIN_FEE, \"VolatilePair: AdminFee is greater than the maximum value\");\r\n        uint256 _old = adminFeeRate;\r\n        adminFeeRate = _adminFeeRate;\r\n        emit SetAdminFeeRate(_old, _adminFeeRate);\r\n    }\r\n}\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}