{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address master) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `master` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address master, bytes32 salt) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt, address deployer) internal pure returns (address predicted) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt) internal view returns (address predicted) {\n        return predictDeterministicAddress(master, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./UpgradeableProxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _setAdmin(admin_);\n    }\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _admin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\");\n        emit AdminChanged(_admin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external virtual ifAdmin {\n        _upgradeTo(newImplementation);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {\n        _upgradeTo(newImplementation);\n        Address.functionDelegateCall(newImplementation, data);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address adm) {\n        bytes32 slot = _ADMIN_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        bytes32 slot = _ADMIN_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newAdmin)\n        }\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/UpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./Proxy.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n *\n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\n * {TransparentUpgradeableProxy}.\n */\ncontract UpgradeableProxy is Proxy {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) public payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _setImplementation(_logic);\n        if(_data.length > 0) {\n            Address.functionDelegateCall(_logic, _data);\n        }\n    }\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal virtual {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\n\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/interface/IPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IPair {\n    function initialize(address[] memory _tokens, bytes memory _data) external;\n\n    function PAIR_TYPE() external view returns (uint8);\n\n    function AUTH() external view returns (bool);\n\n    function tokens() external view returns (address[] memory);\n\n    function getAmountOut(address _from, address _to, uint256 _amount) external view returns (uint256);\n}\n\ninterface IVolatilePair is IPair {\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n\n    function mint(address _to) external returns (uint256 _liquidity);\n\n    function burn(address _to) external returns (uint256 _amount0, uint256 _amount1);\n\n    function swap(uint256 _amount0Out, uint256 _amount1Out, address _to, bytes calldata _data) external;\n\n    function getRealBalanceOf() external view returns (uint256, uint256);\n\n    function skim(address _to) external;\n\n    function sync() external;\n\n    function claimFees() external returns (uint256[] memory _adminFees);\n}\n\ninterface IStablePair is IPair {\n    function lpToken() external view returns (address);\n\n    function calculateTokenAmount(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts,\n        bool _deposit\n    ) external view returns (uint256);\n\n    function calculateRemoveLiquidityOneToken(address _token, uint256 _liquidity) external view returns (uint256);\n\n    function calculateRemoveLiquidity(\n        address[] calldata _tokens,\n        uint256 _amount\n    ) external view returns (uint256[] memory);\n\n    function addLiquidity(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts,\n        uint256 _minToMint,\n        address _receiver,\n        uint256 _deadline\n    ) external returns (uint256);\n\n    function removeLiquidity(\n        uint256 _amount,\n        address[] calldata _tokens,\n        uint256[] calldata _minAmounts,\n        address _receiver,\n        uint256 _deadline\n    ) external returns (uint256[] memory);\n\n    function removeLiquidityOneToken(\n        uint256 _tokenAmount,\n        address _token,\n        uint256 _minAmount,\n        address _receiver,\n        uint256 _deadline\n    ) external returns (uint256);\n\n    function removeLiquidityImbalance(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts,\n        uint256 _maxBurnAmount,\n        address _receiver,\n        uint256 _deadline\n    ) external returns (uint256);\n\n    function swap(\n        address _tokenFrom,\n        address _tokenTo,\n        uint256 _dx,\n        uint256 _minDy,\n        address _receiver,\n        uint256 _deadline\n    ) external returns (uint256);\n}\n"
    },
    "contracts/interface/IPairCallee.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IPairCallee {\n    function hook(address sender, uint256 amountOut0, uint256 amountOut1, bytes calldata data) external;\n}\n"
    },
    "contracts/interface/IPairERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IPairERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/interface/IPairFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IPairFactory {\n    function allPairsLength() external view returns (uint256);\n\n    function isPair(address _pair) external view returns (bool);\n\n    function manager() external view returns (address);\n\n    function getPairAddress(address[] memory _tokens, uint8 _type) external view returns (address);\n\n    function pairTypeValues() external view returns (address[] memory);\n\n    function atPairType(uint256 _index) external view returns (address);\n\n    function createPair(address[] memory _tokens, uint8 _pairType, bytes memory _data) external returns (address _pair);\n}\n"
    },
    "contracts/interface/IPairRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface IPairRouter {\n    /**\n     * @dev Struct representing a route between two tokens through a pair contract\n     */\n    struct Route {\n        address from; // Address of the token to swap from\n        address to; // Address of the token to swap to\n        address pair; // Address of the pair contract to use for the swap\n    }\n\n    function PAIR_TYPE() external view returns (uint8);\n\n    function quoteAddLiquidity(\n        address[] calldata _tokens,\n        uint256[] calldata _amountDesireds\n    ) external view returns (uint256[] memory _amountIn, uint256 _liquidity);\n\n    function quoteRemoveLiquidity(\n        address[] calldata _tokens,\n        uint256 _liquidity\n    ) external view returns (uint256[] memory _amounts);\n\n    function addLiquidity(\n        address[] memory _tokens,\n        uint256[] memory _amountDesireds,\n        uint256[] memory _amountsMin,\n        uint256 _minLiquidity,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256[] memory _amounts, uint256 _liquidity);\n\n    function addLiquidityETH(\n        address[] memory _tokens,\n        uint256[] memory _amountDesireds,\n        uint256[] memory _amountMins,\n        uint256 _minLiquidity,\n        address _to,\n        uint256 _deadline\n    ) external payable returns (uint256[] memory _amounts, uint256 _liquidity);\n\n    function removeLiquidity(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256[] memory _amounts);\n\n    function removeLiquidityETH(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256[] memory _returns);\n\n    function removeLiquidityWithPermit(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256[] memory _amounts);\n\n    function removeLiquidityETHWithPermit(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256[] memory);\n\n    function swap(\n        Route memory _route,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address _to,\n        uint256 _deadline\n    ) external payable returns (uint256 _amountOut);\n}\n\ninterface IVolatileRouter is IPairRouter {\n    function getReserves(\n        address _pair,\n        address[] calldata _tokens\n    ) external view returns (uint256 _reserveA, uint256 _reserveB);\n}\n\ninterface IStablPairRouter is IPairRouter {\n    function quoteRemoveLiquidityOneToken(\n        address[] calldata _tokens,\n        address _token,\n        uint256 _liquidity\n    ) external view returns (uint256 _amount);\n\n    function quoteRemoveLiquidityImbalance(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external view returns (uint256 _liquidity);\n\n    function removeLiquidityOneToken(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        address _token,\n        uint256 _minAmount,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 _tokenAmount);\n\n    function removeLiquidityOneTokenETH(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        address _token,\n        uint256 _minAmount,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 _tokenAmount);\n\n    function removeLiquidityImbalance(\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256 _maxBurnAmount,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 _amount);\n\n    function removeLiquidityImbalanceETH(\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256 _maxBurnAmount,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 _amount);\n\n    function removeLiquidityOneTokenWithPermit(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        address _token,\n        uint256 _minAmount,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256 _tokenAmount);\n\n    function removeLiquidityOneTokenETHWithPermit(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        address _token,\n        uint256 _minAmount,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256 _tokenAmount);\n\n    function removeLiquidityImbalanceWithPermit(\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256 _maxBurnAmount,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256 _actualBurnAmount);\n\n    function removeLiquidityImbalanceETHWithPermit(\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256 _maxBurnAmount,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256 _actualBurnAmount);\n}\n"
    },
    "contracts/interface/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/// @title Interface for WETH9\ninterface IWETH {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n\n    function transfer(address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/lib/MyTransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\nimport \"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\";\n\ncontract MyTransparentUpgradeableProxy is TransparentUpgradeableProxy {\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) public TransparentUpgradeableProxy(_logic, admin_, _data) {}\n\n    receive() external payable override {}\n}\n"
    },
    "contracts/lib/PairERC20.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"../interface/IPairERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @title PairERC20\n * @dev Abstract contract that implements the IPairERC20 interface and provides basic ERC20 functionality.\n */\nabstract contract PairERC20 is IPairERC20 {\n    using SafeMath for uint256;\n\n    string public override name;\n    string public override symbol;\n    uint8 public constant override decimals = 18;\n\n    uint256 public override totalSupply;\n\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    bytes32 public override DOMAIN_SEPARATOR;\n\n    // keccak256(\"Permit(address owner,address spender,uint256 chainId, uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant override PERMIT_TYPEHASH =\n        0x576144ed657c8304561e56ca632e17751956250114636e8c01f64a7f2c6d98cf;\n\n    mapping(address => uint256) public override nonces;\n\n    /**\n     * @dev Initializes the contract by setting the name and symbol of the token, as well as the domain separator for the permit function.\n     * @param _name The name of the token.\n     * @param _symbol The symbol of the token.\n     */\n    function _initialize(string memory _name, string memory _symbol) internal {\n        name = _name;\n        symbol = _symbol;\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n\n    function _getChainId() internal pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n\n    /**\n     * @dev Mints new tokens and adds them to the total supply.\n     * @param to The address to which the new tokens will be minted.\n     * @param value The amount of tokens to be minted.\n     */\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    /**\n     * @dev Burns tokens and removes them from the total supply.\n     * @param from The address from which the tokens will be burned.\n     * @param value The amount of tokens to be burned.\n     */\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    /**\n     * @dev Approves a spender to transfer tokens on behalf of the owner.\n     * @param owner The address of the owner of the tokens.\n     * @param spender The address of the spender to be approved.\n     * @param value The amount of tokens to be approved for transfer.\n     */\n    function _approve(address owner, address spender, uint256 value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Transfers tokens from one address to another.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param value The amount of tokens to be transferred.\n     */\n    function _transfer(address from, address to, uint256 value) internal virtual {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Approves a spender to transfer tokens on behalf of the owner.\n     * @param spender The address of the spender to be approved.\n     * @param value The amount of tokens to be approved for transfer.\n     * @return A boolean indicating whether the approval was successful or not.\n     */\n    function approve(address spender, uint256 value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Transfers tokens from the caller's address to another address.\n     * @param to The address to which the tokens will be transferred.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean indicating whether the transfer was successful or not.\n     */\n    function transfer(address to, uint256 value) external override returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Transfers tokens from one address to another, on behalf of the owner.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean indicating whether the transfer was successful or not.\n     */\n    function transferFrom(address from, address to, uint256 value) external override returns (bool) {\n        if (allowance[from][msg.sender] != uint256(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Approves a spender to transfer tokens on behalf of the owner, using a permit signature.\n     * @param owner The address of the owner of the tokens.\n     * @param spender The address of the spender to be approved.\n     * @param value The amount of tokens to be approved for transfer.\n     * @param deadline The deadline by which the permit must be used.\n     * @param v The recovery byte of the permit signature.\n     * @param r The R component of the permit signature.\n     * @param s The S component of the permit signature.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(deadline >= block.timestamp, \"PairERC20: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, _getChainId(), value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"PairERC20: INVALID_SIGNATURE\");\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/lib/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{ value: msg.value }(implementation, data);\n    }\n}\n"
    },
    "contracts/PairFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport \"./interface/IPairFactory.sol\";\n\nimport \"./utils/Arrays.sol\";\nimport { IPair } from \"./interface/IPair.sol\";\n\n/**\n * @title PairFactory\n * @dev This contract is responsible for creating and managing pairs.\n */\ncontract PairFactory is IPairFactory, Initializable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Arrays for address[];\n\n    // Maximum swap fee and admin fee rates\n    uint256 public constant MAX_SWAP_FEE = 10 ** 8;\n    uint256 public constant MAX_ADMIN_FEE = 10 ** 10;\n\n    // Address of the current manager\n    address public override manager;\n\n    // Address of the pending manager\n    address public pendingManager;\n\n    // Default swap fee rate\n    uint256 public defSwapFeeRate;\n\n    // Default admin fee rate\n    uint256 public defAdminFeeRate;\n\n    // Mapping of pair addresses to boolean values indicating whether the pair exists\n    mapping(address => bool) public override isPair;\n\n    // Array of all pair addresses\n    address[] public allPairs;\n\n    // Set of pair implementation addresses\n    EnumerableSet.AddressSet internal pairImpls_;\n\n    //1: volatile pair, 2: stable pair, 3: yeild pair\n    // Struct to store pair implementation and authorization status\n    struct PairParams {\n        address impl; // Address of the pair implementation\n        bool auth; // Authorization status of the pair\n    }\n    // Mapping of pair type to pair implementation and authorization status\n    mapping(uint8 => PairParams) public pairParams;\n\n    /**\n     * @dev Event emitted when a new pair is created.\n     * @param tokens The tokens in the new pair.\n     * @param pairType The type of the new pair.\n     * @param pair The address of the new pair.\n     * @param pairsAmount The total number of pairs.\n     */\n    event PairCreated(address[] tokens, uint8 pairType, address pair, uint256 pairsAmount);\n\n    /**\n     * @dev Event emitted when a new manager is pending.\n     * @param manager The current manager.\n     * @param pendingManager The new pending manager.\n     */\n    event SetPendingManager(address manager, address pendingManager);\n\n    /**\n     * @dev Event emitted when the manager is changed.\n     * @param oldManager The old manager.\n     * @param newManager The new manager.\n     */\n    event ChangeManager(address oldManager, address newManager);\n\n    /**\n     * @dev Event emitted when the default swap fee rate is changed.\n     * @param oldDefSwapFeeRate The old default swap fee rate.\n     * @param newDefSwapFeeRate The new default swap fee rate.\n     */\n    event SetDefSwapFeeRate(uint256 oldDefSwapFeeRate, uint256 newDefSwapFeeRate);\n\n    /**\n     * @dev Event emitted when the default admin fee rate is changed.\n     * @param oldDefAdminFeeRate The old default admin fee rate.\n     * @param newDefAdminFeeRate The new default admin fee rate.\n     */\n    event SetDefAdminFeeRate(uint256 oldDefAdminFeeRate, uint256 newDefAdminFeeRate);\n\n    /**\n     * @dev Event emitted when a new pair type is added.\n     * @param impl The address of the pair implementation.\n     * @param pairType The type of the new pair.\n     * @param auth The authorization status of the new pair.\n     * @param oldImpl The address of the old pair implementation.\n     */\n    event SetPairType(address impl, uint8 pairType, bool auth, address oldImpl);\n\n    /**\n     * @dev Event emitted when a pair type is removed.\n     * @param impl The address of the pair implementation.\n     * @param pairType The type of the pair to be removed.\n     * @param auth The authorization status of the pair to be removed.\n     */\n    event RemovePairType(address impl, uint8 pairType, bool auth);\n\n    /**\n     * @dev Constructor function that initializes the default swap fee rate and default admin fee rate.\n     * @param _defSwapFeeRate The default swap fee rate.\n     * @param _defAdminFeeRate The default admin fee rate.\n     */\n    constructor(uint256 _defSwapFeeRate, uint256 _defAdminFeeRate) public {\n        initialize(_defSwapFeeRate, _defAdminFeeRate);\n    }\n\n    /**\n     * @dev Function that initializes the default swap fee rate, default admin fee rate, and manager.\n     * @param _defSwapFeeRate The default swap fee rate.\n     * @param _defAdminFeeRate The default admin fee rate.\n     */\n    function initialize(uint256 _defSwapFeeRate, uint256 _defAdminFeeRate) public initializer {\n        manager = msg.sender;\n        setDefSwapFeeRate(_defSwapFeeRate);\n        setDefAdminFeeRate(_defAdminFeeRate);\n    }\n\n    /**\n     * @dev Modifier that checks if the caller is the manager.\n     */\n    modifier onlyManager() {\n        require(msg.sender == manager, \"PairFactory: not manager\");\n        _;\n    }\n\n    /**\n     * @dev Function that returns the length of the allPairs array.\n     * @return The length of the allPairs array.\n     */\n    function allPairsLength() external view override returns (uint256) {\n        return allPairs.length;\n    }\n\n    /**\n     * @dev Function that checks if a pair with the given address exists.\n     * @param value The address of the pair to check.\n     * @return A boolean indicating whether the pair exists or not.\n     */\n    function containsPair(address value) external view returns (bool) {\n        return pairImpls_.contains(value);\n    }\n\n    /**\n     * @dev Function that returns an array of all pair implementation addresses.\n     * @return _pairImpls An array of all pair implementation addresses.\n     */\n    function pairTypeValues() external view override returns (address[] memory _pairImpls) {\n        uint256 _len = pairImpls_.length();\n        _pairImpls = new address[](_len);\n        for (uint256 i = 0; i < _len; i++) {\n            _pairImpls[i] = pairImpls_.at(i);\n        }\n        return _pairImpls;\n    }\n\n    /**\n     * @dev Function that returns the number of pair implementations.\n     * @return The number of pair implementations.\n     */\n    function pairTypeAmount() external view returns (uint256) {\n        return pairImpls_.length();\n    }\n\n    /**\n     * @dev Function that returns the pair implementation address at the given index.\n     * @param _index The index of the pair implementation address to return.\n     * @return The pair implementation address at the given index.\n     */\n    function atPairType(uint256 _index) external view override returns (address) {\n        return pairImpls_.at(_index);\n    }\n\n    /**\n     * @dev Function that returns the pair address for the given tokens and pair type.\n     * @param _tokens The tokens to create the pair with.\n     * @param _pairType The type of the pair to create.\n     * @return The pair address for the given tokens and pair type.\n     */\n    function getPairAddress(address[] memory _tokens, uint8 _pairType) public view override returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(_tokens.sortArray(), _pairType));\n        return Clones.predictDeterministicAddress(pairParams[_pairType].impl, salt);\n    }\n\n    /**\n     * @dev Function that creates a new pair with the given tokens and pair type.\n     * @param _tokens The tokens to create the pair with.\n     * @param _pairType The type of the pair to create.\n     * @param _data Additional data to pass to the pair's `initialize` function.\n     * @return _pair The address of the newly created pair.\n     */\n    function createPair(\n        address[] memory _tokens,\n        uint8 _pairType,\n        bytes memory _data\n    ) external override returns (address _pair) {\n        _tokens = _tokens.sortArray();\n        require(pairParams[_pairType].impl != address(0), \"PairFactory: No impl of this type\");\n        require(!isPair[getPairAddress(_tokens, _pairType)], \"PairFactory: Pair already exists\");\n\n        bytes32 salt = keccak256(abi.encodePacked(_tokens, _pairType));\n\n        PairParams memory _params = pairParams[_pairType];\n        if (_pairType == 1) {\n            _data = abi.encode(defSwapFeeRate, defAdminFeeRate);\n        }\n        if (_params.auth) {\n            require(manager == msg.sender, \"PairFactory: this pair type can only be created by manager\");\n        }\n        _pair = Clones.cloneDeterministic(_params.impl, salt);\n\n        IPair(_pair).initialize(_tokens, _data);\n\n        allPairs.push(_pair);\n        isPair[_pair] = true;\n\n        emit PairCreated(_tokens, _pairType, _pair, allPairs.length);\n    }\n\n    /**\n     * @dev Function that sets the pending manager address.\n     * @param _pendingManager The address of the pending manager.\n     */\n    function setPendingManager(address _pendingManager) external onlyManager {\n        require(manager != _pendingManager && pendingManager != _pendingManager, \"PairFactory: manager has been set\");\n\n        pendingManager = _pendingManager;\n\n        emit SetPendingManager(manager, _pendingManager);\n    }\n\n    /**\n     * @dev Function that accepts the pending manager address.\n     */\n    function acceptManager() external {\n        require(msg.sender == pendingManager, \"PairFactory: not pending fee manager\");\n        address _oldManager = manager;\n\n        manager = pendingManager;\n        pendingManager = address(0);\n\n        emit ChangeManager(_oldManager, manager);\n    }\n\n    /**\n     * @dev Function that sets the default swap fee rate.\n     * @param _defSwapFeeRate The new default swap fee rate.\n     */\n    function setDefSwapFeeRate(uint256 _defSwapFeeRate) public onlyManager {\n        require(_defSwapFeeRate <= MAX_SWAP_FEE, \"PairFactory: Over MAX_SWAP_FEE is not allowed\");\n\n        uint256 _oldDefSwapFeeRate = defSwapFeeRate;\n        require(_defSwapFeeRate != _oldDefSwapFeeRate, \"PairFactory: _defSwapFeeRate invalid\");\n\n        defSwapFeeRate = _defSwapFeeRate;\n\n        emit SetDefSwapFeeRate(_oldDefSwapFeeRate, _defSwapFeeRate);\n    }\n\n    /**\n     * @dev Function that sets the default admin fee rate.\n     * @param _defAdminFeeRate The new default admin fee rate.\n     */\n    function setDefAdminFeeRate(uint256 _defAdminFeeRate) public onlyManager {\n        require(_defAdminFeeRate <= MAX_ADMIN_FEE, \"PairFactory: Over MAX_ADMIN_FEE is not allowed\");\n\n        uint256 _oldDefAdminFeeRate = defAdminFeeRate;\n        require(_defAdminFeeRate != _oldDefAdminFeeRate, \"PairFactory: _defAdminFeeRate invalid\");\n\n        defAdminFeeRate = _defAdminFeeRate;\n\n        emit SetDefAdminFeeRate(_oldDefAdminFeeRate, _defAdminFeeRate);\n    }\n\n    /**\n     * @dev Function that adds a new pair type.\n     * @param _impl The address of the pair implementation.\n     */\n    function addPairType(address _impl) external onlyManager {\n        uint8 _type = IPair(_impl).PAIR_TYPE();\n        bool _auth = IPair(_impl).AUTH();\n\n        require(pairImpls_.add(_impl), \"PairFactory: This pair already exists\");\n\n        require(pairParams[_type].impl == address(0), \"PairFactory: This pair type already exists\");\n\n        pairParams[_type] = PairParams({ impl: _impl, auth: _auth });\n\n        emit SetPairType(_impl, _type, _auth, address(0));\n    }\n\n    /**\n     * @dev Function that removes a pair type.\n     * @param _impl The address of the pair implementation.\n     */\n    function removePairType(address _impl) external onlyManager {\n        require(pairImpls_.contains(_impl), \"PairFactory: This pair does not exist\");\n\n        uint8 _type = IPair(_impl).PAIR_TYPE();\n\n        pairImpls_.remove(_impl);\n        PairParams memory _old = pairParams[_type];\n        delete pairParams[_type];\n\n        emit RemovePairType(_impl, _type, _old.auth);\n    }\n}\n"
    },
    "contracts/Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"./utils/TransferHelper.sol\";\n\nimport \"./interface/IWETH.sol\";\nimport \"./interface/IPair.sol\";\nimport \"./interface/IPairRouter.sol\";\nimport \"./interface/IPairFactory.sol\";\n\n/**\n * @title Router contract\n * @dev This contract handles the routing of tokens in the dForce AMM ecosystem\n */\ncontract Router is Initializable {\n    using Address for address;\n    using TransferHelper for address;\n\n    /**\n     * @dev Struct to represent a route between two tokens\n     */\n    struct Route {\n        address from; // Address of the token to convert from\n        address to; // Address of the token to convert to\n        address pair; // Address of the pair contract that connects the two tokens\n    }\n\n    /**\n     * @dev Address of the factory contract\n     */\n    address public factory;\n\n    /**\n     * @dev Address of the WETH contract\n     */\n    IWETH internal weth_;\n\n    /**\n     * @dev Mapping of pair types to their respective router contracts\n     */\n    mapping(uint8 => address) internal pairTypes_;\n\n    /**\n     * @dev Event emitted when a pair type is set\n     */\n    event SetPairTypes(uint8 pairType, address router);\n\n    /**\n     * @dev Constructor function for the Router contract\n     * @param _factory Address of the factory contract\n     * @param _weth Address of the WETH contract\n     */\n    constructor(address _factory, address _weth) public {\n        initialize(_factory, _weth);\n    }\n\n    /**\n     * @dev Initializes the Router contract\n     * @param _factory Address of the factory contract\n     * @param _weth Address of the WETH contract\n     */\n    function initialize(address _factory, address _weth) public initializer {\n        factory = _factory;\n        weth_ = IWETH(_weth);\n    }\n\n    /**\n     * @dev Fallback function to receive ETH from WETH contract\n     */\n    receive() external payable {\n        assert(msg.sender == address(weth_)); // only accept ETH via fallback from the WETH contract\n    }\n\n    /**\n     * @dev Modifier to restrict access to only the manager\n     */\n    modifier onlyManager() {\n        require(msg.sender == IPairFactory(factory).manager(), \"Router: not manager\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if the given pair type is valid\n     * @param _pairType The pair type to check\n     */\n    modifier checkPairType(uint8 _pairType) {\n        require(pairTypes_[_pairType] != address(0), \"Router: invalid pair type\");\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the WETH contract\n     */\n    function weth() external view returns (address) {\n        return address(weth_);\n    }\n\n    /**\n     * @dev Returns the address of the router contract for a given pair type\n     * @param _pairType The pair type\n     */\n    function pairTypes(uint8 _pairType) external view returns (address) {\n        return pairTypes_[_pairType];\n    }\n\n    /**\n     * @dev Returns the amount of tokens that will be received for a given input amount and route\n     * @param _amountIn The input amount\n     * @param _routes The route to take\n     * @return _amounts The amounts of tokens that will be received\n     */\n    function _getAmountsOut(\n        uint256 _amountIn,\n        Route[] memory _routes\n    ) internal view returns (uint256[] memory _amounts) {\n        _amounts = new uint256[](_routes.length + 1);\n        _amounts[0] = _amountIn;\n\n        for (uint256 i = 0; i < _routes.length; i++)\n            _amounts[i + 1] = IPair(_routes[i].pair).getAmountOut(_routes[i].from, _routes[i].to, _amounts[i]);\n    }\n\n    /**\n     * @dev Returns the amount of tokens that will be received for a given input amount and route\n     * @param _amountIn The input amount\n     * @param _routes The route to take\n     */\n    function getAmountsOutPath(\n        uint256 _amountIn,\n        Route[] memory _routes\n    ) external view returns (uint256[] memory _amounts) {\n        _amounts = _getAmountsOut(_amountIn, _routes);\n    }\n\n    /**\n     * @dev Returns the amount of tokens that will be received for a given input amount and route\n     * @param _amountIn The input amount\n     * @param _routes The route to take\n     */\n    function getAmountsOut(uint256 _amountIn, Route[] memory _routes) external view returns (uint256) {\n        require(_routes.length >= 1, \"Router: INVALID_PATH\");\n        uint256[] memory _amounts = _getAmountsOut(_amountIn, _routes);\n        return _amounts[_amounts.length - 1];\n    }\n\n    /**\n     * @dev Returns the address of the pair for the given tokens and pair type\n     * @param _tokens The tokens to get the pair address for\n     * @param _type The pair type\n     * @return _pair The address of the pair\n     * @return _has Whether or not the pair exists\n     */\n    function pairFor(address[] memory _tokens, uint8 _type) external view returns (address _pair, bool _has) {\n        _pair = IPairFactory(factory).getPairAddress(_tokens, _type);\n        _has = IPairFactory(factory).isPair(_pair);\n    }\n\n    /**\n     * @dev Returns the reserves of the volatile pair for the given tokens\n     * @param _tokens The tokens to get the reserves for\n     * @return _reserveA The reserve of token A\n     * @return _reserveB The reserve of token B\n     */\n    function getReserves(address[] memory _tokens) external view returns (uint256 _reserveA, uint256 _reserveB) {\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, 1);\n        if (IPairFactory(factory).isPair(_pair))\n            (_reserveA, _reserveB) = IVolatileRouter(pairTypes_[1]).getReserves(_pair, _tokens);\n    }\n\n    /**\n     * @dev Returns the amount of tokens required to add liquidity to a given pair\n     * @param _pairType The pair type\n     * @param _tokens The tokens to add liquidity for\n     * @param _amountDesireds The desired amounts of each token to add liquidity for\n     */\n    function quoteAddLiquidity(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256[] memory _amountDesireds\n    ) external view returns (uint256[] memory _amountIn, uint256 liquidity) {\n        address _router = pairTypes_[_pairType];\n        bytes memory _returns = _router.functionStaticCall(\n            abi.encodeWithSelector(IPairRouter.quoteAddLiquidity.selector, _tokens, _amountDesireds)\n        );\n        (_amountIn, liquidity) = abi.decode(_returns, (uint256[], uint256));\n    }\n\n    /**\n     * @dev Returns the amount of tokens that will be received when removing liquidity from a given pair\n     * @param _pairType The pair type\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     */\n    function quoteRemoveLiquidity(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256 _liquidity\n    ) external view returns (uint256[] memory _amounts) {\n        address _router = pairTypes_[_pairType];\n        bytes memory _returns = _router.functionStaticCall(\n            abi.encodeWithSelector(IPairRouter.quoteRemoveLiquidity.selector, _tokens, _liquidity)\n        );\n        _amounts = abi.decode(_returns, (uint256[]));\n    }\n\n    /**\n     * @dev Returns the amount of a specific token that will be received when removing liquidity from a given pair\n     * @param _pairType The pair type\n     * @param _tokens The tokens to remove liquidity for\n     * @param _token The token to receive\n     * @param _liquidity The amount of liquidity to remove\n     */\n    function quoteRemoveLiquidityOneToken(\n        uint8 _pairType,\n        address[] calldata _tokens,\n        address _token,\n        uint256 _liquidity\n    ) external view returns (uint256 _amount) {\n        address _router = pairTypes_[_pairType];\n        bytes memory _returns = _router.functionStaticCall(\n            abi.encodeWithSelector(IStablPairRouter.quoteRemoveLiquidityOneToken.selector, _tokens, _token, _liquidity)\n        );\n        _amount = abi.decode(_returns, (uint256));\n    }\n\n    /**\n     * @dev Returns the amount of tokens that will be removed when removing liquidity from a given pair\n     * @param _pairType The pair type\n     * @param _tokens The tokens to remove liquidity for\n     * @param _amounts The desired amounts of each token to remove liquidity for\n     */\n    function quoteRemoveLiquidityImbalance(\n        uint8 _pairType,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external view returns (uint256 _amount) {\n        address _router = pairTypes_[_pairType];\n        bytes memory _returns = _router.functionStaticCall(\n            abi.encodeWithSelector(IStablPairRouter.quoteRemoveLiquidityImbalance.selector, _tokens, _amounts)\n        );\n        _amount = abi.decode(_returns, (uint256));\n    }\n\n    /**\n     * @dev Adds liquidity to a given pair\n     * @param _pairType The pair type\n     * @param _tokens The tokens to add liquidity for\n     * @param _amountDesireds The desired amounts of each token to add liquidity for\n     * @param _amountsMin The minimum amounts of each token to add liquidity for\n     * @param _minLiquidity The minimum liquidity to add\n     * @param _to The address to send the liquidity to\n     * @param _deadline The deadline for the transaction\n     * @return _amounts The amounts of tokens added\n     * @return _liquidity The amount of liquidity added\n     */\n    function addLiquidity(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256[] memory _amountDesireds,\n        uint256[] memory _amountsMin,\n        uint256 _minLiquidity,\n        address _to,\n        uint256 _deadline\n    ) external checkPairType(_pairType) returns (uint256[] memory _amounts, uint256 _liquidity) {\n        (_amounts, _liquidity) = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IPairRouter.addLiquidity.selector,\n                    _tokens,\n                    _amountDesireds,\n                    _amountsMin,\n                    _minLiquidity,\n                    _to,\n                    _deadline\n                )\n            ),\n            (uint256[], uint256)\n        );\n    }\n\n    /**\n     * @dev Adds liquidity to a given pair with ETH\n     * @param _pairType The pair type\n     * @param _tokens The tokens to add liquidity for\n     * @param _amountDesireds The desired amounts of each token to add liquidity for\n     * @param _amountsMin The minimum amounts of each token to add liquidity for\n     * @param _minLiquidity The minimum liquidity to add\n     * @param _to The address to send the liquidity to\n     * @param _deadline The deadline for the transaction\n     * @return _amounts The amounts of tokens added\n     * @return _liquidity The amount of liquidity added\n     */\n    function addLiquidityETH(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256[] memory _amountDesireds,\n        uint256[] memory _amountsMin,\n        uint256 _minLiquidity,\n        address _to,\n        uint256 _deadline\n    ) external payable checkPairType(_pairType) returns (uint256[] memory _amounts, uint256 _liquidity) {\n        (_amounts, _liquidity) = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IPairRouter.addLiquidityETH.selector,\n                    _tokens,\n                    _amountDesireds,\n                    _amountsMin,\n                    _minLiquidity,\n                    _to,\n                    _deadline\n                )\n            ),\n            (uint256[], uint256)\n        );\n    }\n\n    /**\n     * @dev Removes liquidity from a given pair\n     * @param _pairType The pair type\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _amountsMin The minimum amounts of each token to receive\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline for the transaction\n     * @return _amounts The amounts of tokens received\n     */\n    function removeLiquidity(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline\n    ) external checkPairType(_pairType) returns (uint256[] memory _amounts) {\n        _amounts = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IPairRouter.removeLiquidity.selector,\n                    _tokens,\n                    _liquidity,\n                    _amountsMin,\n                    _to,\n                    _deadline\n                )\n            ),\n            (uint256[])\n        );\n    }\n\n    /**\n     * @dev Removes liquidity from a given pair with ETH\n     * @param _pairType The pair type\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _amountsMin The minimum amounts of each token to receive\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline for the transaction\n     * @return _amounts The amounts of tokens received\n     */\n    function removeLiquidityETH(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline\n    ) external checkPairType(_pairType) returns (uint256[] memory _amounts) {\n        _amounts = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IPairRouter.removeLiquidityETH.selector,\n                    _tokens,\n                    _liquidity,\n                    _amountsMin,\n                    _to,\n                    _deadline\n                )\n            ),\n            (uint256[])\n        );\n    }\n\n    /**\n     * @dev Removes liquidity for a single token from a given pair\n     * @param _pairType The pair type\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _token The token to receive\n     * @param _minAmount The minimum amount of token to receive\n     * @param _to The address to send the token to\n     * @param _deadline The deadline for the transaction\n     * @return _amount The amount of token received\n     */\n    function removeLiquidityOneToken(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256 _liquidity,\n        address _token,\n        uint256 _minAmount,\n        address _to,\n        uint256 _deadline\n    ) external checkPairType(_pairType) returns (uint256 _amount) {\n        _amount = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IStablPairRouter.removeLiquidityOneToken.selector,\n                    _tokens,\n                    _liquidity,\n                    _token,\n                    _minAmount,\n                    _to,\n                    _deadline\n                )\n            ),\n            (uint256)\n        );\n    }\n\n    /**\n     * @dev Removes liquidity for a single token from a given pair with ETH\n     * @param _pairType The pair type\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _token The token to receive\n     * @param _minAmount The minimum amount of token to receive\n     * @param _to The address to send the token to\n     * @param _deadline The deadline for the transaction\n     * @return _amount The amount of token received\n     */\n    function removeLiquidityOneTokenETH(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256 _liquidity,\n        address _token,\n        uint256 _minAmount,\n        address _to,\n        uint256 _deadline\n    ) external checkPairType(_pairType) returns (uint256 _amount) {\n        _amount = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IStablPairRouter.removeLiquidityOneTokenETH.selector,\n                    _tokens,\n                    _liquidity,\n                    _token,\n                    _minAmount,\n                    _to,\n                    _deadline\n                )\n            ),\n            (uint256)\n        );\n    }\n\n    /**\n     * @dev Removes liquidity from a given pair with an imbalance of tokens\n     * @param _pairType The pair type\n     * @param _tokens The tokens to remove liquidity for\n     * @param _amounts The amounts of each token to remove\n     * @param _maxBurnAmount The maximum amount of liquidity to remove\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline for the transaction\n     * @return _amount The amount of liquidity removed\n     */\n    function removeLiquidityImbalance(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256[] calldata _amounts,\n        uint256 _maxBurnAmount,\n        address _to,\n        uint256 _deadline\n    ) external checkPairType(_pairType) returns (uint256 _amount) {\n        _amount = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IStablPairRouter.removeLiquidityImbalance.selector,\n                    _tokens,\n                    _amounts,\n                    _maxBurnAmount,\n                    _to,\n                    _deadline\n                )\n            ),\n            (uint256)\n        );\n    }\n\n    /**\n     * @dev Removes liquidity from a given pair with an imbalance of ETH and tokens\n     * @param _pairType The type of pair\n     * @param _tokens The tokens to remove liquidity for\n     * @param _amounts The amounts of each token to remove\n     * @param _maxBurnAmount The maximum amount of liquidity to remove\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline for the transaction\n     * @return _amount The amount of liquidity removed\n     */\n    function removeLiquidityImbalanceETH(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256[] calldata _amounts,\n        uint256 _maxBurnAmount,\n        address _to,\n        uint256 _deadline\n    ) external checkPairType(_pairType) returns (uint256 _amount) {\n        _amount = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IStablPairRouter.removeLiquidityImbalanceETH.selector,\n                    _tokens,\n                    _amounts,\n                    _maxBurnAmount,\n                    _to,\n                    _deadline\n                )\n            ),\n            (uint256)\n        );\n    }\n\n    /**\n     * @dev Removes liquidity from a given pair with a permit\n     * @param _pairType The pair type\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _amountsMin The minimum amounts of each token to remove\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline for the transaction\n     * @param _approveMax Whether to approve the maximum amount\n     * @param _v The v value of the permit signature\n     * @param _r The r value of the permit signature\n     * @param _s The s value of the permit signature\n     * @return _amounts The amounts of tokens removed\n     */\n    function removeLiquidityWithPermit(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external checkPairType(_pairType) returns (uint256[] memory _amounts) {\n        _amounts = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IPairRouter.removeLiquidityWithPermit.selector,\n                    _tokens,\n                    _liquidity,\n                    _amountsMin,\n                    _to,\n                    _deadline,\n                    _approveMax,\n                    _v,\n                    _r,\n                    _s\n                )\n            ),\n            (uint256[])\n        );\n    }\n\n    /**\n     * @dev Removes liquidity from a given pair with a permit\n     * @param _pairType The pair type\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _amountsMin The minimum amounts of each token to remove\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline for the transaction\n     * @param _approveMax Whether to approve the maximum amount\n     * @param _v The v value of the permit signature\n     * @param _r The r value of the permit signature\n     * @param _s The s value of the permit signature\n     * @return _amounts The amounts of tokens removed\n     */\n    function removeLiquidityETHWithPermit(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external checkPairType(_pairType) returns (uint256[] memory _amounts) {\n        _amounts = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IPairRouter.removeLiquidityETHWithPermit.selector,\n                    _tokens,\n                    _liquidity,\n                    _amountsMin,\n                    _to,\n                    _deadline,\n                    _approveMax,\n                    _v,\n                    _r,\n                    _s\n                )\n            ),\n            (uint256[])\n        );\n    }\n\n    /**\n     * @dev Removes liquidity for a single token with a permit\n     * @param _pairType The type of pair\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _token The token to remove liquidity for\n     * @param _minAmount The minimum amount of tokens to remove\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline for the transaction\n     * @param _approveMax Whether to approve the maximum amount\n     * @param _v The v value of the permit signature\n     * @param _r The r value of the permit signature\n     * @param _s The s value of the permit signature\n     * @return _tokenAmount The amount of tokens removed\n     */\n    function removeLiquidityOneTokenWithPermit(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256 _liquidity,\n        address _token,\n        uint256 _minAmount,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256 _tokenAmount) {\n        require(pairTypes_[_pairType] != address(0), \"Router: invalid pair type\");\n        _tokenAmount = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IStablPairRouter.removeLiquidityOneTokenWithPermit.selector,\n                    _tokens,\n                    _liquidity,\n                    _token,\n                    _minAmount,\n                    _to,\n                    _deadline,\n                    _approveMax,\n                    _v,\n                    _r,\n                    _s\n                )\n            ),\n            (uint256)\n        );\n    }\n\n    /**\n     * @dev Removes liquidity for a single token with a permit\n     * @param _pairType The type of pair\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _token The token to remove liquidity for\n     * @param _minAmount The minimum amount of tokens to remove\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline for the transaction\n     * @param _approveMax Whether to approve the maximum amount\n     * @param _v The v value of the permit signature\n     * @param _r The r value of the permit signature\n     * @param _s The s value of the permit signature\n     * @return _tokenAmount The amount of tokens removed\n     */\n    function removeLiquidityOneTokenETHWithPermit(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256 _liquidity,\n        address _token,\n        uint256 _minAmount,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256 _tokenAmount) {\n        require(pairTypes_[_pairType] != address(0), \"Router: invalid pair type\");\n        _tokenAmount = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IStablPairRouter.removeLiquidityOneTokenETHWithPermit.selector,\n                    _tokens,\n                    _liquidity,\n                    _token,\n                    _minAmount,\n                    _to,\n                    _deadline,\n                    _approveMax,\n                    _v,\n                    _r,\n                    _s\n                )\n            ),\n            (uint256)\n        );\n    }\n\n    /**\n     * @dev Removes liquidity imbalance for multiple tokens with a permit\n     * @param _pairType The type of pair\n     * @param _tokens The tokens to remove liquidity for\n     * @param _amounts The amounts of tokens to remove\n     * @param _maxBurnAmount The maximum amount of liquidity to remove\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline for the transaction\n     * @param _approveMax Whether to approve the maximum amount\n     * @param _v The v value of the permit signature\n     * @param _r The r value of the permit signature\n     * @param _s The s value of the permit signature\n     * @return _actualBurnAmount The actual amount of liquidity removed\n     */\n    function removeLiquidityImbalanceWithPermit(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256 _maxBurnAmount,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external checkPairType(_pairType) returns (uint256 _actualBurnAmount) {\n        _actualBurnAmount = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IStablPairRouter.removeLiquidityImbalanceWithPermit.selector,\n                    _tokens,\n                    _amounts,\n                    _maxBurnAmount,\n                    _to,\n                    _deadline,\n                    _approveMax,\n                    _v,\n                    _r,\n                    _s\n                )\n            ),\n            (uint256)\n        );\n    }\n\n    /**\n     * @dev Removes liquidity imbalance for multiple tokens with a permit\n     * @param _pairType The type of pair\n     * @param _tokens The tokens to remove liquidity for\n     * @param _amounts The amounts of tokens to remove\n     * @param _maxBurnAmount The maximum amount of liquidity to remove\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline for the transaction\n     * @param _approveMax Whether to approve the maximum amount\n     * @param _v The v value of the permit signature\n     * @param _r The r value of the permit signature\n     * @param _s The s value of the permit signature\n     * @return _actualBurnAmount The actual amount of liquidity removed\n     */\n    function removeLiquidityImbalanceETHWithPermit(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256 _maxBurnAmount,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external checkPairType(_pairType) returns (uint256 _actualBurnAmount) {\n        _actualBurnAmount = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IStablPairRouter.removeLiquidityImbalanceETHWithPermit.selector,\n                    _tokens,\n                    _amounts,\n                    _maxBurnAmount,\n                    _to,\n                    _deadline,\n                    _approveMax,\n                    _v,\n                    _r,\n                    _s\n                )\n            ),\n            (uint256)\n        );\n    }\n\n    /**\n     * @dev Swaps tokens through multiple pairs\n     * @param _routes The routes to swap through\n     * @param _amountIn The amount of tokens to swap\n     * @param _amountOutMin The minimum amount of tokens to receive\n     * @param _to The address to send the swapped tokens to\n     * @param _deadline The deadline for the transaction\n     * @return _amountOut The amount of tokens received\n     */\n    function swap(\n        Route[] memory _routes,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 _amountOut) {\n        // Get the amounts of tokens to receive for each pair in the route\n        uint256[] memory _amounts = _getAmountsOut(_amountIn, _routes);\n        // Ensure that the amount of tokens received is greater than or equal to the minimum amount specified\n        require(_amounts[_amounts.length - 1] >= _amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n        // Transfer the input tokens from the sender to this contract\n        _routes[0].from.safeTransferFrom(msg.sender, address(this), _amountIn);\n        // Swap the tokens through each pair in the route\n        for (uint256 i = 0; i < _routes.length; i++) {\n            // Get the pair type for the current pair in the route\n            uint8 _pairType = IPair(_routes[i].pair).PAIR_TYPE();\n            // Set the receiver address for the current pair in the route\n            address _receiver = address(this);\n            if (i == _routes.length - 1) _receiver = _to;\n\n            // Call the swap function on the router contract for the current pair in the route\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IPairRouter.swap.selector,\n                    _routes[i],\n                    _amounts[i],\n                    _amounts[i + 1],\n                    _receiver,\n                    _deadline\n                )\n            );\n        }\n        // Set the amount of tokens received to the output amount\n        _amountOut = _amounts[_amounts.length - 1];\n    }\n\n    /**\n     * @dev Swaps ETH for tokens through multiple pairs\n     * @param _routes The routes to swap through\n     * @param _amountIn The amount of ETH to swap\n     * @param _amountOutMin The minimum amount of tokens to receive\n     * @param _to The address to send the swapped tokens to\n     * @param _deadline The deadline for the transaction\n     * @return _amountOut The amount of tokens received\n     */\n    function swapETH(\n        Route[] memory _routes,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address _to,\n        uint256 _deadline\n    ) external payable returns (uint256 _amountOut) {\n        // Get the amounts of tokens to receive for each pair in the route\n        uint256[] memory _amounts = _getAmountsOut(_amountIn, _routes);\n        // Ensure that the amount of tokens received is greater than or equal to the minimum amount specified\n        require(_amounts[_amounts.length - 1] >= _amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n\n        // If the input token is WETH, ensure that the amount of ETH sent is equal to the amount to swap\n        if (_routes[0].from == address(weth_)) {\n            require(msg.value == _amountIn, \"Router: msg.value is not equal to _amountIn\");\n            // Deposit the ETH into WETH\n            weth_.deposit{ value: msg.value }();\n        } else {\n            require(msg.value == 0, \"Router: msg.value is not equal to 0\");\n            // Transfer the input tokens from the sender to this contract\n            _routes[0].from.safeTransferFrom(msg.sender, address(this), _amountIn);\n        }\n\n        // Swap the tokens through each pair in the route\n        for (uint256 i = 0; i < _routes.length; i++) {\n            // Get the pair type for the current pair in the route\n            uint8 _pairType = IPair(_routes[i].pair).PAIR_TYPE();\n            // Set the receiver address for the current pair in the route\n            address _receiver = address(this);\n            if (i == _routes.length - 1 && _routes[i].to != address(weth_)) _receiver = _to;\n\n            // Call the swap function on the router contract for the current pair in the route\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IPairRouter.swap.selector,\n                    _routes[i],\n                    _amounts[i],\n                    _amounts[i + 1],\n                    _receiver,\n                    _deadline\n                )\n            );\n        }\n        // Set the amount of tokens received to the output amount\n        _amountOut = _amounts[_amounts.length - 1];\n\n        // If the output token is WETH, withdraw the WETH and transfer the ETH to the recipient\n        if (_routes[_routes.length - 1].to == address(weth_)) {\n            weth_.withdraw(_amountOut);\n            _to.safeTransferETH(_amountOut);\n        }\n    }\n\n    /**\n     * @dev Sets the pair types for the router contract\n     * @param _pairRouter The address of the pair router contract\n     */\n    function setPairTypes(address _pairRouter) external onlyManager {\n        // Get the pair type for the pair router contract\n        uint8 _pairType = IPairRouter(_pairRouter).PAIR_TYPE();\n        // Set the pair type for the router contract\n        pairTypes_[_pairType] = _pairRouter;\n        // Emit an event indicating that the pair types have been set\n        emit SetPairTypes(_pairType, _pairRouter);\n    }\n}\n"
    },
    "contracts/RouterBeta.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"./utils/TransferHelper.sol\";\n\nimport \"./interface/IWETH.sol\";\nimport \"./interface/IPair.sol\";\nimport \"./interface/IPairRouter.sol\";\nimport \"./interface/IPairFactory.sol\";\n\n/**\n * @title RouterBeta contract\n * @dev This contract handles the routing of tokens in the dForce AMM ecosystem\n */\ncontract RouterBeta is Initializable {\n    using Address for address;\n    using TransferHelper for address;\n\n    /**\n     * @dev Struct to represent a route between two tokens\n     */\n    struct Route {\n        address from; // Address of the token to convert from\n        address to; // Address of the token to convert to\n        address pair; // Address of the pair contract that connects the two tokens\n    }\n\n    /**\n     * @dev Address of the factory contract\n     */\n    address public factory;\n\n    /**\n     * @dev Address of the WETH contract\n     */\n    IWETH internal weth_;\n\n    /**\n     * @dev Mapping of pair types to their respective router contracts\n     */\n    mapping(uint8 => address) internal pairTypes_;\n\n    /**\n     * @dev Event emitted when a pair type is set\n     */\n    event SetPairTypes(uint8 pairType, address router);\n\n    /**\n     * @dev Constructor function for the Router contract\n     * @param _factory Address of the factory contract\n     * @param _weth Address of the WETH contract\n     */\n    constructor(address _factory, address _weth) public {\n        initialize(_factory, _weth);\n    }\n\n    /**\n     * @dev Initializes the Router contract\n     * @param _factory Address of the factory contract\n     * @param _weth Address of the WETH contract\n     */\n    function initialize(address _factory, address _weth) public initializer {\n        factory = _factory;\n        weth_ = IWETH(_weth);\n    }\n\n    /**\n     * @dev Fallback function to receive ETH from WETH contract\n     */\n    receive() external payable {\n        assert(msg.sender == address(weth_)); // only accept ETH via fallback from the WETH contract\n    }\n\n    /**\n     * @dev Modifier to restrict access to only the manager\n     */\n    modifier onlyManager() {\n        require(msg.sender == IPairFactory(factory).manager(), \"Router: not manager\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if the given pair type is valid\n     * @param _pairType The pair type to check\n     */\n    modifier checkPairType(uint8 _pairType) {\n        require(pairTypes_[_pairType] != address(0), \"Router: invalid pair type\");\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the WETH contract\n     */\n    function weth() external view returns (address) {\n        return address(weth_);\n    }\n\n    /**\n     * @dev Returns the address of the router contract for a given pair type\n     * @param _pairType The pair type\n     */\n    function pairTypes(uint8 _pairType) external view returns (address) {\n        return pairTypes_[_pairType];\n    }\n\n    /**\n     * @dev Returns the amount of tokens that will be received for a given input amount and route\n     * @param _amountIn The input amount\n     * @param _routes The route to take\n     * @return _amounts The amounts of tokens that will be received\n     */\n    function _getAmountsOut(\n        uint256 _amountIn,\n        Route[] memory _routes\n    ) internal view returns (uint256[] memory _amounts) {\n        _amounts = new uint256[](_routes.length + 1);\n        _amounts[0] = _amountIn;\n\n        for (uint256 i = 0; i < _routes.length; i++)\n            _amounts[i + 1] = IPair(_routes[i].pair).getAmountOut(_routes[i].from, _routes[i].to, _amounts[i]);\n    }\n\n    /**\n     * @dev Returns the amount of tokens that will be received for a given input amount and route\n     * @param _amountIn The input amount\n     * @param _routes The route to take\n     */\n    function getAmountsOutPath(\n        uint256 _amountIn,\n        Route[] memory _routes\n    ) external view returns (uint256[] memory _amounts) {\n        _amounts = _getAmountsOut(_amountIn, _routes);\n    }\n\n    /**\n     * @dev Returns the amount of tokens that will be received for a given input amount and route\n     * @param _amountIn The input amount\n     * @param _routes The route to take\n     */\n    function getAmountsOut(uint256 _amountIn, Route[] memory _routes) external view returns (uint256) {\n        require(_routes.length >= 1, \"Router: INVALID_PATH\");\n        uint256[] memory _amounts = _getAmountsOut(_amountIn, _routes);\n        return _amounts[_amounts.length - 1];\n    }\n\n    /**\n     * @dev Returns the address of the pair for the given tokens and pair type\n     * @param _tokens The tokens to get the pair address for\n     * @param _type The pair type\n     * @return _pair The address of the pair\n     * @return _has Whether or not the pair exists\n     */\n    function pairFor(address[] memory _tokens, uint8 _type) external view returns (address _pair, bool _has) {\n        _pair = IPairFactory(factory).getPairAddress(_tokens, _type);\n        _has = IPairFactory(factory).isPair(_pair);\n    }\n\n    /**\n     * @dev Returns the reserves of the volatile pair for the given tokens\n     * @param _tokens The tokens to get the reserves for\n     * @return _reserveA The reserve of token A\n     * @return _reserveB The reserve of token B\n     */\n    function getReserves(address[] memory _tokens) external view returns (uint256 _reserveA, uint256 _reserveB) {\n        address _pair = IPairFactory(factory).getPairAddress(_tokens, 1);\n        if (IPairFactory(factory).isPair(_pair))\n            (_reserveA, _reserveB) = IVolatileRouter(pairTypes_[1]).getReserves(_pair, _tokens);\n    }\n\n    /**\n     * @dev Returns the amount of tokens required to add liquidity to a given pair\n     * @param _pairType The pair type\n     * @param _tokens The tokens to add liquidity for\n     * @param _amountDesireds The desired amounts of each token to add liquidity for\n     */\n    function quoteAddLiquidity(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256[] memory _amountDesireds\n    ) external view returns (uint256[] memory _amountIn, uint256 liquidity) {\n        address _router = pairTypes_[_pairType];\n        bytes memory _returns = _router.functionStaticCall(\n            abi.encodeWithSelector(IPairRouter.quoteAddLiquidity.selector, _tokens, _amountDesireds)\n        );\n        (_amountIn, liquidity) = abi.decode(_returns, (uint256[], uint256));\n    }\n\n    /**\n     * @dev Returns the amount of tokens that will be received when removing liquidity from a given pair\n     * @param _pairType The pair type\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     */\n    function quoteRemoveLiquidity(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256 _liquidity\n    ) external view returns (uint256[] memory _amounts) {\n        address _router = pairTypes_[_pairType];\n        bytes memory _returns = _router.functionStaticCall(\n            abi.encodeWithSelector(IPairRouter.quoteRemoveLiquidity.selector, _tokens, _liquidity)\n        );\n        _amounts = abi.decode(_returns, (uint256[]));\n    }\n\n    /**\n     * @dev Returns the amount of a specific token that will be received when removing liquidity from a given pair\n     * @param _pairType The pair type\n     * @param _tokens The tokens to remove liquidity for\n     * @param _token The token to receive\n     * @param _liquidity The amount of liquidity to remove\n     */\n    function quoteRemoveLiquidityOneToken(\n        uint8 _pairType,\n        address[] calldata _tokens,\n        address _token,\n        uint256 _liquidity\n    ) external view returns (uint256 _amount) {\n        address _router = pairTypes_[_pairType];\n        bytes memory _returns = _router.functionStaticCall(\n            abi.encodeWithSelector(IStablPairRouter.quoteRemoveLiquidityOneToken.selector, _tokens, _token, _liquidity)\n        );\n        _amount = abi.decode(_returns, (uint256));\n    }\n\n    /**\n     * @dev Returns the amount of tokens that will be removed when removing liquidity from a given pair\n     * @param _pairType The pair type\n     * @param _tokens The tokens to remove liquidity for\n     * @param _amounts The desired amounts of each token to remove liquidity for\n     */\n    function quoteRemoveLiquidityImbalance(\n        uint8 _pairType,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external view returns (uint256 _amount) {\n        address _router = pairTypes_[_pairType];\n        bytes memory _returns = _router.functionStaticCall(\n            abi.encodeWithSelector(IStablPairRouter.quoteRemoveLiquidityImbalance.selector, _tokens, _amounts)\n        );\n        _amount = abi.decode(_returns, (uint256));\n    }\n\n    /**\n     * @dev Adds liquidity to a given pair\n     * @param _pairType The pair type\n     * @param _tokens The tokens to add liquidity for\n     * @param _amountDesireds The desired amounts of each token to add liquidity for\n     * @param _amountsMin The minimum amounts of each token to add liquidity for\n     * @param _minLiquidity The minimum liquidity to add\n     * @param _to The address to send the liquidity to\n     * @param _deadline The deadline for the transaction\n     * @return _amounts The amounts of tokens added\n     * @return _liquidity The amount of liquidity added\n     */\n    function addLiquidity(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256[] memory _amountDesireds,\n        uint256[] memory _amountsMin,\n        uint256 _minLiquidity,\n        address _to,\n        uint256 _deadline\n    ) external checkPairType(_pairType) returns (uint256[] memory _amounts, uint256 _liquidity) {\n        (_amounts, _liquidity) = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IPairRouter.addLiquidity.selector,\n                    _tokens,\n                    _amountDesireds,\n                    _amountsMin,\n                    _minLiquidity,\n                    _to,\n                    _deadline\n                )\n            ),\n            (uint256[], uint256)\n        );\n    }\n\n    /**\n     * @dev Removes liquidity from a given pair\n     * @param _pairType The pair type\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _amountsMin The minimum amounts of each token to receive\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline for the transaction\n     * @return _amounts The amounts of tokens received\n     */\n    function removeLiquidity(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline\n    ) external checkPairType(_pairType) returns (uint256[] memory _amounts) {\n        _amounts = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IPairRouter.removeLiquidity.selector,\n                    _tokens,\n                    _liquidity,\n                    _amountsMin,\n                    _to,\n                    _deadline\n                )\n            ),\n            (uint256[])\n        );\n    }\n\n    /**\n     * @dev Removes liquidity for a single token from a given pair\n     * @param _pairType The pair type\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _token The token to receive\n     * @param _minAmount The minimum amount of token to receive\n     * @param _to The address to send the token to\n     * @param _deadline The deadline for the transaction\n     * @return _amount The amount of token received\n     */\n    function removeLiquidityOneToken(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256 _liquidity,\n        address _token,\n        uint256 _minAmount,\n        address _to,\n        uint256 _deadline\n    ) external checkPairType(_pairType) returns (uint256 _amount) {\n        _amount = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IStablPairRouter.removeLiquidityOneToken.selector,\n                    _tokens,\n                    _liquidity,\n                    _token,\n                    _minAmount,\n                    _to,\n                    _deadline\n                )\n            ),\n            (uint256)\n        );\n    }\n\n    /**\n     * @dev Removes liquidity from a given pair with an imbalance of tokens\n     * @param _pairType The pair type\n     * @param _tokens The tokens to remove liquidity for\n     * @param _amounts The amounts of each token to remove\n     * @param _maxBurnAmount The maximum amount of liquidity to remove\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline for the transaction\n     * @return _amount The amount of liquidity removed\n     */\n    function removeLiquidityImbalance(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256[] calldata _amounts,\n        uint256 _maxBurnAmount,\n        address _to,\n        uint256 _deadline\n    ) external checkPairType(_pairType) returns (uint256 _amount) {\n        _amount = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IStablPairRouter.removeLiquidityImbalance.selector,\n                    _tokens,\n                    _amounts,\n                    _maxBurnAmount,\n                    _to,\n                    _deadline\n                )\n            ),\n            (uint256)\n        );\n    }\n\n    /**\n     * @dev Removes liquidity from a given pair with a permit\n     * @param _pairType The pair type\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _amountsMin The minimum amounts of each token to remove\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline for the transaction\n     * @param _approveMax Whether to approve the maximum amount\n     * @param _v The v value of the permit signature\n     * @param _r The r value of the permit signature\n     * @param _s The s value of the permit signature\n     * @return _amounts The amounts of tokens removed\n     */\n    function removeLiquidityWithPermit(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external checkPairType(_pairType) returns (uint256[] memory _amounts) {\n        _amounts = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IPairRouter.removeLiquidityWithPermit.selector,\n                    _tokens,\n                    _liquidity,\n                    _amountsMin,\n                    _to,\n                    _deadline,\n                    _approveMax,\n                    _v,\n                    _r,\n                    _s\n                )\n            ),\n            (uint256[])\n        );\n    }\n\n    /**\n     * @dev Removes liquidity for a single token with a permit\n     * @param _pairType The type of pair\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _token The token to remove liquidity for\n     * @param _minAmount The minimum amount of tokens to remove\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline for the transaction\n     * @param _approveMax Whether to approve the maximum amount\n     * @param _v The v value of the permit signature\n     * @param _r The r value of the permit signature\n     * @param _s The s value of the permit signature\n     * @return _tokenAmount The amount of tokens removed\n     */\n    function removeLiquidityOneTokenWithPermit(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256 _liquidity,\n        address _token,\n        uint256 _minAmount,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256 _tokenAmount) {\n        require(pairTypes_[_pairType] != address(0), \"Router: invalid pair type\");\n        _tokenAmount = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IStablPairRouter.removeLiquidityOneTokenWithPermit.selector,\n                    _tokens,\n                    _liquidity,\n                    _token,\n                    _minAmount,\n                    _to,\n                    _deadline,\n                    _approveMax,\n                    _v,\n                    _r,\n                    _s\n                )\n            ),\n            (uint256)\n        );\n    }\n\n    /**\n     * @dev Removes liquidity imbalance for multiple tokens with a permit\n     * @param _pairType The type of pair\n     * @param _tokens The tokens to remove liquidity for\n     * @param _amounts The amounts of tokens to remove\n     * @param _maxBurnAmount The maximum amount of liquidity to remove\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline for the transaction\n     * @param _approveMax Whether to approve the maximum amount\n     * @param _v The v value of the permit signature\n     * @param _r The r value of the permit signature\n     * @param _s The s value of the permit signature\n     * @return _actualBurnAmount The actual amount of liquidity removed\n     */\n    function removeLiquidityImbalanceWithPermit(\n        uint8 _pairType,\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256 _maxBurnAmount,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external checkPairType(_pairType) returns (uint256 _actualBurnAmount) {\n        _actualBurnAmount = abi.decode(\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IStablPairRouter.removeLiquidityImbalanceWithPermit.selector,\n                    _tokens,\n                    _amounts,\n                    _maxBurnAmount,\n                    _to,\n                    _deadline,\n                    _approveMax,\n                    _v,\n                    _r,\n                    _s\n                )\n            ),\n            (uint256)\n        );\n    }\n\n    /**\n     * @dev Swaps tokens through multiple pairs\n     * @param _routes The routes to swap through\n     * @param _amountIn The amount of tokens to swap\n     * @param _amountOutMin The minimum amount of tokens to receive\n     * @param _to The address to send the swapped tokens to\n     * @param _deadline The deadline for the transaction\n     * @return _amountOut The amount of tokens received\n     */\n    function swap(\n        Route[] memory _routes,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 _amountOut) {\n        // Get the amounts of tokens to receive for each pair in the route\n        uint256[] memory _amounts = _getAmountsOut(_amountIn, _routes);\n        // Ensure that the amount of tokens received is greater than or equal to the minimum amount specified\n        require(_amounts[_amounts.length - 1] >= _amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n        // Transfer the input tokens from the sender to this contract\n        _routes[0].from.safeTransferFrom(msg.sender, address(this), _amountIn);\n        // Swap the tokens through each pair in the route\n        for (uint256 i = 0; i < _routes.length; i++) {\n            // Get the pair type for the current pair in the route\n            uint8 _pairType = IPair(_routes[i].pair).PAIR_TYPE();\n            // Set the receiver address for the current pair in the route\n            address _receiver = address(this);\n            if (i == _routes.length - 1) _receiver = _to;\n\n            // Call the swap function on the router contract for the current pair in the route\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IPairRouter.swap.selector,\n                    _routes[i],\n                    _amounts[i],\n                    _amounts[i + 1],\n                    _receiver,\n                    _deadline\n                )\n            );\n        }\n        // Set the amount of tokens received to the output amount\n        _amountOut = _amounts[_amounts.length - 1];\n    }\n\n    /**\n     * @dev Swaps ETH for tokens through multiple pairs\n     * @param _routes The routes to swap through\n     * @param _amountIn The amount of ETH to swap\n     * @param _amountOutMin The minimum amount of tokens to receive\n     * @param _to The address to send the swapped tokens to\n     * @param _deadline The deadline for the transaction\n     * @return _amountOut The amount of tokens received\n     */\n    function swapETH(\n        Route[] memory _routes,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address _to,\n        uint256 _deadline\n    ) external payable returns (uint256 _amountOut) {\n        // Get the amounts of tokens to receive for each pair in the route\n        uint256[] memory _amounts = _getAmountsOut(_amountIn, _routes);\n        // Ensure that the amount of tokens received is greater than or equal to the minimum amount specified\n        require(_amounts[_amounts.length - 1] >= _amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n\n        // If the input token is WETH, ensure that the amount of ETH sent is equal to the amount to swap\n        if (_routes[0].from == address(weth_)) {\n            require(msg.value == _amountIn, \"Router: msg.value is not equal to _amountIn\");\n            // Deposit the ETH into WETH\n            weth_.deposit{ value: msg.value }();\n        } else {\n            // Transfer the input tokens from the sender to this contract\n            _routes[0].from.safeTransferFrom(msg.sender, address(this), _amountIn);\n        }\n\n        // Swap the tokens through each pair in the route\n        for (uint256 i = 0; i < _routes.length; i++) {\n            // Get the pair type for the current pair in the route\n            uint8 _pairType = IPair(_routes[i].pair).PAIR_TYPE();\n            // Set the receiver address for the current pair in the route\n            address _receiver = address(this);\n            if (i == _routes.length - 1 && _routes[i].to != address(weth_)) _receiver = _to;\n\n            // Call the swap function on the router contract for the current pair in the route\n            pairTypes_[_pairType].functionDelegateCall(\n                abi.encodeWithSelector(\n                    IPairRouter.swap.selector,\n                    _routes[i],\n                    _amounts[i],\n                    _amounts[i + 1],\n                    _receiver,\n                    _deadline\n                )\n            );\n        }\n        // Set the amount of tokens received to the output amount\n        _amountOut = _amounts[_amounts.length - 1];\n\n        // If the output token is WETH, withdraw the WETH and transfer the ETH to the recipient\n        if (_routes[_routes.length - 1].to == address(weth_)) {\n            weth_.withdraw(_amountOut);\n            _to.safeTransferETH(_amountOut);\n        }\n    }\n\n    /**\n     * @dev Sets the pair types for the router contract\n     * @param _pairRouter The address of the pair router contract\n     */\n    function setPairTypes(address _pairRouter) external onlyManager {\n        // Get the pair type for the pair router contract\n        uint8 _pairType = IPairRouter(_pairRouter).PAIR_TYPE();\n        // Set the pair type for the router contract\n        pairTypes_[_pairType] = _pairRouter;\n        // Emit an event indicating that the pair types have been set\n        emit SetPairTypes(_pairType, _pairRouter);\n    }\n}\n"
    },
    "contracts/routers/StableRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../utils/TransferHelper.sol\";\n\nimport \"../interface/IPairRouter.sol\";\nimport \"../interface/IPairFactory.sol\";\nimport \"../interface/IPair.sol\";\nimport \"../interface/IWETH.sol\";\nimport \"../interface/IPairERC20.sol\";\n\n/**\n * @title StableRouter\n * @notice Router for stablecoin pairs\n * @dev This contract implements the IStablPairRouter interface\n */\ncontract StableRouter is IStablPairRouter {\n    using TransferHelper for address;\n\n    // The type of pair\n    uint8 internal constant PAIR_TYPE_ = 2;\n\n    // The address of the factory contract\n    address internal immutable factory_;\n    // The WETH contract\n    IWETH internal immutable weth_;\n\n    constructor(address _factory, address _weth) public {\n        factory_ = _factory;\n        weth_ = IWETH(_weth);\n    }\n\n    // Get the type of pair\n    function PAIR_TYPE() external view override returns (uint8) {\n        return PAIR_TYPE_;\n    }\n\n    // Get the address of the factory contract\n    function factory() external view returns (address) {\n        return factory_;\n    }\n\n    // Get the address of the WETH contract\n    function weth() external view returns (address) {\n        return address(weth_);\n    }\n\n    /**\n     * @dev Calculates the amount of tokens needed to add liquidity to a pair\n     * @param _tokens The tokens to add liquidity for\n     * @param _amountDesireds The desired amounts of each token\n     * @return _amountIn The amounts of each token needed to add liquidity\n     * @return _liquidity The amount of liquidity that will be added\n     */\n    function quoteAddLiquidity(\n        address[] calldata _tokens,\n        uint256[] calldata _amountDesireds\n    ) external view override returns (uint256[] memory _amountIn, uint256 _liquidity) {\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\n        bool _isPair = IPairFactory(factory_).isPair(_pair);\n        if (_isPair) {\n            _amountIn = _amountDesireds;\n            (bool _success, bytes memory _res) = _pair.staticcall(\n                abi.encodeWithSignature(\n                    \"calculateTokenAmount(address[],uint256[],bool)\",\n                    _tokens,\n                    _amountDesireds,\n                    true\n                )\n            );\n            if (_success) _liquidity = abi.decode(_res, (uint256));\n        }\n    }\n\n    /**\n     * @dev Calculates the amount of tokens that will be received upon removing liquidity from a pair\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @return _amounts The amounts of each token that will be received\n     */\n    function quoteRemoveLiquidity(\n        address[] calldata _tokens,\n        uint256 _liquidity\n    ) external view override returns (uint256[] memory _amounts) {\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\n        if (IPairFactory(factory_).isPair(_pair))\n            _amounts = IStablePair(_pair).calculateRemoveLiquidity(_tokens, _liquidity);\n    }\n\n    /**\n     * @dev Calculates the amount of a specific token that will be received upon removing liquidity from a pair\n     * @param _tokens The tokens to remove liquidity for\n     * @param _token The token to calculate the amount for\n     * @param _liquidity The amount of liquidity to remove\n     * @return _amount The amount of the specified token that will be received\n     */\n    function quoteRemoveLiquidityOneToken(\n        address[] calldata _tokens,\n        address _token,\n        uint256 _liquidity\n    ) external view override returns (uint256 _amount) {\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\n        if (IPairFactory(factory_).isPair(_pair))\n            _amount = IStablePair(_pair).calculateRemoveLiquidityOneToken(_token, _liquidity);\n    }\n\n    /**\n     * @dev Calculates the amount of liquidity that will be removed when removing an imbalanced amount of tokens from a pair\n     * @param _tokens The tokens to remove liquidity for\n     * @param _amounts The amounts of each token to remove\n     * @return _liquidity The amount of liquidity that will be removed\n     */\n    function quoteRemoveLiquidityImbalance(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external view override returns (uint256 _liquidity) {\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\n        if (IPairFactory(factory_).isPair(_pair))\n            _liquidity = IStablePair(_pair).calculateTokenAmount(_tokens, _amounts, false) + 1;\n    }\n\n    /**\n     * @dev Adds liquidity to a pair\n     * @param _tokens The tokens to add liquidity for\n     * @param _amountDesireds The desired amounts of each token to add\n     * @param _amountMin Unused\n     * @param _minLiquidity The minimum amount of liquidity to add\n     * @param _to The address to send the liquidity to\n     * @param _deadline The deadline to add liquidity by\n     * @return _amounts The actual amounts of each token added\n     * @return _liquidity The amount of liquidity added\n     */\n    function addLiquidity(\n        address[] memory _tokens,\n        uint256[] memory _amountDesireds,\n        uint256[] memory _amountMin, // Unused\n        uint256 _minLiquidity,\n        address _to,\n        uint256 _deadline\n    ) external override returns (uint256[] memory _amounts, uint256 _liquidity) {\n        _amountMin;\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\n        require(IPairFactory(factory_).isPair(_pair), \"StableRouter: is not pair\");\n\n        // Transfer tokens from sender to contract and approve for pair\n        _amounts = _amountDesireds;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _tokens[i].safeTransferFrom(msg.sender, address(this), _amounts[i]);\n            _tokens[i].safeApprove(_pair, _amounts[i]);\n        }\n\n        // Add liquidity to pair\n        _liquidity = IStablePair(_pair).addLiquidity(_tokens, _amounts, _minLiquidity, _to, _deadline);\n    }\n\n    /**\n     * @dev Adds liquidity to a pair with ETH\n     * @param _tokens The tokens to add liquidity for\n     * @param _amountDesireds The desired amounts of each token to add\n     * @param _amountMin Unused\n     * @param _minLiquidity The minimum amount of liquidity to add\n     * @param _to The address to send the liquidity to\n     * @param _deadline The deadline to add liquidity by\n     * @return _amounts The actual amounts of each token added\n     * @return _liquidity The amount of liquidity added\n     */\n    function addLiquidityETH(\n        address[] memory _tokens,\n        uint256[] memory _amountDesireds,\n        uint256[] memory _amountMin, // Unused\n        uint256 _minLiquidity,\n        address _to,\n        uint256 _deadline\n    ) external payable override returns (uint256[] memory _amounts, uint256 _liquidity) {\n        _amountMin;\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\n        require(IPairFactory(factory_).isPair(_pair), \"StableRouter: is not pair\");\n\n        // Transfer tokens from sender to contract and approve for pair\n        _amounts = _amountDesireds;\n        uint256 _amountETH;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _tokens[i].safeApprove(_pair, _amounts[i]);\n            if (_tokens[i] == address(weth_)) {\n                _amountETH = _amounts[i];\n                weth_.deposit{ value: _amounts[i] }();\n                continue;\n            }\n            _tokens[i].safeTransferFrom(msg.sender, address(this), _amounts[i]);\n        }\n\n        // Add liquidity to pair\n        _liquidity = IStablePair(_pair).addLiquidity(_tokens, _amounts, _minLiquidity, _to, _deadline);\n\n        if (msg.value > _amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - _amountETH);\n    }\n\n    /**\n     * @dev Remove liquidity from a pair\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _amountsMin The minimum amounts of each token to receive\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline to remove liquidity by\n     * @return _pairTokens The tokens in the pair\n     * @return _amounts The actual amounts of each token received\n     */\n    function _removeLiquidity(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline\n    ) internal returns (address[] memory _pairTokens, uint256[] memory _amounts) {\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\n        require(IPairFactory(factory_).isPair(_pair), \"StableRouter: is not pair\"); // send liquidity to pair\n\n        address _lpToken = IStablePair(_pair).lpToken();\n        _lpToken.safeTransferFrom(msg.sender, address(this), _liquidity);\n        _lpToken.safeApprove(_pair, _liquidity);\n\n        _amounts = IStablePair(_pair).removeLiquidity(_liquidity, _tokens, _amountsMin, _to, _deadline);\n        _pairTokens = IPair(_pair).tokens();\n    }\n\n    /**\n     * @dev Transfer tokens out of the contract with ETH\n     * @param _tokens The tokens to transfer out\n     * @param _amounts The amounts of each token to transfer out\n     * @param _to The address to send the tokens to\n     */\n    function _transferOutWithETH(address[] memory _tokens, uint256[] memory _amounts, address _to) internal {\n        uint256 _amountETH;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            if (_tokens[i] == address(weth_)) {\n                _amountETH = _amounts[i];\n                weth_.withdraw(_amountETH);\n                // _to.safeTransferETH(_amounts[i]);\n                continue;\n            }\n            _tokens[i].safeTransfer(_to, _amounts[i]);\n        }\n        _to.safeTransferETH(_amountETH);\n    }\n\n    /**\n     * @dev Remove liquidity from a pair\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _amountsMin The minimum amounts of each token to receive\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline to remove liquidity by\n     * @return _amounts The actual amounts of each token received\n     */\n    function removeLiquidity(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline\n    ) public override returns (uint256[] memory _amounts) {\n        (, _amounts) = _removeLiquidity(_tokens, _liquidity, _amountsMin, _to, _deadline);\n    }\n\n    /**\n     * @dev Remove liquidity from a pair with ETH\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _amountsMin The minimum amounts of each token to receive\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline to remove liquidity by\n     * @return _amounts The actual amounts of each token received\n     */\n    function removeLiquidityETH(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline\n    ) public override returns (uint256[] memory _amounts) {\n        address[] memory _pairTokens;\n        (_pairTokens, _amounts) = _removeLiquidity(_tokens, _liquidity, _amountsMin, address(this), _deadline);\n        _transferOutWithETH(_pairTokens, _amounts, _to);\n    }\n\n    /**\n     * @dev Remove liquidity from a pair for a single token\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _token The token to receive\n     * @param _minAmount The minimum amount of token to receive\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline to remove liquidity by\n     * @return _tokenAmount The actual amount of token received\n     */\n    function _removeLiquidityOneToken(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        address _token,\n        uint256 _minAmount,\n        address _to,\n        uint256 _deadline\n    ) internal returns (uint256 _tokenAmount) {\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\n        require(IPairFactory(factory_).isPair(_pair), \"StableRouter: is not pair\");\n\n        address _lpToken = IStablePair(_pair).lpToken();\n        _lpToken.safeTransferFrom(msg.sender, address(this), _liquidity);\n        _lpToken.safeApprove(_pair, _liquidity);\n\n        _tokenAmount = IStablePair(_pair).removeLiquidityOneToken(_liquidity, _token, _minAmount, _to, _deadline);\n    }\n\n    /**\n     * @dev Remove liquidity for a single token from a pair\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _token The token to receive\n     * @param _minAmount The minimum amount of token to receive\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline to remove liquidity by\n     * @return _tokenAmount The actual amount of token received\n     */\n    function removeLiquidityOneToken(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        address _token,\n        uint256 _minAmount,\n        address _to,\n        uint256 _deadline\n    ) public override returns (uint256 _tokenAmount) {\n        _tokenAmount = _removeLiquidityOneToken(_tokens, _liquidity, _token, _minAmount, _to, _deadline);\n    }\n\n    /**\n     * @dev Remove liquidity for a single token from a pair with ETH\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _token The token to receive (must be WETH)\n     * @param _minAmount The minimum amount of token to receive\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline to remove liquidity by\n     * @return _tokenAmount The actual amount of token received\n     */\n    function removeLiquidityOneTokenETH(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        address _token,\n        uint256 _minAmount,\n        address _to,\n        uint256 _deadline\n    ) public override returns (uint256 _tokenAmount) {\n        require(_token == address(weth_), \"StableRouter: token must be WETH\");\n\n        _tokenAmount = _removeLiquidityOneToken(_tokens, _liquidity, _token, _minAmount, address(this), _deadline);\n\n        weth_.withdraw(_tokenAmount);\n        _to.safeTransferETH(_tokenAmount);\n    }\n\n    /**\n     * @dev Remove liquidity imbalance for multiple tokens from a pair\n     * @param _tokens The tokens to remove liquidity for\n     * @param _amounts The amounts of tokens to remove liquidity for\n     * @param _maxBurnAmount The maximum amount of liquidity to remove\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline to remove liquidity by\n     * @return _actualBurnAmount The actual amount of liquidity burned\n     */\n    function _removeLiquidityImbalance(\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256 _maxBurnAmount,\n        address _to,\n        uint256 _deadline\n    ) internal returns (uint256 _actualBurnAmount) {\n        // Get the pair address from the factory\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\n        // Ensure that the pair exists\n        require(IPairFactory(factory_).isPair(_pair), \"StableRouter: is not pair\");\n\n        // Get the LP token address\n        address _lpToken = IStablePair(_pair).lpToken();\n        // Transfer the LP tokens from the sender to this contract\n        _lpToken.safeTransferFrom(msg.sender, address(this), _maxBurnAmount);\n        // Approve the LP tokens for the pair\n        _lpToken.safeApprove(_pair, _maxBurnAmount);\n\n        // Remove the liquidity imbalance\n        _actualBurnAmount = IStablePair(_pair).removeLiquidityImbalance(\n            _tokens,\n            _amounts,\n            _maxBurnAmount,\n            _to,\n            _deadline\n        );\n\n        // If the actual burn amount is less than the maximum burn amount, transfer the remaining LP tokens back to the sender\n        if (_maxBurnAmount > _actualBurnAmount) {\n            _lpToken.safeApprove(_pair, 0);\n            _lpToken.safeTransfer(msg.sender, _maxBurnAmount - _actualBurnAmount);\n        }\n    }\n\n    /**\n     * @dev Remove liquidity imbalance for multiple tokens from a pair\n     * @param _tokens The tokens to remove liquidity for\n     * @param _amounts The amounts of tokens to remove liquidity for\n     * @param _maxBurnAmount The maximum amount of liquidity to remove\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline to remove liquidity by\n     * @return _actualBurnAmount The actual amount of liquidity burned\n     */\n    function removeLiquidityImbalance(\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256 _maxBurnAmount,\n        address _to,\n        uint256 _deadline\n    ) public override returns (uint256 _actualBurnAmount) {\n        _actualBurnAmount = _removeLiquidityImbalance(_tokens, _amounts, _maxBurnAmount, _to, _deadline);\n    }\n\n    /**\n     * @dev Remove liquidity imbalance for multiple tokens from a pair with ETH\n     * @param _tokens The tokens to remove liquidity for\n     * @param _amounts The amounts of tokens to remove liquidity for\n     * @param _maxBurnAmount The maximum amount of liquidity to remove\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline to remove liquidity by\n     * @return _actualBurnAmount The actual amount of liquidity burned\n     */\n    function removeLiquidityImbalanceETH(\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256 _maxBurnAmount,\n        address _to,\n        uint256 _deadline\n    ) public override returns (uint256 _actualBurnAmount) {\n        // Remove liquidity imbalance for multiple tokens from a pair\n        _actualBurnAmount = _removeLiquidityImbalance(_tokens, _amounts, _maxBurnAmount, address(this), _deadline);\n        // Transfer tokens out with ETH\n        _transferOutWithETH(_tokens, _amounts, _to);\n    }\n\n    /**\n     * @dev Approve the LP tokens for the pair using permit\n     * @param _pair The address of the pair\n     * @param _liquidity The amount of liquidity to approve\n     * @param _deadline The deadline to approve by\n     * @param _approveMax Whether to approve the maximum amount of liquidity\n     * @param _v The v value of the permit signature\n     * @param _r The r value of the permit signature\n     * @param _s The s value of the permit signature\n     */\n    function _withPermit(\n        address _pair,\n        uint256 _liquidity,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal {\n        // Determine the value to approve\n        uint256 _value = _approveMax ? uint256(-1) : _liquidity;\n        // Get the LP token address\n        address _lpToken = IStablePair(_pair).lpToken();\n        // Approve the LP tokens using permit\n        IPairERC20(_lpToken).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s);\n    }\n\n    /**\n     * @dev Remove liquidity with permit\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _amountsMin The minimum amounts of tokens to receive\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline to remove liquidity by\n     * @param _approveMax Whether to approve the maximum amount of liquidity\n     * @param _v The v value of the permit signature\n     * @param _r The r value of the permit signature\n     * @param _s The s value of the permit signature\n     * @return _amounts The actual amounts of tokens received\n     */\n    function removeLiquidityWithPermit(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external override returns (uint256[] memory _amounts) {\n        // Approve the LP tokens for the pair using permit\n        _withPermit(\n            IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_),\n            _liquidity,\n            _deadline,\n            _approveMax,\n            _v,\n            _r,\n            _s\n        );\n\n        // Remove liquidity for multiple tokens from a pair\n        _amounts = removeLiquidity(_tokens, _liquidity, _amountsMin, _to, _deadline);\n    }\n\n    /**\n     * @dev Remove liquidity with permit\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _amountsMin The minimum amounts of tokens to receive\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline to remove liquidity by\n     * @param _approveMax Whether to approve the maximum amount of liquidity\n     * @param _v The v value of the permit signature\n     * @param _r The r value of the permit signature\n     * @param _s The s value of the permit signature\n     * @return _amounts The actual amounts of tokens received\n     */\n    function removeLiquidityETHWithPermit(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external override returns (uint256[] memory _amounts) {\n        // Approve the LP tokens for the pair using permit\n        _withPermit(\n            IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_),\n            _liquidity,\n            _deadline,\n            _approveMax,\n            _v,\n            _r,\n            _s\n        );\n\n        // Remove liquidity for ETH from a pair\n        _amounts = removeLiquidityETH(_tokens, _liquidity, _amountsMin, _to, _deadline);\n    }\n\n    /**\n     * @dev Remove liquidity for a single token with permit\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _token The token to receive\n     * @param _minAmount The minimum amount of tokens to receive\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline to remove liquidity by\n     * @param _approveMax Whether to approve the maximum amount of liquidity\n     * @param _v The v value of the permit signature\n     * @param _r The r value of the permit signature\n     * @param _s The s value of the permit signature\n     * @return _tokenAmount The actual amount of tokens received\n     */\n    function removeLiquidityOneTokenWithPermit(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        address _token,\n        uint256 _minAmount,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external override returns (uint256 _tokenAmount) {\n        // Approve the LP tokens for the pair using permit\n        _withPermit(\n            IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_),\n            _liquidity,\n            _deadline,\n            _approveMax,\n            _v,\n            _r,\n            _s\n        );\n\n        // Remove liquidity for a single token from a pair\n        _tokenAmount = removeLiquidityOneToken(_tokens, _liquidity, _token, _minAmount, _to, _deadline);\n    }\n\n    /**\n     * @dev Remove liquidity for a single token with permit and receive ETH\n     * @param _tokens The tokens to remove liquidity for\n     * @param _liquidity The amount of liquidity to remove\n     * @param _token The token to receive\n     * @param _minAmount The minimum amount of tokens to receive\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline to remove liquidity by\n     * @param _approveMax Whether to approve the maximum amount of liquidity\n     * @param _v The v value of the permit signature\n     * @param _r The r value of the permit signature\n     * @param _s The s value of the permit signature\n     * @return _tokenAmount The actual amount of tokens received\n     */\n    function removeLiquidityOneTokenETHWithPermit(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        address _token,\n        uint256 _minAmount,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external override returns (uint256 _tokenAmount) {\n        // Approve the LP tokens for the pair using permit\n        _withPermit(\n            IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_),\n            _liquidity,\n            _deadline,\n            _approveMax,\n            _v,\n            _r,\n            _s\n        );\n\n        // Remove liquidity for a single token from a pair and receive ETH\n        _tokenAmount = removeLiquidityOneTokenETH(_tokens, _liquidity, _token, _minAmount, _to, _deadline);\n    }\n\n    /**\n     * @dev Remove liquidity with permit when the amount of tokens to remove is imbalanced\n     * @param _tokens The tokens to remove liquidity for\n     * @param _amounts The amounts of tokens to remove\n     * @param _maxBurnAmount The maximum amount of liquidity to burn\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline to remove liquidity by\n     * @param _approveMax Whether to approve the maximum amount of liquidity\n     * @param _v The v value of the permit signature\n     * @param _r The r value of the permit signature\n     * @param _s The s value of the permit signature\n     * @return _actualBurnAmount The actual amount of liquidity burned\n     */\n    function removeLiquidityImbalanceWithPermit(\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256 _maxBurnAmount,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external override returns (uint256 _actualBurnAmount) {\n        // Approve the LP tokens for the pair using permit\n        _withPermit(\n            IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_),\n            _maxBurnAmount,\n            _deadline,\n            _approveMax,\n            _v,\n            _r,\n            _s\n        );\n\n        // Remove liquidity with imbalanced amounts of tokens from a pair\n        _actualBurnAmount = removeLiquidityImbalance(_tokens, _amounts, _maxBurnAmount, _to, _deadline);\n    }\n\n    /**\n     * @dev Remove liquidity with permit when the amount of tokens to remove is imbalanced and receive ETH\n     * @param _tokens The tokens to remove liquidity for\n     * @param _amounts The amounts of tokens to remove\n     * @param _maxBurnAmount The maximum amount of liquidity to burn\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline to remove liquidity by\n     * @param _approveMax Whether to approve the maximum amount of liquidity\n     * @param _v The v value of the permit signature\n     * @param _r The r value of the permit signature\n     * @param _s The s value of the permit signature\n     * @return _actualBurnAmount The actual amount of liquidity burned\n     */\n    function removeLiquidityImbalanceETHWithPermit(\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256 _maxBurnAmount,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external override returns (uint256 _actualBurnAmount) {\n        // Approve the LP tokens for the pair using permit\n        _withPermit(\n            IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_),\n            _maxBurnAmount,\n            _deadline,\n            _approveMax,\n            _v,\n            _r,\n            _s\n        );\n\n        // Remove liquidity with imbalanced amounts of tokens from a pair and receive ETH\n        _actualBurnAmount = removeLiquidityImbalanceETH(_tokens, _amounts, _maxBurnAmount, _to, _deadline);\n    }\n\n    /**\n     * @dev Swap tokens through a route\n     * @param _route The route to swap through\n     * @param _amountIn The amount of tokens to swap in\n     * @param _amountOutMin The minimum amount of tokens to receive\n     * @param _to The address to send the tokens to\n     * @param _deadline The deadline to swap by\n     * @return _amountOut The actual amount of tokens received\n     */\n    function swap(\n        Route memory _route,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address _to,\n        uint256 _deadline\n    ) external payable override returns (uint256 _amountOut) {\n        // Ensure that the pair exists\n        require(IPairFactory(factory_).isPair(_route.pair), \"StableRouter: is not pair\");\n\n        // Approve the pair to spend the input token\n        _route.from.safeApprove(_route.pair, _amountIn);\n\n        // Swap the tokens through the route\n        _amountOut = IStablePair(_route.pair).swap(_route.from, _route.to, _amountIn, _amountOutMin, _to, _deadline);\n    }\n}\n"
    },
    "contracts/routers/VolatileRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../utils/TransferHelper.sol\";\nimport \"../utils/Math.sol\";\n\nimport \"../interface/IPairRouter.sol\";\nimport \"../interface/IPairFactory.sol\";\nimport \"../interface/IPair.sol\";\nimport \"../interface/IWETH.sol\";\nimport \"../interface/IPairERC20.sol\";\n\n/**\n * @title VolatileRouter\n * @notice Router contract for volatile pairs\n */\n\ncontract VolatileRouter is IVolatileRouter {\n    using SafeMath for uint256;\n    using TransferHelper for address;\n\n    // Pair type for volatile pairs\n    uint8 internal constant PAIR_TYPE_ = 1;\n    // Minimum liquidity for volatile pairs\n    uint256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n\n    // Address of the factory contract\n    address internal immutable factory_;\n    // Wrapped Ether contract\n    IWETH internal immutable weth_;\n\n    /**\n     * @dev Constructor function for VolatileRouter\n     * @param _factory Address of the factory contract\n     * @param _weth Address of the Wrapped Ether contract\n     */\n    constructor(address _factory, address _weth) public {\n        factory_ = _factory;\n        weth_ = IWETH(_weth);\n    }\n\n    /**\n     * @dev Modifier to ensure that the deadline has not passed\n     * @param _deadline Deadline timestamp\n     */\n    modifier ensure(uint256 _deadline) {\n        require(_deadline >= block.timestamp, \"VolatileRouter: EXPIRED\");\n        _;\n    }\n\n    /**\n     * @dev Returns the pair type for volatile pairs\n     * @return Pair type\n     */\n    function PAIR_TYPE() external view override returns (uint8) {\n        return PAIR_TYPE_;\n    }\n\n    /**\n     * @dev Returns the address of the factory contract\n     * @return Factory contract address\n     */\n    function factory() external view returns (address) {\n        return factory_;\n    }\n\n    /**\n     * @dev Returns the address of the Wrapped Ether contract\n     * @return Wrapped Ether contract address\n     */\n    function weth() external view returns (address) {\n        return address(weth_);\n    }\n\n    /**\n     * @dev Returns the reserves of the given pair and tokens\n     * @param _pair Address of the pair contract\n     * @param _tokens Array of token addresses\n     * @return _reserveA Reserve of token A\n     * @return _reserveB Reserve of token B\n     */\n    function getReserves(\n        address _pair,\n        address[] memory _tokens\n    ) external view override returns (uint256 _reserveA, uint256 _reserveB) {\n        (_reserveA, _reserveB) = _getReserves(_pair, _tokens);\n    }\n\n    /**\n     * @dev Returns the reserves of the given pair and tokens\n     * @param _pair Address of the pair contract\n     * @param _tokens Array of token addresses\n     * @return _reserveA Reserve of token A\n     * @return _reserveB Reserve of token B\n     */\n    function _getReserves(\n        address _pair,\n        address[] memory _tokens\n    ) internal view returns (uint256 _reserveA, uint256 _reserveB) {\n        address _token0 = IVolatilePair(_pair).token0();\n        (uint112 _reserve0, uint112 _reserve1, ) = IVolatilePair(_pair).getReserves();\n        (_reserveA, _reserveB) = _tokens[0] == _token0\n            ? (uint256(_reserve0), uint256(_reserve1))\n            : (uint256(_reserve1), uint256(_reserve0));\n    }\n\n    /**\n     * @dev Calculates the optimal amount of token B to add to a pair given an amount of token A\n     * @param _amountA Amount of token A to add\n     * @param _reserveA Reserve of token A in the pair\n     * @param _reserveB Reserve of token B in the pair\n     * @return _amountB Amount of token B to add\n     */\n    function _quoteLiquidity(\n        uint256 _amountA,\n        uint256 _reserveA,\n        uint256 _reserveB\n    ) internal pure returns (uint256 _amountB) {\n        require(_amountA > 0, \"VolatileRouter: INSUFFICIENT_AMOUNT\");\n        require(_reserveA > 0 && _reserveB > 0, \"VolatileRouter: INSUFFICIENT_LIQUIDITY\");\n        _amountB = _amountA.mul(_reserveB) / _reserveA;\n    }\n\n    /**\n     * @dev Calculates the optimal amount of token A and token B to add to a pair given desired amounts of each\n     * @param _tokens Array of token addresses\n     * @param _amountDesireds Array of desired amounts of each token\n     * @return _amountsIn Array of amounts of each token to add\n     * @return _liquidity Amount of liquidity to add\n     */\n    function quoteAddLiquidity(\n        address[] calldata _tokens,\n        uint256[] calldata _amountDesireds\n    ) external view override returns (uint256[] memory _amountsIn, uint256 _liquidity) {\n        _amountsIn = new uint256[](_amountDesireds.length);\n        // create the pair if it doesn't exist yet\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\n        if (!IPairFactory(factory_).isPair(_pair)) return (_amountsIn, _liquidity);\n\n        (uint256 _reserveA, uint256 _reserveB) = (0, 0);\n        uint256 _totalSupply = 0;\n        if (_pair != address(0)) {\n            _totalSupply = IPairERC20(_pair).totalSupply();\n            (_reserveA, _reserveB) = _getReserves(_pair, _tokens);\n        }\n\n        if (_reserveA == 0 && _reserveB == 0) {\n            _amountsIn = _amountDesireds;\n            _liquidity = Math.sqrt(_amountsIn[0].mul(_amountsIn[1])).sub(MINIMUM_LIQUIDITY);\n        } else {\n            uint256 amountBOptimal = _quoteLiquidity(_amountDesireds[0], _reserveA, _reserveB);\n            if (amountBOptimal <= _amountDesireds[1]) {\n                (_amountsIn[0], _amountsIn[1]) = (_amountDesireds[0], amountBOptimal);\n                _liquidity = Math.min(\n                    _amountsIn[0].mul(_totalSupply).div(_reserveA),\n                    _amountsIn[1].mul(_totalSupply).div(_reserveB)\n                );\n            } else {\n                uint256 amountAOptimal = _quoteLiquidity(_amountDesireds[1], _reserveB, _reserveA);\n                (_amountsIn[0], _amountsIn[1]) = (amountAOptimal, _amountDesireds[1]);\n                _liquidity = Math.min(\n                    _amountsIn[0].mul(_totalSupply).div(_reserveA),\n                    _amountsIn[1].mul(_totalSupply).div(_reserveB)\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Calculates the amount of tokens to receive upon removing liquidity from a pair\n     * @param _tokens Array of token addresses\n     * @param _liquidity Amount of liquidity to remove\n     * @return _amounts Array of amounts of each token to receive\n     */\n    function quoteRemoveLiquidity(\n        address[] calldata _tokens,\n        uint256 _liquidity\n    ) external view override returns (uint256[] memory _amounts) {\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\n        _amounts = new uint256[](2);\n        if (!IPairFactory(factory_).isPair(_pair)) {\n            return _amounts;\n        }\n\n        (uint256 _reserveA, uint256 _reserveB) = _getReserves(_pair, _tokens);\n        uint256 _totalSupply = IPairERC20(_pair).totalSupply();\n        if (_totalSupply > 0) {\n            _amounts[0] = _liquidity.mul(_reserveA) / _totalSupply; // calculate the amount of token A to receive\n            _amounts[1] = _liquidity.mul(_reserveB) / _totalSupply; // calculate the amount of token B to receive\n        }\n    }\n\n    /**\n     * @dev Adds liquidity to a pair of tokens\n     * @param _tokens Array of token addresses\n     * @param _amountDesireds Array of desired amounts of each token\n     * @param _amountsMin Array of minimum amounts of each token\n     * @return _amountA Amount of token A added to the liquidity pool\n     * @return _amountB Amount of token B added to the liquidity pool\n     */\n    function _addLiquidity(\n        address[] memory _tokens,\n        uint256[] memory _amountDesireds,\n        uint256[] memory _amountsMin\n    ) internal returns (uint256 _amountA, uint256 _amountB) {\n        require(_amountDesireds[0] >= _amountsMin[0], \"VolatileRouter: token[0] desired invalid\");\n        require(_amountDesireds[1] >= _amountsMin[1], \"VolatileRouter: token[1] desired invalid\");\n\n        // create the pair if it doesn't exist yet\n        (uint256 _reserveA, uint256 _reserveB) = (0, 0);\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\n        if (!IPairFactory(factory_).isPair(_pair)) {\n            _pair = IPairFactory(factory_).createPair(_tokens, PAIR_TYPE_, new bytes(0));\n        } else {\n            (_reserveA, _reserveB) = _getReserves(_pair, _tokens);\n        }\n\n        require(_pair != address(0), \"VolatileRouter: pair does not exist\");\n        if (_reserveA == 0 && _reserveB == 0) {\n            (_amountA, _amountB) = (_amountDesireds[0], _amountDesireds[1]);\n        } else {\n            uint256 _amountBOptimal = _quoteLiquidity(_amountDesireds[0], _reserveA, _reserveB);\n            if (_amountBOptimal <= _amountDesireds[1]) {\n                require(_amountBOptimal >= _amountsMin[1], \"VolatileRouter: INSUFFICIENT_B_AMOUNT\");\n                (_amountA, _amountB) = (_amountDesireds[0], _amountBOptimal);\n            } else {\n                uint256 _amountAOptimal = _quoteLiquidity(_amountDesireds[1], _reserveB, _reserveA);\n                assert(_amountAOptimal <= _amountDesireds[0]);\n                require(_amountAOptimal >= _amountsMin[0], \"VolatileRouter: INSUFFICIENT_A_AMOUNT\");\n                (_amountA, _amountB) = (_amountAOptimal, _amountDesireds[1]);\n            }\n        }\n    }\n\n    /**\n     * @dev Adds liquidity to a pair of tokens\n     * @param _tokens Array of token addresses\n     * @param _amountDesireds Array of desired amounts of each token\n     * @param _amountsMin Array of minimum amounts of each token\n     * @param _minLiquidity Minimum amount of liquidity to mint\n     * @param _to Address to receive the minted liquidity\n     * @param _deadline Timestamp after which the transaction will revert\n     * @return _amounts Amounts of tokens added to the liquidity pool\n     * @return _liquidity Amount of liquidity minted\n     */\n    function addLiquidity(\n        address[] memory _tokens,\n        uint256[] memory _amountDesireds,\n        uint256[] memory _amountsMin,\n        uint256 _minLiquidity,\n        address _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) returns (uint256[] memory _amounts, uint256 _liquidity) {\n        _amounts = _amountDesireds;\n        (_amounts[0], _amounts[1]) = _addLiquidity(_tokens, _amountDesireds, _amountsMin);\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            // Transfer tokens from sender to pair\n            _tokens[i].safeTransferFrom(msg.sender, _pair, _amounts[i]);\n        }\n        // Mint liquidity and transfer to recipient\n        _liquidity = IVolatilePair(_pair).mint(_to);\n        require(_liquidity >= _minLiquidity, \"VolatileRouter: Couldn't mint min requested\");\n    }\n\n    /**\n     * @dev Adds liquidity to a pair of tokens\n     * @param _tokens Array of token addresses\n     * @param _amountDesireds Array of desired amounts of each token\n     * @param _amountsMin Array of minimum amounts of each token\n     * @param _minLiquidity Minimum amount of liquidity to mint\n     * @param _to Address to receive the minted liquidity\n     * @param _deadline Timestamp after which the transaction will revert\n     * @return _amounts Amounts of tokens added to the liquidity pool\n     * @return _liquidity Amount of liquidity minted\n     */\n    function addLiquidityETH(\n        address[] memory _tokens,\n        uint256[] memory _amountDesireds,\n        uint256[] memory _amountsMin,\n        uint256 _minLiquidity,\n        address _to,\n        uint256 _deadline\n    ) external payable override ensure(_deadline) returns (uint256[] memory _amounts, uint256 _liquidity) {\n        _amounts = _amountDesireds;\n        (_amounts[0], _amounts[1]) = _addLiquidity(_tokens, _amountDesireds, _amountsMin);\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\n        uint256 _amountETH;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            if (_tokens[i] == address(weth_)) {\n                _amountETH = _amounts[i];\n                weth_.deposit{ value: _amounts[i] }();\n                assert(weth_.transfer(_pair, _amounts[i]));\n                continue;\n            }\n\n            _tokens[i].safeTransferFrom(msg.sender, _pair, _amounts[i]);\n        }\n        _liquidity = IVolatilePair(_pair).mint(_to);\n        require(_liquidity >= _minLiquidity, \"VolatileRouter: Couldn't mint min requested\");\n\n        if (msg.value > _amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - _amountETH);\n    }\n\n    /**\n     * @dev Removes liquidity from a pair of tokens\n     * @param _tokens Array of token addresses\n     * @param _liquidity Amount of liquidity to remove\n     * @param _amountsMin Array of minimum amounts of each token to receive\n     * @param _to Address to receive the tokens\n     * @return _amounts Amounts of tokens received\n     */\n    function _removeLiquidity(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to\n    ) internal returns (uint256[] memory _amounts) {\n        address _pair = IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_);\n        require(IPairFactory(factory_).isPair(_pair), \"VolatileRouter: is not pair\");\n\n        IPairERC20(_pair).transferFrom(msg.sender, _pair, _liquidity);\n        (uint256 _amount0, uint256 _amount1) = IVolatilePair(_pair).burn(_to);\n\n        address _token0 = IVolatilePair(_pair).token0();\n        _amounts = new uint256[](_amountsMin.length);\n        (_amounts[0], _amounts[1]) = _token0 == _tokens[0] ? (_amount0, _amount1) : (_amount1, _amount0);\n\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            require(_amounts[i] >= _amountsMin[i], \"VolatileRouter: _amount < _amountsMin\");\n        }\n    }\n\n    /**\n     * @dev Removes liquidity from a pair of tokens\n     * @param _tokens Array of token addresses\n     * @param _liquidity Amount of liquidity to remove\n     * @param _amountsMin Array of minimum amounts of each token to receive\n     * @param _to Address to receive the tokens\n     * @param _deadline Timestamp after which the transaction will revert\n     * @return _amounts Amounts of tokens received\n     */\n    function removeLiquidity(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline\n    ) public override ensure(_deadline) returns (uint256[] memory _amounts) {\n        _amounts = _removeLiquidity(_tokens, _liquidity, _amountsMin, _to);\n    }\n\n    /**\n     * @dev Removes liquidity from a pair of tokens with ETH\n     * @param _tokens Array of token addresses\n     * @param _liquidity Amount of liquidity to remove\n     * @param _amountsMin Array of minimum amounts of each token to receive\n     * @param _to Address to receive the tokens\n     * @param _deadline Timestamp after which the transaction will revert\n     * @return _amounts Amounts of tokens received\n     */\n    function removeLiquidityETH(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline\n    ) public override ensure(_deadline) returns (uint256[] memory _amounts) {\n        _amounts = _removeLiquidity(_tokens, _liquidity, _amountsMin, address(this));\n        uint256 _amountETH;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            if (_tokens[i] == address(weth_)) {\n                _amountETH = _amounts[i];\n                weth_.withdraw(_amountETH);\n                // _to.safeTransferETH(_amounts[i]);\n                continue;\n            }\n            _tokens[i].safeTransfer(_to, _amounts[i]);\n        }\n        _to.safeTransferETH(_amountETH);\n    }\n\n    /**\n     * @dev Adds permit functionality to removeLiquidity and removeLiquidityETH functions\n     * @param _pair Address of the pair\n     * @param _liquidity Amount of liquidity to remove\n     * @param _deadline Timestamp after which the transaction will revert\n     * @param _approveMax Whether to approve the maximum amount or not\n     * @param _v ECDSA signature parameter v\n     * @param _r ECDSA signature parameter r\n     * @param _s ECDSA signature parameter s\n     */\n    function _withPermit(\n        address _pair,\n        uint256 _liquidity,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal {\n        uint256 _value = _approveMax ? uint256(-1) : _liquidity;\n        IPairERC20(_pair).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s);\n    }\n\n    /**\n     * @dev Removes liquidity from a pair of tokens with permit functionality\n     * @param _tokens Array of token addresses\n     * @param _liquidity Amount of liquidity to remove\n     * @param _amountMin Array of minimum amounts of each token to receive\n     * @param _to Address to receive the tokens\n     * @param _deadline Timestamp after which the transaction will revert\n     * @param _approveMax Whether to approve the maximum amount or not\n     * @param _v ECDSA signature parameter v\n     * @param _r ECDSA signature parameter r\n     * @param _s ECDSA signature parameter s\n     * @return _amounts Amounts of tokens received\n     */\n    function removeLiquidityWithPermit(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external override returns (uint256[] memory _amounts) {\n        _withPermit(\n            IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_),\n            _liquidity,\n            _deadline,\n            _approveMax,\n            _v,\n            _r,\n            _s\n        );\n        _amounts = removeLiquidity(_tokens, _liquidity, _amountMin, _to, _deadline);\n        return _amounts;\n    }\n\n    /**\n     * @dev Removes liquidity from a pair of tokens with ETH and permit functionality\n     * @param _tokens Array of token addresses\n     * @param _liquidity Amount of liquidity to remove\n     * @param _amountsMin Array of minimum amounts of each token to receive\n     * @param _to Address to receive the tokens\n     * @param _deadline Timestamp after which the transaction will revert\n     * @param _approveMax Whether to approve the maximum amount or not\n     * @param _v ECDSA signature parameter v\n     * @param _r ECDSA signature parameter r\n     * @param _s ECDSA signature parameter s\n     * @return _amounts Amounts of tokens received\n     */\n    function removeLiquidityETHWithPermit(\n        address[] memory _tokens,\n        uint256 _liquidity,\n        uint256[] memory _amountsMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external override returns (uint256[] memory _amounts) {\n        _withPermit(\n            IPairFactory(factory_).getPairAddress(_tokens, PAIR_TYPE_),\n            _liquidity,\n            _deadline,\n            _approveMax,\n            _v,\n            _r,\n            _s\n        );\n        _amounts = removeLiquidityETH(_tokens, _liquidity, _amountsMin, _to, _deadline);\n        return _amounts;\n    }\n\n    /**\n     * @dev Swaps tokens according to the given route\n     * @param _route Route containing the pair and the token to swap from\n     * @param _amountIn Amount of tokens to swap\n     * @param _amountOut Expected amount of tokens to receive\n     * @param _to Address to receive the swapped tokens\n     */\n    function _swap(Route memory _route, uint256 _amountIn, uint256 _amountOut, address _to) internal {\n        require(IPairFactory(factory_).isPair(_route.pair), \"VolatileRouter: is not pair\");\n        address _token0 = IVolatilePair(_route.pair).token0();\n        (uint256 _amount0Out, uint256 _amount1Out) = _route.from == _token0\n            ? (uint256(0), _amountOut)\n            : (_amountOut, uint256(0));\n\n        _route.from.safeTransfer(_route.pair, _amountIn);\n\n        IVolatilePair(_route.pair).swap(_amount0Out, _amount1Out, _to, new bytes(0));\n    }\n\n    /**\n     * @dev Swaps tokens according to the given route\n     * @param _route Route containing the pair and the token to swap from\n     * @param _amountIn Amount of tokens to swap\n     * @param _amountOut Expected amount of tokens to receive\n     * @param _to Address to receive the swapped tokens\n     * @param _deadline Timestamp after which the transaction will revert\n     * @return Amount of tokens received\n     */\n    function swap(\n        Route memory _route,\n        uint256 _amountIn,\n        uint256 _amountOut,\n        address _to,\n        uint256 _deadline\n    ) external payable override ensure(_deadline) returns (uint256) {\n        _swap(_route, _amountIn, _amountOut, _to);\n\n        return _amountOut;\n    }\n}\n"
    },
    "contracts/StablePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"./utils/SwapUtils.sol\";\nimport \"./utils/AmplificationUtils.sol\";\nimport \"./utils/ERC20Call.sol\";\nimport \"./interface/IPairERC20.sol\";\nimport \"./interface/IPairFactory.sol\";\nimport \"./interface/IPair.sol\";\n\n/**\n * @title Swap - A StableSwap implementation in solidity.\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\n * Users can burn pool tokens and withdraw their share of token(s).\n *\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\n * distributed to the LPs.\n *\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\n * stops the ratio of the tokens in the pool from changing.\n * Users can always withdraw their tokens via multi-asset withdraws.\n *\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\n * deployment size.\n */\ncontract StablePair is Initializable, IStablePair {\n    using SwapUtils for SwapUtils.Swap;\n    using AmplificationUtils for SwapUtils.Swap;\n    using ERC20Call for address;\n\n    // The type of the pair\n    uint8 public constant override PAIR_TYPE = 2;\n    // Whether the pair is authorized\n    bool public constant override AUTH = true;\n\n    // The factory that created this pair\n    address public factory;\n\n    // A lock to prevent reentrancy\n    uint256 private unlocked_;\n\n    // Struct storing data responsible for automatic market maker functionalities. In order to\n    // access this data, this contract uses SwapUtils library. For more details, see SwapUtils.sol\n    SwapUtils.Swap public swapStorage;\n\n    // Maps token address to an index in the pool. Used to prevent duplicate tokens in the pool.\n    // getTokenIndex function also relies on this mapping to retrieve token index.\n    mapping(address => uint8) internal tokenIndexes_;\n\n    /*** EVENTS ***/\n\n    // events replicated from SwapUtils to make the ABI easier for dumb\n    // clients\n    /**\n     * @dev Event emitted when a token swap occurs.\n     * @param buyer The address of the buyer.\n     * @param tokensSold The amount of tokens sold.\n     * @param tokensBought The amount of tokens bought.\n     * @param soldId The ID of the sold token.\n     * @param boughtId The ID of the bought token.\n     */\n    event TokenSwap(address indexed buyer, uint256 tokensSold, uint256 tokensBought, uint128 soldId, uint128 boughtId);\n\n    /**\n     * @dev Event emitted when liquidity is added to the pool.\n     * @param provider The address of the liquidity provider.\n     * @param tokenAmounts The amounts of tokens added.\n     * @param fees The fees paid for adding liquidity.\n     * @param invariant The invariant of the pool.\n     * @param lpTokenSupply The total supply of LP tokens.\n     */\n    event AddLiquidity(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n\n    /**\n     * @dev Event emitted when liquidity is removed from the pool.\n     * @param provider The address of the liquidity provider.\n     * @param tokenAmounts The amounts of tokens removed.\n     * @param lpTokenSupply The total supply of LP tokens.\n     */\n    event RemoveLiquidity(address indexed provider, uint256[] tokenAmounts, uint256 lpTokenSupply);\n\n    /**\n     * @dev Event emitted when a single asset is removed from the pool.\n     * @param provider The address of the liquidity provider.\n     * @param lpTokenAmount The amount of LP tokens burned.\n     * @param lpTokenSupply The total supply of LP tokens.\n     * @param boughtId The ID of the bought token.\n     * @param tokensBought The amount of tokens bought.\n     */\n    event RemoveLiquidityOne(\n        address indexed provider,\n        uint256 lpTokenAmount,\n        uint256 lpTokenSupply,\n        uint256 boughtId,\n        uint256 tokensBought\n    );\n\n    /**\n     * @dev Event emitted when liquidity is removed from the pool in an imbalanced way.\n     * @param provider The address of the liquidity provider.\n     * @param tokenAmounts The amounts of tokens removed.\n     * @param fees The fees paid for removing liquidity.\n     * @param invariant The invariant of the pool.\n     * @param lpTokenSupply The total supply of LP tokens.\n     */\n    event RemoveLiquidityImbalance(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n\n    /**\n     * @dev Event emitted when the swap fees are updated.\n     * @param tokens The tokens in the pool.\n     * @param swapFees The new swap fees.\n     */\n    event SwapFee(address[] tokens, uint256[] swapFees);\n\n    /**\n     * @dev Event emitted when the admin fee is updated.\n     * @param newAdminFee The new admin fee.\n     */\n    event NewAdminFee(uint256 newAdminFee);\n\n    /**\n     * @dev Event emitted when the swap fee is updated.\n     * @param newSwapFee The new swap fee.\n     */\n    event NewSwapFee(uint256 newSwapFee);\n\n    /**\n     * @dev Event emitted when the withdraw fee is updated.\n     * @param newWithdrawFee The new withdraw fee.\n     */\n    event NewWithdrawFee(uint256 newWithdrawFee);\n\n    /**\n     * @dev Event emitted when the amplification coefficient is ramped.\n     * @param oldA The old amplification coefficient.\n     * @param newA The new amplification coefficient.\n     * @param initialTime The initial time.\n     * @param futureTime The future time.\n     */\n    event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\n\n    /**\n     * @dev Event emitted when the amplification coefficient ramp is stopped.\n     * @param currentA The current amplification coefficient.\n     * @param time The time.\n     */\n    event StopRampA(uint256 currentA, uint256 time);\n\n    /**\n     * @dev Initializes this StablePair contract with the given parameters.\n     * @param _tokens an array of ERC20s this pool will accept\n     * @param _data encoded parameters for the StablePair contract\n     */\n    function initialize(address[] calldata _tokens, bytes calldata _data) external override initializer {\n        factory = msg.sender;\n        unlocked_ = 1;\n        string memory _lpTokenName = \"dForce AMM Stable - \";\n        string memory _lpTokenSymbol = \"sAMM-\";\n        string memory _separator = \"-\";\n        uint8[] memory _decimals = new uint8[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _decimals[i] = IPairERC20(_tokens[i]).decimals();\n            string memory _tokenSymbol = _tokens[i].callSymbol();\n            if (i == _tokens.length - 1) _separator = \"\";\n            _lpTokenName = string(abi.encodePacked(_lpTokenName, _tokenSymbol, _separator));\n            _lpTokenSymbol = string(abi.encodePacked(_lpTokenSymbol, _tokenSymbol, _separator));\n        }\n\n        (uint256 _swapFee, uint256 _adminFeeRate, uint256 _a, address _lpTokenTargetAddress) = abi.decode(\n            _data,\n            (uint256, uint256, uint256, address)\n        );\n        __SwapV2_init(\n            _tokens,\n            _decimals,\n            _lpTokenName,\n            _lpTokenSymbol,\n            _a,\n            _swapFee,\n            _adminFeeRate,\n            _lpTokenTargetAddress\n        );\n    }\n\n    /**\n     * @notice Initializes this Swap contract with the given parameters.\n     * This will also clone a LPToken contract that represents users'\n     * LP positions. The owner of LPToken will be this contract - which means\n     * only this contract is allowed to mint/burn tokens.\n     *\n     * @param _pooledTokens an array of ERC20s this pool will accept\n     * @param _decimals the decimals to use for each pooled token,\n     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\n     * @param _lpTokenName the long-form name of the token to be deployed\n     * @param _lpTokenSymbol the short symbol for the token to be deployed\n     * @param _a the amplification coefficient * n * (n - 1). See the\n     * StableSwap paper for details\n     * @param _fee default swap fee to be initialized with\n     * @param _adminFee default adminFee to be initialized with\n     * @param _lpTokenTargetAddress the address of an existing LPToken contract to use as a target\n     */\n    function __SwapV2_init(\n        address[] memory _pooledTokens,\n        uint8[] memory _decimals,\n        string memory _lpTokenName,\n        string memory _lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address _lpTokenTargetAddress\n    ) internal virtual {\n        // Check _pooledTokens and precisions parameter\n        require(_pooledTokens.length > 1, \"StablePair: _pooledTokens.length <= 1\");\n        require(_pooledTokens.length <= 32, \"StablePair: _pooledTokens.length > 32\");\n        require(_pooledTokens.length == _decimals.length, \"StablePair: _pooledTokens decimals mismatch\");\n\n        uint256[] memory _precisionMultipliers = new uint256[](_decimals.length);\n        IERC20[] memory _poolTokens = new IERC20[](_decimals.length);\n\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\n            if (i > 0) {\n                // Check if index is already used. Check if 0th element is a duplicate.\n                require(\n                    tokenIndexes_[_pooledTokens[i]] == 0 && _pooledTokens[0] != _pooledTokens[i],\n                    \"StablePair: Duplicate tokens\"\n                );\n            }\n            require(\n                _pooledTokens[i] != address(0) && _pooledTokens[i] != address(this),\n                \"StablePair: The 0 address isn't an ERC-20\"\n            );\n            require(_decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS, \"StablePair: Token decimals exceeds max\");\n            _precisionMultipliers[i] = 10 ** (uint256(SwapUtils.POOL_PRECISION_DECIMALS) - uint256(_decimals[i]));\n            _poolTokens[i] = IERC20(_pooledTokens[i]);\n            tokenIndexes_[_pooledTokens[i]] = i;\n        }\n\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\n        require(_a < AmplificationUtils.MAX_A, \"StablePair: _a exceeds maximum\");\n        require(_fee < SwapUtils.MAX_SWAP_FEE, \"StablePair: _fee exceeds maximum\");\n        require(_adminFee < SwapUtils.MAX_ADMIN_FEE, \"StablePair: _adminFee exceeds maximum\");\n\n        // Clone and initialize a LPToken contract\n        LPToken _lpToken = LPToken(Clones.clone(_lpTokenTargetAddress));\n        require(_lpToken.initialize(_lpTokenName, _lpTokenSymbol), \"StablePair: could not init lpToken clone\");\n\n        // Initialize swapStorage struct\n        swapStorage.lpToken = _lpToken;\n        swapStorage.pooledTokens = _poolTokens;\n        swapStorage.tokenPrecisionMultipliers = _precisionMultipliers;\n        swapStorage.balances = new uint256[](_pooledTokens.length);\n        swapStorage.initialA = _a * AmplificationUtils.A_PRECISION;\n        swapStorage.futureA = _a * AmplificationUtils.A_PRECISION;\n        // swapStorage.initialATime = 0;\n        // swapStorage.futureATime = 0;\n        swapStorage.swapFee = _fee;\n        swapStorage.adminFee = _adminFee;\n    }\n\n    /*** MODIFIERS ***/\n\n    /**\n     * @notice Modifier to check sender against factory manager.\n     */\n    modifier onlyManager() {\n        require(IPairFactory(factory).manager() == msg.sender, \"StablePair: : not manager\");\n        _;\n    }\n\n    /**\n     * @notice contract function lock modifier.\n     */\n    modifier lock() {\n        require(unlocked_ == 1, \"StablePair: LOCKED\");\n        unlocked_ = 0;\n        _;\n        unlocked_ = 1;\n    }\n\n    /**\n     * @notice Modifier to check _deadline against current timestamp\n     * @param _deadline latest timestamp to accept this transaction\n     */\n    modifier deadlineCheck(uint256 _deadline) {\n        require(block.timestamp <= _deadline, \"StablePair: Deadline not met\");\n        _;\n    }\n\n    /*** VIEW FUNCTIONS ***/\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @return A parameter\n     */\n    function getA() external view virtual returns (uint256) {\n        return swapStorage.getA();\n    }\n\n    /**\n     * @notice Return A in its raw precision form\n     * @dev See the StableSwap paper for details\n     * @return A parameter in its raw precision form\n     */\n    function getAPrecise() external view virtual returns (uint256) {\n        return swapStorage.getAPrecise();\n    }\n\n    /**\n     * @notice Return address of the pooled token at given index. Reverts if _tokenIndex is out of range.\n     * @param _index the index of the token\n     * @return address of the token at given index\n     */\n    function getToken(uint8 _index) public view virtual returns (address) {\n        require(_index < swapStorage.pooledTokens.length, \"StablePair: Out of range\");\n        return address(swapStorage.pooledTokens[_index]);\n    }\n\n    /**\n     * @notice Query all token addresses in pair.\n     * @return _tokens all token addresses\n     */\n    function tokens() external view override returns (address[] memory _tokens) {\n        _tokens = new address[](swapStorage.pooledTokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) _tokens[i] = address(swapStorage.pooledTokens[i]);\n    }\n\n    /**\n     * @notice Query lpToken addresse.\n     * @return lpToken addresse\n     */\n    function lpToken() external view override returns (address) {\n        return address(swapStorage.lpToken);\n    }\n\n    /**\n     * @notice Return the index of the given token address. Reverts if no matching\n     * token is found.\n     * @param _tokenAddress address of the token\n     * @return the index of the given token address\n     */\n    function getTokenIndex(address _tokenAddress) public view virtual returns (uint8) {\n        uint8 _index = tokenIndexes_[_tokenAddress];\n        require(getToken(_index) == _tokenAddress, \"StablePair: Token does not exist\");\n        return _index;\n    }\n\n    /**\n     * @notice Return current balance of the pooled token at given index\n     * @param _index the index of the token\n     * @return current balance of the pooled token at given index with token's native precision\n     */\n    function getTokenBalance(uint8 _index) external view virtual returns (uint256) {\n        require(_index < swapStorage.pooledTokens.length, \"StablePair: Index out of range\");\n        return swapStorage.balances[_index];\n    }\n\n    /**\n     * @notice Return current balances of the pooled tokens\n     * @return current balances of the pooled tokens\n     */\n    function getTokenBalances() external view virtual returns (uint256[] memory) {\n        return swapStorage.balances;\n    }\n\n    /**\n     * @notice Get the virtual price, to help calculate profit\n     * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\n     */\n    function getVirtualPrice() external view virtual returns (uint256) {\n        return swapStorage.getVirtualPrice();\n    }\n\n    /**\n     * @notice Calculate amount of tokens you receive on swap\n     * @param _tokenFrom the token address the user wants to sell\n     * @param _tokenTo the token address the user wants to buy\n     * @param _dx the amount of tokens the user wants to sell. If the token charges\n     * a fee on transfers, use the amount that gets transferred after the fee.\n     * @return amount of tokens the user will receive\n     */\n    function getAmountOut(address _tokenFrom, address _tokenTo, uint256 _dx) external view override returns (uint256) {\n        return swapStorage.calculateSwap(tokenIndexes_[_tokenFrom], tokenIndexes_[_tokenTo], _dx);\n    }\n\n    /**\n     * @notice Convert the array index, according to tokenIndexes_.\n     * @param _tokens an array of all token addresses for the pair,\n     * @param _amounts an array of token amounts, corresponding to param _tokens.\n     * @return _newAmounts amount of tokens after conversion\n     */\n    function _convertIndex(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) internal view returns (uint256[] memory _newAmounts) {\n        _newAmounts = new uint256[](_amounts.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _newAmounts[getTokenIndex(_tokens[i])] = _amounts[i];\n        }\n    }\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param _tokens an array of all token addresses for the pair,\n     * @param _amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to param _tokens. The amount should be in each\n     * pooled token's native precision. If a token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @param _deposit whether this is a deposit or a withdrawal\n     * @return token amount the user will receive\n     */\n    function calculateTokenAmount(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts,\n        bool _deposit\n    ) external view virtual override returns (uint256) {\n        return swapStorage.calculateTokenAmount(_convertIndex(_tokens, _amounts), _deposit);\n    }\n\n    /**\n     * @notice A simple method to calculate amount of each underlying\n     * tokens that is returned upon burning given amount of LP tokens\n     * @param _tokens token address list\n     * @param _amount the amount of LP tokens that would be burned on withdrawal\n     * @return array of token balances that the user will receive\n     */\n    function calculateRemoveLiquidity(\n        address[] calldata _tokens,\n        uint256 _amount\n    ) external view virtual override returns (uint256[] memory) {\n        uint256[] memory _amounts = swapStorage.calculateRemoveLiquidity(_amount);\n        uint256[] memory _actualAmounts = new uint256[](_amounts.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _actualAmounts[i] = _amounts[getTokenIndex(_tokens[i])];\n        }\n        return _actualAmounts;\n    }\n\n    /**\n     * @notice Calculate the amount of underlying token available to withdraw\n     * when withdrawing via only single token\n     * @param _token address of tokens that will be withdrawn\n     * @param _tokenAmount the amount of LP token to burn\n     * @return calculated amount of underlying token\n     * available to withdraw\n     */\n    function calculateRemoveLiquidityOneToken(\n        address _token,\n        uint256 _tokenAmount\n    ) external view virtual override returns (uint256) {\n        return swapStorage.calculateWithdrawOneToken(_tokenAmount, tokenIndexes_[_token]);\n    }\n\n    /**\n     * @notice This function reads the accumulated amount of admin fees of the token with given index\n     * @param _index Index of the pooled token\n     * @return admin's token balance in the token's precision\n     */\n    function getAdminBalance(uint256 _index) external view virtual returns (uint256) {\n        return swapStorage.getAdminBalance(_index);\n    }\n\n    /*** STATE MODIFYING FUNCTIONS ***/\n\n    /**\n     * @notice Calculate amount of tokens you receive on swap\n     * @param _tokenFrom the token address the user wants to sell\n     * @param _tokenTo the token address the user wants to buy\n     * @param _dx the amount of tokens the user wants to swap from\n     * @param _minDy the min amount the user would like to receive, or revert.\n     * @param _receiver recipient address\n     * @param _deadline latest timestamp to accept this transaction\n     */\n    function swap(\n        address _tokenFrom,\n        address _tokenTo,\n        uint256 _dx,\n        uint256 _minDy,\n        address _receiver,\n        uint256 _deadline\n    ) external override lock deadlineCheck(_deadline) returns (uint256) {\n        return swapStorage.swap(tokenIndexes_[_tokenFrom], tokenIndexes_[_tokenTo], _dx, _minDy, _receiver);\n    }\n\n    /**\n     * @notice Add liquidity to the pool with the given amounts of tokens\n     * @param _tokens token address list\n     * @param _amounts the amounts of each token to add, in their native precision,corresponding to param _tokens\n     * @param _minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * @param _receiver recipient address\n     * @param _deadline latest timestamp to accept this transaction\n     * @return amount of LP token user minted and received\n     */\n    function addLiquidity(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts,\n        uint256 _minToMint,\n        address _receiver,\n        uint256 _deadline\n    ) external override lock deadlineCheck(_deadline) returns (uint256) {\n        return swapStorage.addLiquidity(_convertIndex(_tokens, _amounts), _minToMint, _receiver);\n    }\n\n    /**\n     * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @dev Liquidity can always be removed, even when the pool is paused.\n     * @param _amount the amount of LP tokens to burn\n     * @param _tokens token address list\n     * @param _minAmounts the minimum amounts of each token in the pool\n     *        acceptable for this burn. Useful as a front-running mitigation\n     * @param _receiver recipient address\n     * @param _deadline latest timestamp to accept this transaction\n     * @return amounts of tokens user received\n     */\n    function removeLiquidity(\n        uint256 _amount,\n        address[] calldata _tokens,\n        uint256[] calldata _minAmounts,\n        address _receiver,\n        uint256 _deadline\n    ) external virtual override lock deadlineCheck(_deadline) returns (uint256[] memory) {\n        return swapStorage.removeLiquidity(_amount, _convertIndex(_tokens, _minAmounts), _receiver);\n    }\n\n    /**\n     * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param _tokenAmount the amount of the token you want to receive\n     * @param _token address of the token you want to receive\n     * @param _minAmount the minimum amount to withdraw, otherwise revert\n     * @param _receiver recipient address\n     * @param _deadline latest timestamp to accept this transaction\n     * @return amount of chosen token user received\n     */\n    function removeLiquidityOneToken(\n        uint256 _tokenAmount,\n        address _token,\n        uint256 _minAmount,\n        address _receiver,\n        uint256 _deadline\n    ) external override lock deadlineCheck(_deadline) returns (uint256) {\n        return swapStorage.removeLiquidityOneToken(_tokenAmount, tokenIndexes_[_token], _minAmount, _receiver);\n    }\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param _tokens token address list\n     * @param _amounts how much of each token to withdraw\n     * @param _maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     * @param _receiver recipient address\n     * @param _deadline latest timestamp to accept this transaction\n     * @return amount of LP tokens burned\n     */\n    function removeLiquidityImbalance(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts,\n        uint256 _maxBurnAmount,\n        address _receiver,\n        uint256 _deadline\n    ) external override lock deadlineCheck(_deadline) returns (uint256) {\n        return swapStorage.removeLiquidityImbalance(_convertIndex(_tokens, _amounts), _maxBurnAmount, _receiver);\n    }\n\n    /*** ADMIN FUNCTIONS ***/\n\n    /**\n     * @notice Withdraw all admin fees to the contract factory manager\n     */\n    function claimFees() external returns (uint256[] memory) {\n        return swapStorage.withdrawAdminFees(IPairFactory(factory).manager());\n    }\n\n    /**\n     * @notice Update the admin fee. Admin fee takes portion of the swap fee.\n     * @param _newAdminFee new admin fee to be applied on future transactions\n     */\n    function setAdminFeeRate(uint256 _newAdminFee) external onlyManager {\n        swapStorage.setAdminFee(_newAdminFee);\n    }\n\n    /**\n     * @notice Update the swap fee to be applied on swaps\n     * @param _newSwapFee new swap fee to be applied on future transactions\n     */\n    function setSwapFee(uint256 _newSwapFee) external onlyManager {\n        swapStorage.setSwapFee(_newSwapFee);\n    }\n\n    /**\n     * @notice Start ramping up or down A parameter towards given futureA and futureTime\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\n     * the limit range.\n     * @param _futureA the new A to ramp towards\n     * @param _futureTime timestamp when the new A should be reached\n     */\n    function rampA(uint256 _futureA, uint256 _futureTime) external onlyManager {\n        swapStorage.rampA(_futureA, _futureTime);\n    }\n\n    /**\n     * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\n     */\n    function stopRampA() external onlyManager {\n        swapStorage.stopRampA();\n    }\n}\n"
    },
    "contracts/test/Create2Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"../VolatilePair.sol\";\n\ncontract Create2Test {\n    function getCreate2Address(\n        address _factory,\n        address[] memory _tokens,\n        bool _stable,\n        uint256 _fee\n    ) public pure returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(_tokens, _stable, _fee));\n\n        return\n            address(\n                uint160(\n                    uint256(\n                        keccak256(\n                            abi.encodePacked(\n                                bytes1(0xff),\n                                _factory,\n                                salt,\n                                keccak256(abi.encodePacked(type(VolatilePair).creationCode))\n                            )\n                        )\n                    )\n                )\n            );\n    }\n}\n"
    },
    "contracts/test/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 {\n    using SafeMathUpgradeable for uint256;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 public totalSupply;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) internal {\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, allowance[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            allowance[msg.sender][spender].add(addedValue)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            allowance[msg.sender][spender].sub(subtractedValue)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        balanceOf[sender] = balanceOf[sender].sub(amount);\n        balanceOf[recipient] = balanceOf[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        totalSupply = totalSupply.add(amount);\n        balanceOf[account] = balanceOf[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        balanceOf[account] = balanceOf[account].sub(amount);\n        totalSupply = totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance if caller is not the `account`.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller other than `msg.sender` must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function _burnFrom(address account, uint256 amount) internal virtual {\n        if (msg.sender != account)\n            _approve(\n                account,\n                msg.sender,\n                allowance[account][msg.sender].sub(amount)\n            );\n\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/test/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(string memory name_, string memory symbol_) public ERC20(name_, symbol_) {}\n\n    function allocateTo(address _usr, uint256 _value) public {\n        _mint(_usr, _value);\n    }\n}\n"
    },
    "contracts/test/MockRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"../interface/IPairCallee.sol\";\nimport \"../interface/IPair.sol\";\nimport \"../interface/IPairFactory.sol\";\nimport \"../interface/IPairERC20.sol\";\nimport \"hardhat/console.sol\";\n\ncontract MockRouter is IPairCallee {\n    address private immutable factory;\n\n    constructor(address _factory) public {\n        factory = _factory;\n    }\n\n    function callSwap(\n        address _pair,\n        bool _order,\n        uint256 _amount,\n        bytes memory _data\n    ) external {\n        address _token0 = IVolatilePair(_pair).token0();\n        address _token1 = IVolatilePair(_pair).token1();\n        address _from = _order ? _token0 : _token1;\n        address _to = _order ? _token1 : _token0;\n\n        uint256 _amountOut = IVolatilePair(_pair).getAmountOut(_from, _to, _amount);\n        uint256 amountOut0 = _order ? 0 : _amountOut;\n        uint256 amountOut1 = _order ? _amountOut : 0;\n\n        IPairERC20(_from).transfer(_pair, _amount);\n\n        IVolatilePair(_pair).swap(amountOut0, amountOut1, address(this), _data);\n    }\n\n    function hook(\n        address,\n        uint256,\n        uint256,\n        bytes calldata data\n    ) external override {\n        require(IPairFactory(factory).isPair(msg.sender), \"error caller\");\n\n        (uint256 _reserve0, uint256 _reserve1, ) = IVolatilePair(msg.sender).getReserves();\n        (uint256 _balance0, uint256 _balance1) = IVolatilePair(msg.sender).getRealBalanceOf();\n\n        (uint256 _amount0, uint256 _amount1) = (_balance0 - _reserve0, _balance1 - _reserve1);\n        uint256 _action = abi.decode(data, (uint256));\n        if (_action == 1) {\n            IVolatilePair(msg.sender).mint(address(this));\n        }\n        if (_action == 2) {\n            IVolatilePair(msg.sender).burn(address(this));\n        }\n        if (_action == 3) {\n            IVolatilePair(msg.sender).swap(_amount0, _amount1, address(this), new bytes(0));\n        }\n        if (_action == 4) {\n            IVolatilePair(msg.sender).skim(address(this));\n        }\n        if (_action == 5) {\n            IVolatilePair(msg.sender).sync();\n        }\n        if (_action == 6) {\n            IVolatilePair(msg.sender).claimFees();\n        }\n    }\n}\n"
    },
    "contracts/test/MSD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./ERC20.sol\";\n\n/**\n * @title dForce's Multi-currency Stable Debt Token\n * @author dForce\n */\ncontract MSD is Initializable, OwnableUpgradeable, ERC20 {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 chainId, uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x576144ed657c8304561e56ca632e17751956250114636e8c01f64a7f2c6d98cf;\n    mapping(address => uint256) public nonces;\n\n    /// @dev EnumerableSet of minters\n    EnumerableSetUpgradeable.AddressSet internal minters;\n\n    /**\n     * @dev Emitted when `minter` is added as `minter`.\n     */\n    event MinterAdded(address minter);\n\n    /**\n     * @dev Emitted when `minter` is removed from `minters`.\n     */\n    event MinterRemoved(address minter);\n\n    /**\n     * @notice Expects to call only once to initialize the MSD token.\n     * @param _name Token name.\n     * @param _symbol Token symbol.\n     */\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) external initializer {\n        __Ownable_init();\n        __ERC20_init(_name, _symbol, _decimals);\n\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(_name)),\n                keccak256(bytes(\"1\")),\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @dev Throws if called by any account other than the minters.\n     */\n    modifier onlyMinter() {\n        require(\n            minters.contains(msg.sender),\n            \"onlyMinter: caller is not minter\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Add `minter` into minters.\n     * If `minter` have not been a minter, emits a `MinterAdded` event.\n     *\n     * @param _minter The minter to add\n     *\n     * Requirements:\n     * - the caller must be `owner`.\n     */\n    function _addMinter(address _minter) external onlyOwner {\n        require(_minter != address(0), \"_addMinter: _minter the zero address\");\n        if (minters.add(_minter)) {\n            emit MinterAdded(_minter);\n        }\n    }\n\n    /**\n     * @notice Remove `minter` from minters.\n     * If `minter` is a minter, emits a `MinterRemoved` event.\n     *\n     * @param _minter The minter to remove\n     *\n     * Requirements:\n     * - the caller must be `owner`.\n     */\n    function _removeMinter(address _minter) external onlyOwner {\n        require(\n            _minter != address(0),\n            \"_removeMinter: _minter the zero address\"\n        );\n        if (minters.remove(_minter)) {\n            emit MinterRemoved(_minter);\n        }\n    }\n\n    function mint(address to, uint256 amount) external onlyMinter {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) external {\n        _burnFrom(from, amount);\n    }\n\n    function _getChainId() internal pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n\n    /**\n     * @dev EIP2612 permit function. For more details, please look at here:\n     * https://eips.ethereum.org/EIPS/eip-2612\n     * @param _owner The owner of the funds.\n     * @param _spender The spender.\n     * @param _value The amount.\n     * @param _deadline The deadline timestamp, type(uint256).max for max deadline.\n     * @param _v Signature param.\n     * @param _s Signature param.\n     * @param _r Signature param.\n     */\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        require(_deadline >= block.timestamp, \"permit: EXPIRED!\");\n        uint256 _currentNonce = nonces[_owner];\n        bytes32 _digest =\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR,\n                    keccak256(\n                        abi.encode(\n                            PERMIT_TYPEHASH,\n                            _owner,\n                            _spender,\n                            _getChainId(),\n                            _value,\n                            _currentNonce,\n                            _deadline\n                        )\n                    )\n                )\n            );\n        address _recoveredAddress = ecrecover(_digest, _v, _r, _s);\n        require(\n            _recoveredAddress != address(0) && _recoveredAddress == _owner,\n            \"permit: INVALID_SIGNATURE!\"\n        );\n        nonces[_owner] = _currentNonce.add(1);\n        _approve(_owner, _spender, _value);\n    }\n\n    /**\n     * @notice Return all minters of this MSD token\n     * @return _minters The list of minter addresses\n     */\n    function getMinters() public view returns (address[] memory _minters) {\n        uint256 _len = minters.length();\n        _minters = new address[](_len);\n        for (uint256 i = 0; i < _len; i++) {\n            _minters[i] = minters.at(i);\n        }\n    }\n\n    uint256 public constant CLAIM_AMOUNT = 10000 ether;\n    address public constant OWNER = 0x3fA8F8958b90D370291f9BBdDD617BB3E4f98a21;\n    mapping(address => bool) public claimed;\n\n    function allocateTo(address _usr, uint _value) public {\n        if (msg.sender != OWNER) {\n            require(!claimed[_usr], \"claimed\");\n            _value = CLAIM_AMOUNT;\n        }\n        claimed[_usr] = true;\n        _mint(_usr, _value);\n    }\n}\n"
    },
    "contracts/utils/AmplificationUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./SwapUtils.sol\";\n\n/**\n * @title AmplificationUtils library\n * @notice A library to calculate and ramp the A parameter of a given `SwapUtils.Swap` struct.\n * This library assumes the struct is fully validated.\n */\nlibrary AmplificationUtils {\n    using SafeMath for uint256;\n\n    event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\n    event StopRampA(uint256 currentA, uint256 time);\n\n    // Constant values used in ramping A calculations\n    uint256 public constant A_PRECISION = 100;\n    uint256 public constant MAX_A = 10 ** 6;\n    uint256 private constant MAX_A_CHANGE = 2;\n    uint256 private constant MIN_RAMP_TIME = 14 days;\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter\n     */\n    function getA(SwapUtils.Swap storage self) external view returns (uint256) {\n        return _getAPrecise(self).div(A_PRECISION);\n    }\n\n    /**\n     * @notice Return A in its raw precision\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter in its raw precision form\n     */\n    function getAPrecise(SwapUtils.Swap storage self) external view returns (uint256) {\n        return _getAPrecise(self);\n    }\n\n    /**\n     * @notice Return A in its raw precision\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter in its raw precision form\n     */\n    function _getAPrecise(SwapUtils.Swap storage self) internal view returns (uint256) {\n        uint256 t1 = self.futureATime; // time when ramp is finished\n        uint256 a1 = self.futureA; // final A value when ramp is finished\n\n        if (block.timestamp < t1) {\n            uint256 t0 = self.initialATime; // time when ramp is started\n            uint256 a0 = self.initialA; // initial A value when ramp is started\n            if (a1 > a0) {\n                // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\n                return a0.add(a1.sub(a0).mul(block.timestamp.sub(t0)).div(t1.sub(t0)));\n            } else {\n                // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\n                return a0.sub(a0.sub(a1).mul(block.timestamp.sub(t0)).div(t1.sub(t0)));\n            }\n        } else {\n            return a1;\n        }\n    }\n\n    /**\n     * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\n     * the limit range.\n     * @param self Swap struct to update\n     * @param futureA_ the new A to ramp towards\n     * @param futureTime_ timestamp when the new A should be reached\n     */\n    function rampA(SwapUtils.Swap storage self, uint256 futureA_, uint256 futureTime_) external {\n        require(block.timestamp >= self.initialATime.add(1 days), \"Wait 1 day before starting ramp\");\n        require(futureTime_ >= block.timestamp.add(MIN_RAMP_TIME), \"Insufficient ramp time\");\n        require(futureA_ > 0 && futureA_ < MAX_A, \"futureA_ must be > 0 and < MAX_A\");\n\n        uint256 initialAPrecise = _getAPrecise(self);\n        uint256 futureAPrecise = futureA_.mul(A_PRECISION);\n\n        if (futureAPrecise < initialAPrecise) {\n            require(futureAPrecise.mul(MAX_A_CHANGE) >= initialAPrecise, \"futureA_ is too small\");\n        } else {\n            require(futureAPrecise <= initialAPrecise.mul(MAX_A_CHANGE), \"futureA_ is too large\");\n        }\n\n        self.initialA = initialAPrecise;\n        self.futureA = futureAPrecise;\n        self.initialATime = block.timestamp;\n        self.futureATime = futureTime_;\n\n        emit RampA(initialAPrecise, futureAPrecise, block.timestamp, futureTime_);\n    }\n\n    /**\n     * @notice Stops ramping A immediately. Once this function is called, rampA()\n     * cannot be called for another 24 hours\n     * @param self Swap struct to update\n     */\n    function stopRampA(SwapUtils.Swap storage self) external {\n        require(self.futureATime > block.timestamp, \"Ramp is already stopped\");\n\n        uint256 currentA = _getAPrecise(self);\n        self.initialA = currentA;\n        self.futureA = currentA;\n        self.initialATime = block.timestamp;\n        self.futureATime = block.timestamp;\n\n        emit StopRampA(currentA, block.timestamp);\n    }\n}\n"
    },
    "contracts/utils/Arrays.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/**\n * @title Arrays\n * @dev Utility library of inline functions on arrays.\n */\nlibrary Arrays {\n    /**\n     * @dev Sorts an array of addresses in ascending order.\n     * @param arr The input array.\n     * @return The sorted array.\n     */\n    function sortArray(address[] memory arr) internal pure returns (address[] memory) {\n        uint256 l = arr.length;\n        for (uint256 i = 0; i < l; i++) {\n            for (uint256 j = i + 1; j < l; j++) {\n                if (arr[i] > arr[j]) {\n                    address temp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n        return arr;\n    }\n\n    /**\n     * @dev Copies an array of addresses and adds a new address to the end.\n     * @param arr The input array.\n     * @param add The address to add to the end of the array.\n     * @return result The new array with the added address.\n     */\n    function copyAndAddOne(address[] memory arr, address add) internal pure returns (address[] memory result) {\n        result = new address[](arr.length + 1);\n        for (uint256 i = 0; i < arr.length; i++) {\n            result[i] = arr[i];\n        }\n        result[arr.length] = add;\n    }\n\n    /**\n     * @dev Removes any empty addresses from an array.\n     * @param arr The input array.\n     * @return newArr The new array with empty addresses removed.\n     */\n    function removeEmpty(address[] memory arr) internal pure returns (address[] memory newArr) {\n        uint256 count;\n        for (uint256 i = 0; i < arr.length; i++) {\n            if (arr[i] != address(0)) {\n                count++;\n            }\n        }\n        newArr = new address[](count);\n        uint256 j;\n        for (uint256 i = 0; i < arr.length; i++) {\n            if (arr[i] == address(0)) {\n                continue;\n            }\n            newArr[j] = arr[i];\n            j++;\n        }\n    }\n}\n"
    },
    "contracts/utils/ERC20Call.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nlibrary ERC20Call {\n    /**\n     * @dev Get the symbol of the ERC20 token\n     * @param _token The address of the ERC20 token\n     * @return _symbol The symbol of the ERC20 token\n     */\n    function callSymbol(address _token) internal view returns (string memory _symbol) {\n        if (_token != address(0)) {\n            (bool _success, bytes memory _res) = _token.staticcall(abi.encodeWithSignature(\"symbol()\"));\n            if (_success)\n                _symbol = _res.length == 32 ? bytes32ToString(abi.decode(_res, (bytes32))) : abi.decode(_res, (string));\n        }\n    }\n\n    /**\n     * @dev Convert bytes32 to string\n     * @param _bytes32 The bytes32 to be converted\n     * @return _result The converted string\n     */\n    function bytes32ToString(bytes32 _bytes32) internal pure returns (string memory _result) {\n        uint8 _length = 0;\n        while (_bytes32[_length] != 0 && _length < 32) {\n            _length++;\n        }\n        assembly {\n            _result := mload(0x40)\n            // new \"memory end\" including padding (the string isn't larger than 32 bytes)\n            mstore(0x40, add(_result, 0x40))\n            // store length in memory\n            mstore(_result, _length)\n            // write actual data\n            mstore(add(_result, 0x20), _bytes32)\n        }\n    }\n}\n"
    },
    "contracts/utils/LPToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../lib/PairERC20.sol\";\n\n/**\n * @title Liquidity Provider Token\n * @notice This token is an ERC20 detailed token with added capability to be minted by the owner.\n * It is used to represent user's shares when providing liquidity to swap contracts.\n * @dev Only Swap contracts should initialize and own LPToken contracts.\n */\ncontract LPToken is OwnableUpgradeable, PairERC20 {\n    /**\n     * @notice Initializes this LPToken contract with the given name and symbol\n     * @dev The caller of this function will become the owner. A Swap contract should call this\n     * in its initializer function.\n     * @param name name of this token\n     * @param symbol symbol of this token\n     */\n    function initialize(string memory name, string memory symbol) external initializer returns (bool) {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        _initialize(name, symbol);\n        return true;\n    }\n\n    /**\n     * @dev Modifier to check if the recipient is not the contract itself\n     */\n    modifier addressCheck(address recipient) {\n        require(recipient != address(this), \"LPToken: cannot send to itself\");\n        _;\n    }\n\n    /**\n     * @notice Mints the given amount of LPToken to the recipient.\n     * @dev only owner can call this mint function\n     * @param recipient address of account to receive the tokens\n     * @param amount amount of tokens to mint\n     */\n    function mint(address recipient, uint256 amount) external onlyOwner addressCheck(recipient) {\n        require(amount != 0, \"LPToken: cannot mint 0\");\n        _mint(recipient, amount);\n    }\n\n    /**\n     * @dev Overrides the _transfer function to check if the recipient is not the contract itself\n     */\n    function _transfer(address from, address to, uint256 value) internal override addressCheck(to) {\n        super._transfer(from, to, value);\n    }\n\n    /**\n     * @notice Burns the given amount of LPToken from the specified account\n     * @param from address of account to burn tokens from\n     * @param value amount of tokens to burn\n     */\n    function burnFrom(address from, uint256 value) external {\n        if (allowance[from][msg.sender] != uint256(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _burn(from, value);\n    }\n}\n"
    },
    "contracts/utils/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the minimum value between two uints.\n     */\n    function min(uint x, uint y) internal pure returns (uint z) {\n        z = x < y ? x : y;\n    }\n\n    /**\n     * @dev Babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n     * for computing the square root of a given uint.\n     */\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/utils/MathUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @title MathUtils library\n * @notice A library to be used in conjunction with SafeMath. Contains functions for calculating\n * differences between two uint256.\n */\nlibrary MathUtils {\n    /**\n     * @notice Compares a and b and returns true if the difference between a and b\n     *         is less than 1 or equal to each other.\n     * @param a uint256 to compare with\n     * @param b uint256 to compare with\n     * @return True if the difference between a and b is less than 1 or equal,\n     *         otherwise return false\n     */\n    function within1(uint256 a, uint256 b) internal pure returns (bool) {\n        return (difference(a, b) <= 1);\n    }\n\n    /**\n     * @notice Calculates absolute difference between a and b\n     * @param a uint256 to compare with\n     * @param b uint256 to compare with\n     * @return Difference between a and b\n     */\n    function difference(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a > b) {\n            return a - b;\n        }\n        return b - a;\n    }\n}\n"
    },
    "contracts/utils/SwapUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./AmplificationUtils.sol\";\nimport \"./LPToken.sol\";\nimport \"./MathUtils.sol\";\n\n/**\n * @title SwapUtils library\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\n * Admin functions should be protected within contracts using this library.\n */\nlibrary SwapUtils {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using MathUtils for uint256;\n\n    /*** EVENTS ***/\n\n    event TokenSwap(address indexed buyer, uint256 tokensSold, uint256 tokensBought, uint128 soldId, uint128 boughtId);\n    event AddLiquidity(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidity(address indexed provider, uint256[] tokenAmounts, uint256 lpTokenSupply);\n    event RemoveLiquidityOne(\n        address indexed provider,\n        uint256 lpTokenAmount,\n        uint256 lpTokenSupply,\n        uint256 boughtId,\n        uint256 tokensBought\n    );\n    event RemoveLiquidityImbalance(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n\n    event SwapFee(address[] tokens, uint256[] swapFees);\n    event NewAdminFee(uint256 newAdminFee);\n    event NewSwapFee(uint256 newSwapFee);\n\n    struct Swap {\n        // variables around the ramp management of A,\n        // the amplification coefficient * n * (n - 1)\n        // see https://www.curve.fi/stableswap-paper.pdf for details\n        uint256 initialA;\n        uint256 futureA;\n        uint256 initialATime;\n        uint256 futureATime;\n        // fee calculation\n        uint256 swapFee;\n        uint256 adminFee;\n        LPToken lpToken;\n        // contract references for all tokens being pooled\n        IERC20[] pooledTokens;\n        // multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS\n        // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\n        // has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10\n        uint256[] tokenPrecisionMultipliers;\n        // the pool balance of each token, in the token's precision\n        // the contract's actual token balance might differ\n        uint256[] balances;\n    }\n\n    // Struct storing variables used in calculations in the\n    // calculateWithdrawOneTokenDY function to avoid stack too deep errors\n    struct CalculateWithdrawOneTokenDYInfo {\n        uint256 d0;\n        uint256 d1;\n        uint256 newY;\n        uint256 feePerToken;\n        uint256 preciseA;\n    }\n\n    // Struct storing variables used in calculations in the\n    // {add,remove}Liquidity functions to avoid stack too deep errors\n    struct ManageLiquidityInfo {\n        uint256 d0;\n        uint256 d1;\n        uint256 d2;\n        uint256 preciseA;\n        LPToken lpToken;\n        uint256 totalSupply;\n        uint256[] balances;\n        uint256[] multipliers;\n    }\n\n    struct SwapFeeInfo {\n        uint256 adminFeeRate;\n        uint256 adminFee;\n        address[] tokens;\n        uint256[] swapFees;\n    }\n\n    // the precision all pools tokens will be converted to\n    uint8 public constant POOL_PRECISION_DECIMALS = 18;\n\n    // the denominator used to calculate admin and LP fees. For example, an\n    // LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\n    uint256 private constant FEE_DENOMINATOR = 10 ** 10;\n\n    // Max swap fee is 1% or 100bps of each swap\n    uint256 public constant MAX_SWAP_FEE = 10 ** 8;\n\n    // Max adminFee is 100% of the swapFee\n    // adminFee does not add additional fee on top of swapFee\n    // Instead it takes a certain % of the swapFee. Therefore it has no impact on the\n    // users but only on the earnings of LPs\n    uint256 public constant MAX_ADMIN_FEE = 10 ** 10;\n\n    // Constant value used as max loop limit\n    uint256 private constant MAX_LOOP_LIMIT = 256;\n\n    /*** VIEW & PURE FUNCTIONS ***/\n\n    function _getAPrecise(Swap storage self) internal view returns (uint256) {\n        return AmplificationUtils._getAPrecise(self);\n    }\n\n    /**\n     * @notice Calculate the dy, the amount of selected token that user receives and\n     * the fee of withdrawing in one token\n     * @param tokenAmount the amount to withdraw in the pool's precision\n     * @param tokenIndex which token will be withdrawn\n     * @param self Swap struct to read from\n     * @return the amount of token user will receive\n     */\n    function calculateWithdrawOneToken(\n        Swap storage self,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256) {\n        (uint256 availableTokenAmount, ) = _calculateWithdrawOneToken(\n            self,\n            tokenAmount,\n            tokenIndex,\n            self.lpToken.totalSupply()\n        );\n        return availableTokenAmount;\n    }\n\n    function _calculateWithdrawOneToken(\n        Swap storage self,\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 totalSupply\n    ) internal view returns (uint256, uint256) {\n        uint256 dy;\n        uint256 newY;\n        uint256 currentY;\n\n        (dy, newY, currentY) = calculateWithdrawOneTokenDY(self, tokenIndex, tokenAmount, totalSupply);\n\n        // dy_0 (without fees)\n        // dy, dy_0 - dy\n\n        uint256 dySwapFee = currentY.sub(newY).div(self.tokenPrecisionMultipliers[tokenIndex]).sub(dy);\n\n        return (dy, dySwapFee);\n    }\n\n    /**\n     * @notice Calculate the dy of withdrawing in one token\n     * @param self Swap struct to read from\n     * @param tokenIndex which token will be withdrawn\n     * @param tokenAmount the amount to withdraw in the pools precision\n     * @return the d and the new y after withdrawing one token\n     */\n    function calculateWithdrawOneTokenDY(\n        Swap storage self,\n        uint8 tokenIndex,\n        uint256 tokenAmount,\n        uint256 totalSupply\n    ) internal view returns (uint256, uint256, uint256) {\n        // Get the current D, then solve the stableswap invariant\n        // y_i for D - tokenAmount\n        uint256[] memory xp = _xp(self);\n\n        require(tokenIndex < xp.length, \"Token index out of range\");\n\n        CalculateWithdrawOneTokenDYInfo memory v = CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\n        v.preciseA = _getAPrecise(self);\n        v.d0 = getD(xp, v.preciseA);\n        v.d1 = v.d0.sub(tokenAmount.mul(v.d0).div(totalSupply));\n\n        require(tokenAmount <= xp[tokenIndex], \"Withdraw exceeds available\");\n\n        v.newY = getYD(v.preciseA, tokenIndex, xp, v.d1);\n\n        uint256[] memory xpReduced = new uint256[](xp.length);\n\n        v.feePerToken = _feePerToken(self.swapFee, xp.length);\n        for (uint256 i = 0; i < xp.length; i++) {\n            uint256 xpi = xp[i];\n            // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\n            // else dxExpected = xp[i] - (xp[i] * d1 / d0)\n            // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\n            xpReduced[i] = xpi.sub(\n                ((i == tokenIndex) ? xpi.mul(v.d1).div(v.d0).sub(v.newY) : xpi.sub(xpi.mul(v.d1).div(v.d0)))\n                    .mul(v.feePerToken)\n                    .div(FEE_DENOMINATOR)\n            );\n        }\n\n        uint256 dy = xpReduced[tokenIndex].sub(getYD(v.preciseA, tokenIndex, xpReduced, v.d1));\n        dy = dy.sub(1).div(self.tokenPrecisionMultipliers[tokenIndex]);\n\n        return (dy, v.newY, xp[tokenIndex]);\n    }\n\n    /**\n     * @notice Calculate the price of a token in the pool with given\n     * precision-adjusted balances and a particular D.\n     *\n     * @dev This is accomplished via solving the invariant iteratively.\n     * See the StableSwap paper and Curve.fi implementation for further details.\n     *\n     * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n     * x_1**2 + b*x_1 = c\n     * x_1 = (x_1**2 + c) / (2*x_1 + b)\n     *\n     * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\n     * @param tokenIndex Index of token we are calculating for.\n     * @param xp a precision-adjusted set of pool balances. Array should be\n     * the same cardinality as the pool.\n     * @param d the stableswap invariant\n     * @return the price of the token, in the same precision as in xp\n     */\n    function getYD(uint256 a, uint8 tokenIndex, uint256[] memory xp, uint256 d) internal pure returns (uint256) {\n        uint256 numTokens = xp.length;\n        require(tokenIndex < numTokens, \"Token not found\");\n\n        uint256 c = d;\n        uint256 s;\n        uint256 nA = a.mul(numTokens);\n\n        for (uint256 i = 0; i < numTokens; i++) {\n            if (i != tokenIndex) {\n                s = s.add(xp[i]);\n                c = c.mul(d).div(xp[i].mul(numTokens));\n                // If we were to protect the division loss we would have to keep the denominator separate\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\n                // c = c * D * D * D * ... overflow!\n            }\n        }\n        c = c.mul(d).mul(AmplificationUtils.A_PRECISION).div(nA.mul(numTokens));\n\n        uint256 b = s.add(d.mul(AmplificationUtils.A_PRECISION).div(nA));\n        uint256 yPrev;\n        uint256 y = d;\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            yPrev = y;\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\n            if (y.within1(yPrev)) {\n                return y;\n            }\n        }\n        revert(\"Approximation did not converge\");\n    }\n\n    /**\n     * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\n     * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\n     * as the pool.\n     * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\n     * See the StableSwap paper for details\n     * @return the invariant, at the precision of the pool\n     */\n    function getD(uint256[] memory xp, uint256 a) internal pure returns (uint256) {\n        uint256 numTokens = xp.length;\n        uint256 s;\n        for (uint256 i = 0; i < numTokens; i++) {\n            s = s.add(xp[i]);\n        }\n        if (s == 0) {\n            return 0;\n        }\n\n        uint256 prevD;\n        uint256 d = s;\n        uint256 nA = a.mul(numTokens);\n\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            uint256 dP = d;\n            for (uint256 j = 0; j < numTokens; j++) {\n                dP = dP.mul(d).div(xp[j].mul(numTokens));\n                // If we were to protect the division loss we would have to keep the denominator separate\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\n                // dP = dP * D * D * D * ... overflow!\n            }\n            prevD = d;\n            d = nA.mul(s).div(AmplificationUtils.A_PRECISION).add(dP.mul(numTokens)).mul(d).div(\n                nA.sub(AmplificationUtils.A_PRECISION).mul(d).div(AmplificationUtils.A_PRECISION).add(\n                    numTokens.add(1).mul(dP)\n                )\n            );\n            if (d.within1(prevD)) {\n                return d;\n            }\n        }\n\n        // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\n        // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\n        // function which does not rely on D.\n        revert(\"D does not converge\");\n    }\n\n    /**\n     * @notice Given a set of balances and precision multipliers, return the\n     * precision-adjusted balances.\n     *\n     * @param balances an array of token balances, in their native precisions.\n     * These should generally correspond with pooled tokens.\n     *\n     * @param precisionMultipliers an array of multipliers, corresponding to\n     * the amounts in the balances array. When multiplied together they\n     * should yield amounts at the pool's precision.\n     *\n     * @return an array of amounts \"scaled\" to the pool's precision\n     */\n    function _xp(\n        uint256[] memory balances,\n        uint256[] memory precisionMultipliers\n    ) internal pure returns (uint256[] memory) {\n        uint256 numTokens = balances.length;\n        require(numTokens == precisionMultipliers.length, \"Balances must match multipliers\");\n        uint256[] memory xp = new uint256[](numTokens);\n        for (uint256 i = 0; i < numTokens; i++) {\n            xp[i] = balances[i].mul(precisionMultipliers[i]);\n        }\n        return xp;\n    }\n\n    /**\n     * @notice Return the precision-adjusted balances of all tokens in the pool\n     * @param self Swap struct to read from\n     * @return the pool balances \"scaled\" to the pool's precision, allowing\n     * them to be more easily compared.\n     */\n    function _xp(Swap storage self) internal view returns (uint256[] memory) {\n        return _xp(self.balances, self.tokenPrecisionMultipliers);\n    }\n\n    /**\n     * @notice Get the virtual price, to help calculate profit\n     * @param self Swap struct to read from\n     * @return the virtual price, scaled to precision of POOL_PRECISION_DECIMALS\n     */\n    function getVirtualPrice(Swap storage self) external view returns (uint256) {\n        uint256 d = getD(_xp(self), _getAPrecise(self));\n        LPToken lpToken = self.lpToken;\n        uint256 supply = lpToken.totalSupply();\n        if (supply > 0) {\n            return d.mul(10 ** uint256(POOL_PRECISION_DECIMALS)).div(supply);\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Calculate the new balances of the tokens given the indexes of the token\n     * that is swapped from (FROM) and the token that is swapped to (TO).\n     * This function is used as a helper function to calculate how much TO token\n     * the user should receive on swap.\n     *\n     * @param preciseA precise form of amplification coefficient\n     * @param tokenIndexFrom index of FROM token\n     * @param tokenIndexTo index of TO token\n     * @param x the new total amount of FROM token\n     * @param xp balances of the tokens in the pool\n     * @return the amount of TO token that should remain in the pool\n     */\n    function getY(\n        uint256 preciseA,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 x,\n        uint256[] memory xp\n    ) internal pure returns (uint256) {\n        uint256 numTokens = xp.length;\n        require(tokenIndexFrom != tokenIndexTo, \"Can't compare token to itself\");\n        require(tokenIndexFrom < numTokens && tokenIndexTo < numTokens, \"Tokens must be in pool\");\n\n        uint256 d = getD(xp, preciseA);\n        uint256 c = d;\n        uint256 s;\n        uint256 nA = numTokens.mul(preciseA);\n\n        uint256 _x;\n        for (uint256 i = 0; i < numTokens; i++) {\n            if (i == tokenIndexFrom) {\n                _x = x;\n            } else if (i != tokenIndexTo) {\n                _x = xp[i];\n            } else {\n                continue;\n            }\n            s = s.add(_x);\n            c = c.mul(d).div(_x.mul(numTokens));\n            // If we were to protect the division loss we would have to keep the denominator separate\n            // and divide at the end. However this leads to overflow with large numTokens or/and D.\n            // c = c * D * D * D * ... overflow!\n        }\n        c = c.mul(d).mul(AmplificationUtils.A_PRECISION).div(nA.mul(numTokens));\n        uint256 b = s.add(d.mul(AmplificationUtils.A_PRECISION).div(nA));\n        uint256 yPrev;\n        uint256 y = d;\n\n        // iterative approximation\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            yPrev = y;\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\n            if (y.within1(yPrev)) {\n                return y;\n            }\n        }\n        revert(\"Approximation did not converge\");\n    }\n\n    /**\n     * @notice Externally calculates a swap between two tokens.\n     * @param self Swap struct to read from\n     * @param tokenIndexFrom the token to sell\n     * @param tokenIndexTo the token to buy\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @return dy the number of tokens the user will get\n     */\n    function calculateSwap(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 dy) {\n        (dy, ) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, self.balances);\n    }\n\n    /**\n     * @notice Internally calculates a swap between two tokens.\n     *\n     * @dev The caller is expected to transfer the actual amounts (dx and dy)\n     * using the token contracts.\n     *\n     * @param self Swap struct to read from\n     * @param tokenIndexFrom the token to sell\n     * @param tokenIndexTo the token to buy\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @return dy the number of tokens the user will get\n     * @return dyFee the associated fee\n     */\n    function _calculateSwap(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256[] memory balances\n    ) internal view returns (uint256 dy, uint256 dyFee) {\n        uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n        uint256[] memory xp = _xp(balances, multipliers);\n        require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, \"Token index out of range\");\n        uint256 x = dx.mul(multipliers[tokenIndexFrom]).add(xp[tokenIndexFrom]);\n        uint256 y = getY(_getAPrecise(self), tokenIndexFrom, tokenIndexTo, x, xp);\n        dy = xp[tokenIndexTo].sub(y).sub(1);\n        dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);\n        dy = dy.sub(dyFee).div(multipliers[tokenIndexTo]);\n    }\n\n    /**\n     * @notice A simple method to calculate amount of each underlying\n     * tokens that is returned upon burning given amount of\n     * LP tokens\n     *\n     * @param amount the amount of LP tokens that would to be burned on\n     * withdrawal\n     * @return array of amounts of tokens user will receive\n     */\n    function calculateRemoveLiquidity(Swap storage self, uint256 amount) external view returns (uint256[] memory) {\n        return _calculateRemoveLiquidity(self.balances, amount, self.lpToken.totalSupply());\n    }\n\n    function _calculateRemoveLiquidity(\n        uint256[] memory balances,\n        uint256 amount,\n        uint256 totalSupply\n    ) internal pure returns (uint256[] memory) {\n        require(amount <= totalSupply, \"Cannot exceed total supply\");\n\n        uint256[] memory amounts = new uint256[](balances.length);\n\n        for (uint256 i = 0; i < balances.length; i++) {\n            amounts[i] = balances[i].mul(amount).div(totalSupply);\n        }\n        return amounts;\n    }\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param self Swap struct to read from\n     * @param amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to pooledTokens. The amount should be in each\n     * pooled token's native precision. If a token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @param deposit whether this is a deposit or a withdrawal\n     * @return if deposit was true, total amount of lp token that will be minted and if\n     * deposit was false, total amount of lp token that will be burned\n     */\n    function calculateTokenAmount(\n        Swap storage self,\n        uint256[] calldata amounts,\n        bool deposit\n    ) external view returns (uint256) {\n        uint256 a = _getAPrecise(self);\n        uint256[] memory balances = self.balances;\n        uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n\n        uint256 d0 = getD(_xp(balances, multipliers), a);\n        for (uint256 i = 0; i < balances.length; i++) {\n            if (deposit) {\n                balances[i] = balances[i].add(amounts[i]);\n            } else {\n                balances[i] = balances[i].sub(amounts[i], \"Cannot withdraw more than available\");\n            }\n        }\n        uint256 d1 = getD(_xp(balances, multipliers), a);\n        uint256 totalSupply = self.lpToken.totalSupply();\n\n        if (deposit) {\n            return d1.sub(d0).mul(totalSupply).div(d0);\n        } else {\n            return d0.sub(d1).mul(totalSupply).div(d0);\n        }\n    }\n\n    /**\n     * @notice return accumulated amount of admin fees of the token with given index\n     * @param self Swap struct to read from\n     * @param index Index of the pooled token\n     * @return admin balance in the token's precision\n     */\n    function getAdminBalance(Swap storage self, uint256 index) external view returns (uint256) {\n        require(index < self.pooledTokens.length, \"Token index out of range\");\n        return self.pooledTokens[index].balanceOf(address(this)).sub(self.balances[index]);\n    }\n\n    /**\n     * @notice internal helper function to calculate fee per token multiplier used in\n     * swap fee calculations\n     * @param swapFee swap fee for the tokens\n     * @param numTokens number of tokens pooled\n     */\n    function _feePerToken(uint256 swapFee, uint256 numTokens) internal pure returns (uint256) {\n        return swapFee.mul(numTokens).div(numTokens.sub(1).mul(4));\n    }\n\n    /*** STATE MODIFYING FUNCTIONS ***/\n\n    /**\n     * @notice swap two tokens in the pool\n     * @param self Swap struct to read from and write to\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell\n     * @param minDy the min amount the user would like to receive, or revert.\n     * @return amount of token user received on swap\n     */\n    function swap(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        address receiver\n    ) external returns (uint256) {\n        {\n            IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n            require(dx <= tokenFrom.balanceOf(msg.sender), \"Cannot swap more than you own\");\n            // Transfer tokens first to see if a fee was charged on transfer\n            uint256 beforeBalance = tokenFrom.balanceOf(address(this));\n            tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\n\n            // Use the actual transferred amount for AMM math\n            dx = tokenFrom.balanceOf(address(this)).sub(beforeBalance);\n        }\n\n        uint256 dy;\n        uint256 dyFee;\n        uint256[] memory balances = self.balances;\n        (dy, dyFee) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, balances);\n        require(dy >= minDy, \"Swap didn't result in min tokens\");\n\n        uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\n            self.tokenPrecisionMultipliers[tokenIndexTo]\n        );\n\n        self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx);\n        self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy).sub(dyAdminFee);\n\n        self.pooledTokens[tokenIndexTo].safeTransfer(receiver, dy);\n\n        emit TokenSwap(receiver, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n        SwapFeeInfo memory swapFeeInfo;\n        swapFeeInfo.tokens = new address[](1);\n        swapFeeInfo.swapFees = new uint256[](1);\n        swapFeeInfo.tokens[0] = address(self.pooledTokens[tokenIndexTo]);\n        swapFeeInfo.swapFees[0] = dyFee.sub(dyAdminFee);\n        emit SwapFee(swapFeeInfo.tokens, swapFeeInfo.swapFees);\n\n        return dy;\n    }\n\n    /**\n     * @notice Add liquidity to the pool\n     * @param self Swap struct to read from and write to\n     * @param amounts the amounts of each token to add, in their native precision\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\n     * @param receiver recipient address\n     * @return amount of LP token user received\n     */\n    function addLiquidity(\n        Swap storage self,\n        uint256[] memory amounts,\n        uint256 minToMint,\n        address receiver\n    ) external returns (uint256) {\n        IERC20[] memory pooledTokens = self.pooledTokens;\n        require(amounts.length == pooledTokens.length, \"Amounts must match pooled tokens\");\n\n        // current state\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\n            0,\n            0,\n            0,\n            _getAPrecise(self),\n            self.lpToken,\n            0,\n            self.balances,\n            self.tokenPrecisionMultipliers\n        );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        if (v.totalSupply != 0) {\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n        }\n\n        uint256[] memory newBalances = new uint256[](pooledTokens.length);\n\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\n            require(v.totalSupply != 0 || amounts[i] > 0, \"Must supply all tokens in pool\");\n\n            // Transfer tokens first to see if a fee was charged on transfer\n            if (amounts[i] != 0) {\n                uint256 beforeBalance = pooledTokens[i].balanceOf(address(this));\n                pooledTokens[i].safeTransferFrom(msg.sender, address(this), amounts[i]);\n\n                // Update the amounts[] with actual transfer amount\n                amounts[i] = pooledTokens[i].balanceOf(address(this)).sub(beforeBalance);\n            }\n\n            newBalances[i] = v.balances[i].add(amounts[i]);\n        }\n\n        // invariant after change\n        v.d1 = getD(_xp(newBalances, v.multipliers), v.preciseA);\n        require(v.d1 > v.d0, \"D should increase\");\n\n        // updated to reflect fees and calculate the user's LP tokens\n        v.d2 = v.d1;\n        uint256[] memory fees = new uint256[](pooledTokens.length);\n\n        if (v.totalSupply != 0) {\n            uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\n\n            SwapFeeInfo memory swapFeeInfo;\n            swapFeeInfo.tokens = new address[](fees.length);\n            swapFeeInfo.swapFees = new uint256[](fees.length);\n            swapFeeInfo.adminFeeRate = self.adminFee;\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\n                fees[i] = feePerToken.mul(idealBalance.difference(newBalances[i])).div(FEE_DENOMINATOR);\n\n                swapFeeInfo.adminFee = fees[i].mul(swapFeeInfo.adminFeeRate).div(FEE_DENOMINATOR);\n\n                self.balances[i] = newBalances[i].sub(swapFeeInfo.adminFee);\n                newBalances[i] = newBalances[i].sub(fees[i]);\n\n                swapFeeInfo.tokens[i] = address(pooledTokens[i]);\n                swapFeeInfo.swapFees[i] = fees[i].sub(swapFeeInfo.adminFee);\n            }\n\n            emit SwapFee(swapFeeInfo.tokens, swapFeeInfo.swapFees);\n\n            v.d2 = getD(_xp(newBalances, v.multipliers), v.preciseA);\n        } else {\n            // the initial depositor doesn't pay fees\n            self.balances = newBalances;\n        }\n\n        uint256 toMint;\n        if (v.totalSupply == 0) {\n            toMint = v.d1;\n        } else {\n            toMint = v.d2.sub(v.d0).mul(v.totalSupply).div(v.d0);\n        }\n\n        require(toMint >= minToMint, \"Couldn't mint min requested\");\n\n        // mint the user's LP tokens\n        v.lpToken.mint(receiver, toMint);\n\n        emit AddLiquidity(receiver, amounts, fees, v.d1, v.totalSupply.add(toMint));\n\n        return toMint;\n    }\n\n    /**\n     * @notice Burn LP tokens to remove liquidity from the pool.\n     * @dev Liquidity can always be removed, even when the pool is paused.\n     * @param self Swap struct to read from and write to\n     * @param amount the amount of LP tokens to burn\n     * @param minAmounts the minimum amounts of each token in the pool\n     * acceptable for this burn. Useful as a front-running mitigation\n     * @param receiver recipient address\n     * @return amounts of tokens the user received\n     */\n    function removeLiquidity(\n        Swap storage self,\n        uint256 amount,\n        uint256[] calldata minAmounts,\n        address receiver\n    ) external returns (uint256[] memory) {\n        LPToken lpToken = self.lpToken;\n        IERC20[] memory pooledTokens = self.pooledTokens;\n        require(amount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n        require(minAmounts.length == pooledTokens.length, \"minAmounts must match poolTokens\");\n\n        uint256[] memory balances = self.balances;\n        uint256 totalSupply = lpToken.totalSupply();\n\n        uint256[] memory amounts = _calculateRemoveLiquidity(balances, amount, totalSupply);\n\n        for (uint256 i = 0; i < amounts.length; i++) {\n            require(amounts[i] >= minAmounts[i], \"amounts[i] < minAmounts[i]\");\n            self.balances[i] = balances[i].sub(amounts[i]);\n            pooledTokens[i].safeTransfer(receiver, amounts[i]);\n        }\n\n        lpToken.burnFrom(msg.sender, amount);\n\n        emit RemoveLiquidity(receiver, amounts, totalSupply.sub(amount));\n\n        return amounts;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool all in one token.\n     * @param self Swap struct to read from and write to\n     * @param tokenAmount the amount of the lp tokens to burn\n     * @param tokenIndex the index of the token you want to receive\n     * @param minAmount the minimum amount to withdraw, otherwise revert\n     * @param receiver recipient address\n     * @return amount chosen token that user received\n     */\n    function removeLiquidityOneToken(\n        Swap storage self,\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        address receiver\n    ) external returns (uint256) {\n        LPToken lpToken = self.lpToken;\n        IERC20[] memory pooledTokens = self.pooledTokens;\n\n        require(tokenAmount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n        require(tokenIndex < pooledTokens.length, \"Token not found\");\n\n        uint256 totalSupply = lpToken.totalSupply();\n\n        (uint256 dy, uint256 dyFee) = _calculateWithdrawOneToken(self, tokenAmount, tokenIndex, totalSupply);\n\n        require(dy >= minAmount, \"dy < minAmount\");\n\n        uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR);\n\n        self.balances[tokenIndex] = self.balances[tokenIndex].sub(dy.add(dyAdminFee));\n        lpToken.burnFrom(msg.sender, tokenAmount);\n        pooledTokens[tokenIndex].safeTransfer(receiver, dy);\n\n        emit RemoveLiquidityOne(receiver, tokenAmount, totalSupply, tokenIndex, dy);\n\n        SwapFeeInfo memory swapFeeInfo;\n        swapFeeInfo.tokens = new address[](1);\n        swapFeeInfo.swapFees = new uint256[](1);\n        swapFeeInfo.tokens[0] = address(pooledTokens[tokenIndex]);\n        swapFeeInfo.swapFees[0] = dyFee.sub(dyAdminFee);\n        emit SwapFee(swapFeeInfo.tokens, swapFeeInfo.swapFees);\n\n        return dy;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances.\n     *\n     * @param self Swap struct to read from and write to\n     * @param amounts how much of each token to withdraw\n     * @param maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     * @param receiver recipient address\n     * @return actual amount of LP tokens burned in the withdrawal\n     */\n    function removeLiquidityImbalance(\n        Swap storage self,\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount,\n        address receiver\n    ) external returns (uint256) {\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\n            0,\n            0,\n            0,\n            _getAPrecise(self),\n            self.lpToken,\n            0,\n            self.balances,\n            self.tokenPrecisionMultipliers\n        );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        IERC20[] memory pooledTokens = self.pooledTokens;\n\n        require(amounts.length == pooledTokens.length, \"Amounts should match pool tokens\");\n\n        require(maxBurnAmount <= v.lpToken.balanceOf(msg.sender) && maxBurnAmount != 0, \">LP.balanceOf\");\n\n        uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\n        uint256[] memory fees = new uint256[](pooledTokens.length);\n        {\n            uint256[] memory balances1 = new uint256[](pooledTokens.length);\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                balances1[i] = v.balances[i].sub(amounts[i], \"Cannot withdraw more than available\");\n            }\n            v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\n\n            SwapFeeInfo memory swapFeeInfo;\n            swapFeeInfo.tokens = new address[](fees.length);\n            swapFeeInfo.swapFees = new uint256[](fees.length);\n            swapFeeInfo.adminFeeRate = self.adminFee;\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n\n                swapFeeInfo.adminFee = fees[i].mul(swapFeeInfo.adminFeeRate).div(FEE_DENOMINATOR);\n\n                self.balances[i] = balances1[i].sub(swapFeeInfo.adminFee);\n                balances1[i] = balances1[i].sub(fees[i]);\n\n                swapFeeInfo.tokens[i] = address(pooledTokens[i]);\n                swapFeeInfo.swapFees[i] = fees[i].sub(swapFeeInfo.adminFee);\n            }\n\n            emit SwapFee(swapFeeInfo.tokens, swapFeeInfo.swapFees);\n\n            v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\n        }\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n        tokenAmount = tokenAmount.add(1);\n\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\n\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\n            pooledTokens[i].safeTransfer(receiver, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(receiver, amounts, fees, v.d1, v.totalSupply.sub(tokenAmount));\n\n        return tokenAmount;\n    }\n\n    /**\n     * @notice withdraw all admin fees to a given address\n     * @param self Swap struct to withdraw fees from\n     * @param to Address to send the fees to\n     */\n    function withdrawAdminFees(Swap storage self, address to) external returns (uint256[] memory) {\n        IERC20[] memory pooledTokens = self.pooledTokens;\n        uint256[] memory amounts = new uint256[](pooledTokens.length);\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\n            IERC20 token = pooledTokens[i];\n            uint256 balance = token.balanceOf(address(this)).sub(self.balances[i]);\n            amounts[i] = balance;\n            if (balance != 0) {\n                token.safeTransfer(to, balance);\n            }\n        }\n        return amounts;\n    }\n\n    /**\n     * @notice Sets the admin fee\n     * @dev adminFee cannot be higher than 100% of the swap fee\n     * @param self Swap struct to update\n     * @param newAdminFee new admin fee to be applied on future transactions\n     */\n    function setAdminFee(Swap storage self, uint256 newAdminFee) external {\n        require(newAdminFee <= MAX_ADMIN_FEE, \"Fee is too high\");\n        self.adminFee = newAdminFee;\n\n        emit NewAdminFee(newAdminFee);\n    }\n\n    /**\n     * @notice update the swap fee\n     * @dev fee cannot be higher than 1% of each swap\n     * @param self Swap struct to update\n     * @param newSwapFee new swap fee to be applied on future transactions\n     */\n    function setSwapFee(Swap storage self, uint256 newSwapFee) external {\n        require(newSwapFee <= MAX_SWAP_FEE, \"Fee is too high\");\n        self.swapFee = newSwapFee;\n\n        emit NewSwapFee(newSwapFee);\n    }\n}\n"
    },
    "contracts/utils/TransferHelper.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/**\n * @dev Library for safely executing transfers and approvals of ERC20 tokens and ETH.\n */\nlibrary TransferHelper {\n    /**\n     * @dev Safely approves `value` tokens for `to` by calling the `approve` function on `token`.\n     * @param token The address of the ERC20 token.\n     * @param to The address to approve tokens for.\n     * @param value The number of tokens to approve.\n     */\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: APPROVE_FAILED\");\n    }\n\n    /**\n     * @dev Safely transfers `value` tokens to `to` by calling the `transfer` function on `token`.\n     * @param token The address of the ERC20 token.\n     * @param to The address to transfer tokens to.\n     * @param value The number of tokens to transfer.\n     */\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FAILED\");\n    }\n\n    /**\n     * @dev Safely transfers `value` tokens from `from` to `to` by calling the `transferFrom` function on `token`.\n     * @param token The address of the ERC20 token.\n     * @param from The address to transfer tokens from.\n     * @param to The address to transfer tokens to.\n     * @param value The number of tokens to transfer.\n     */\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FROM_FAILED\");\n    }\n\n    /**\n     * @dev Safely transfers `value` ETH to `to`.\n     * @param to The address to transfer ETH to.\n     * @param value The amount of ETH to transfer.\n     */\n    function safeTransferETH(address to, uint value) internal {\n        (bool success, ) = to.call{ value: value }(new bytes(0));\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n    }\n}\n"
    },
    "contracts/utils/UQ112x112.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2 ** 112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n"
    },
    "contracts/VolatilePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./lib/PairERC20.sol\";\nimport { IVolatilePair } from \"./interface/IPair.sol\";\n\nimport \"./utils/UQ112x112.sol\";\nimport \"./utils/ERC20Call.sol\";\nimport \"./utils/Math.sol\";\n\nimport \"./interface/IPairCallee.sol\";\nimport \"./interface/IPairFactory.sol\";\n\n/**\n * @title VolatilePair\n * @dev This contract implements the VolatilePair interface and inherits from the PairERC20 contract.\n * It also uses the Initializable contract from the OpenZeppelin library.\n */\ncontract VolatilePair is Initializable, PairERC20, IVolatilePair {\n    using SafeMath for uint256;\n    using UQ112x112 for uint224;\n    using ERC20Call for address;\n\n    // Minimum liquidity required to add to the pool\n    uint256 public constant MINIMUM_LIQUIDITY = 10**3;\n    // Selector for transfer function\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n    // Address of the factory that created the pair\n    address public factory;\n    // Address of token0\n    address public override token0;\n    // Address of token1\n    address public override token1;\n\n    // Reserve of token0\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\n    // Reserve of token1\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\n    // Block timestamp of the last liquidity event\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint256 public price0CumulativeLast;\n    uint256 public price1CumulativeLast;\n    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    // This variable is used to prevent reentrancy attacks\n    uint256 private unlocked;\n\n    // The type of the pair, 1 for volatile pair\n    uint8 public constant override PAIR_TYPE = 1;\n\n    // Whether or not the pair requires authorization\n    bool public constant override AUTH = false;\n\n    // The denominator used for calculating fees\n    uint256 public constant FEE_DENOMINATOR = 10**10;\n\n    // The maximum swap fee rate\n    uint256 public constant MAX_SWAP_FEE = 10**8;\n\n    // The maximum admin fee rate\n    uint256 public constant MAX_ADMIN_FEE = 10**10;\n\n    // The current swap fee rate\n    uint256 public swapFeeRate;\n\n    // The current admin fee rate\n    uint256 public adminFeeRate;\n\n    // The total admin fee for token0\n    uint256 public totalAdminFee0;\n\n    // The total admin fee for token1\n    uint256 public totalAdminFee1;\n\n    /**\n     * @dev Emitted when liquidity is added to the pool\n     * @param sender The address of the sender\n     * @param amount0 The amount of token0 added\n     * @param amount1 The amount of token1 added\n     */\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n\n    /**\n     * @dev Emitted when liquidity is removed from the pool\n     * @param sender The address of the sender\n     * @param amount0 The amount of token0 removed\n     * @param amount1 The amount of token1 removed\n     * @param to The address that receives the tokens\n     */\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n\n    /**\n     * @dev Emitted when a swap occurs\n     * @param sender The address of the sender\n     * @param amount0In The amount of token0 being swapped in\n     * @param amount1In The amount of token1 being swapped in\n     * @param amount0Out The amount of token0 being swapped out\n     * @param amount1Out The amount of token1 being swapped out\n     * @param to The address that receives the swapped tokens\n     */\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n\n    /**\n     * @dev Emitted when the swap fee rate is updated\n     * @param tokens The addresses of the tokens in the pair\n     * @param swapFees The new swap fee rates for each token\n     */\n    event SwapFee(address[] tokens, uint256[] swapFees);\n\n    /**\n     * @dev Emitted when the reserves are synced\n     * @param reserve0 The reserve of token0\n     * @param reserve1 The reserve of token1\n     */\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    /**\n     * @dev Emitted when admin fees are claimed\n     * @param token0 The address of token0\n     * @param token1 The address of token1\n     * @param amount0 The amount of token0 claimed\n     * @param amount1 The amount of token1 claimed\n     */\n    event ClaimFees(address token0, address token1, uint256 amount0, uint256 amount1);\n\n    /**\n     * @dev Emitted when the swap fee rate is updated\n     * @param oldSwapFeeRate The old swap fee rate\n     * @param newSwapFeeRate The new swap fee rate\n     */\n    event SetSwapFeeRate(uint256 oldSwapFeeRate, uint256 newSwapFeeRate);\n\n    /**\n     * @dev Emitted when the admin fee rate is updated\n     * @param oldAdminFeeRate The old admin fee rate\n     * @param newAdminFeeRate The new admin fee rate\n     */\n    event SetAdminFeeRate(uint256 oldAdminFeeRate, uint256 newAdminFeeRate);\n\n    /**\n     * @dev Initializes the VolatilePair contract\n     * @param _tokens The addresses of the tokens in the pair\n     * @param _data The encoded swap fee rate and admin fee rate\n     */\n    function initialize(address[] memory _tokens, bytes memory _data) external override initializer {\n        factory = msg.sender;\n        unlocked = 1;\n        require(_tokens.length == 2, \"VolatilePair: This type of pair must have only two tokens when created\");\n        require(_tokens[0] != _tokens[1], \"VolatilePair: Token cannot be the same\");\n        (token0, token1) = (_tokens[0], _tokens[1]);\n        (uint256 _swapfeeRate, uint256 _adminFeeRate) = abi.decode(_data, (uint256, uint256));\n\n        require(_swapfeeRate <= MAX_SWAP_FEE, \"VolatilePair: SwapFee is greater than the maximum value\");\n        require(_adminFeeRate <= MAX_ADMIN_FEE, \"VolatilePair: AdminFee is greater than the maximum value\");\n        (swapFeeRate, adminFeeRate) = (_swapfeeRate, _adminFeeRate);\n\n        _initialize(\n            string(abi.encodePacked(\"dForce AMM Volatile - \", _tokens[0].callSymbol(), \"-\", _tokens[1].callSymbol())),\n            string(abi.encodePacked(\"vAMM-\", _tokens[0].callSymbol(), \"-\", _tokens[1].callSymbol()))\n        );\n    }\n\n    /**\n     * @dev Modifier to prevent reentrancy\n     */\n    modifier lock() {\n        require(unlocked == 1, \"VolatilePair: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    /**\n     * @dev Modifier to restrict access to only the manager\n     */\n    modifier onlyManager() {\n        require(msg.sender == IPairFactory(factory).manager(), \"VolatilePair: not manager\");\n        _;\n    }\n\n    /**\n     * @dev Returns the tokens in the pair\n     */\n    function tokens() external view override returns (address[] memory) {\n        return _tokens();\n    }\n\n    /**\n     * @dev Returns the reserves and the timestamp of the last block when they were updated\n     */\n    function getReserves()\n        external\n        view\n        override\n        returns (\n            uint112,\n            uint112,\n            uint32\n        )\n    {\n        return _getReserves();\n    }\n\n    /**\n     * @dev Returns the real balance of each token in the pair, excluding the admin fee\n     */\n    function getRealBalanceOf() external view override returns (uint256, uint256) {\n        return _getRealBalanceOf();\n    }\n\n    /**\n     * @dev Returns the amount of output tokens given an input amount of a token\n     * @param _from The address of the input token\n     * @param _to The address of the output token\n     * @param _amount The input amount of the token\n     */\n    function getAmountOut(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external view override returns (uint256) {\n        _to;\n        (uint256 _reserveA, uint256 _reserveB) = _from == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n        return _getAmountOut(_amount, _reserveA, _reserveB);\n    }\n\n    /**\n     * @dev Returns the tokens in the pair\n     */\n    function _tokens() internal view returns (address[] memory _tokenList) {\n        _tokenList = new address[](2);\n        _tokenList[0] = token0;\n        _tokenList[1] = token1;\n    }\n\n    /**\n     * @dev Returns the reserves and the timestamp of the last block when they were updated\n     */\n    function _getReserves()\n        internal\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    /**\n     * @dev Returns the real balance of each token in the pair, excluding the admin fee\n     */\n    function _getRealBalanceOf() internal view returns (uint256, uint256) {\n        return (\n            IERC20(token0).balanceOf(address(this)).sub(totalAdminFee0),\n            IERC20(token1).balanceOf(address(this)).sub(totalAdminFee1)\n        );\n    }\n\n    /**\n     * @dev Returns the amount of output tokens given an input amount of a token\n     * @param _amountIn The input amount of the token\n     * @param _reserveIn The reserve of the input token\n     * @param _reserveOut The reserve of the output token\n     */\n    function _getAmountOut(\n        uint256 _amountIn,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    ) internal view returns (uint256 _amountOut) {\n        require(_amountIn > 0, \"VolatilePair: INSUFFICIENT_INPUT_AMOUNT\");\n        require(_reserveIn > 0 && _reserveOut > 0, \"VolatilePair: INSUFFICIENT_LIQUIDITY\");\n        uint256 _amountInWithFee = _amountIn.mul(FEE_DENOMINATOR - swapFeeRate);\n        uint256 _numerator = _amountInWithFee.mul(_reserveOut);\n        uint256 _denominator = _reserveIn.mul(FEE_DENOMINATOR).add(_amountInWithFee);\n        _amountOut = _numerator / _denominator;\n    }\n\n    /**\n     * @dev Safely transfers tokens\n     * @param _token The address of the token to transfer\n     * @param _to The address to transfer the tokens to\n     * @param _value The amount of tokens to transfer\n     */\n    function _safeTransfer(\n        address _token,\n        address _to,\n        uint256 _value\n    ) private {\n        (bool _success, bytes memory _data) = _token.call(abi.encodeWithSelector(SELECTOR, _to, _value));\n        require(_success && (_data.length == 0 || abi.decode(_data, (bool))), \"VolatilePair: TRANSFER_FAILED\");\n    }\n\n    /**\n     * @dev Updates the reserves and price accumulators for the pair\n     * @param _balance0 The current balance of token0 in the pair\n     * @param _balance1 The current balance of token1 in the pair\n     * @param _reserve0 The current reserve of token0 in the pair\n     * @param _reserve1 The current reserve of token1 in the pair\n     */\n    function _update(\n        uint256 _balance0,\n        uint256 _balance1,\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) private {\n        require(_balance0 <= uint112(-1) && _balance1 <= uint112(-1), \"VolatilePair: OVERFLOW\");\n        uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 _timeElapsed = _blockTimestamp - blockTimestampLast; // overflow is desired\n        if (_timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // Calculate the price accumulators for token0 and token1\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * _timeElapsed;\n            price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * _timeElapsed;\n        }\n        reserve0 = uint112(_balance0);\n        reserve1 = uint112(_balance1);\n        blockTimestampLast = _blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    /**\n     * @dev Updates the admin fee for the pair\n     * @param _amountIn0 The input amount of token0\n     * @param _amountIn1 The input amount of token1\n     * @return _swapFee0 The swap fee for token0\n     * @return _swapFee1 The swap fee for token1\n     */\n    function _updateAdminFee(uint256 _amountIn0, uint256 _amountIn1)\n        internal\n        returns (uint256 _swapFee0, uint256 _swapFee1)\n    {\n        uint256 _totalFee0 = _amountIn0.mul(swapFeeRate).div(FEE_DENOMINATOR);\n        uint256 _totalFee1 = _amountIn1.mul(swapFeeRate).div(FEE_DENOMINATOR);\n\n        {\n            uint256 _adminFee0 = _totalFee0.mul(adminFeeRate).div(FEE_DENOMINATOR);\n            uint256 _adminFee1 = _totalFee1.mul(adminFeeRate).div(FEE_DENOMINATOR);\n\n            _swapFee0 = _totalFee0 - _adminFee0;\n            _swapFee1 = _totalFee1 - _adminFee1;\n\n            totalAdminFee0 += _adminFee0;\n            totalAdminFee1 += _adminFee1;\n        }\n    }\n\n    /**\n     * @dev Mint liquidity tokens to the caller and add corresponding reserves\n     * @param _to The address to mint liquidity tokens to\n     * @return _liquidity The amount of liquidity tokens minted\n     */\n    function mint(address _to) external override lock returns (uint256 _liquidity) {\n        (uint112 _reserve0, uint112 _reserve1, ) = _getReserves(); // gas savings\n        (uint256 _balance0, uint256 _balance1) = _getRealBalanceOf();\n        uint256 _amount0 = _balance0.sub(_reserve0);\n        uint256 _amount1 = _balance1.sub(_reserve1);\n\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            _liquidity = Math.sqrt(_amount0.mul(_amount1)).sub(MINIMUM_LIQUIDITY);\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            _liquidity = Math.min(_amount0.mul(_totalSupply) / _reserve0, _amount1.mul(_totalSupply) / _reserve1);\n        }\n        require(_liquidity > 0, \"VolatilePair: INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(_to, _liquidity);\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Mint(msg.sender, _amount0, _amount1); // Emit a Mint event with the amount of token0 and token1 minted\n    }\n\n    /**\n     * @dev Burn liquidity tokens from the caller and remove corresponding reserves\n     * @param _to The address to send the tokens to\n     * @return _amount0 The amount of token0 burned\n     * @return _amount1 The amount of token1 burned\n     */\n    function burn(address _to) external override lock returns (uint256 _amount0, uint256 _amount1) {\n        (uint112 _reserve0, uint112 _reserve1, ) = _getReserves(); // gas savings\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        (uint256 _balance0, uint256 _balance1) = _getRealBalanceOf();\n        uint256 _liquidity = balanceOf[address(this)];\n\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        _amount0 = _liquidity.mul(_balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        _amount1 = _liquidity.mul(_balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(_amount0 > 0 && _amount1 > 0, \"VolatilePair: INSUFFICIENT_LIQUIDITY_BURNED\");\n        _burn(address(this), _liquidity);\n        _safeTransfer(_token0, _to, _amount0);\n        _safeTransfer(_token1, _to, _amount1);\n\n        (_balance0, _balance1) = _getRealBalanceOf();\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Burn(msg.sender, _amount0, _amount1, _to); // Emit a Burn event with the amount of token0 and token1 burned and the address they were sent to\n    }\n\n    /**\n     * @dev Low-level function for swapping tokens\n     * @param _amount0Out The amount of token0 to receive\n     * @param _amount1Out The amount of token1 to receive\n     * @param _to The address to send the tokens to\n     * @param _data Additional data with no specified format, sent in call to `_to`\n     */\n    function swap(\n        uint256 _amount0Out,\n        uint256 _amount1Out,\n        address _to,\n        bytes calldata _data\n    ) external override lock {\n        require(_amount0Out > 0 || _amount1Out > 0, \"VolatilePair: INSUFFICIENT_OUTPUT_AMOUNT\");\n        (uint112 _reserve0, uint112 _reserve1, ) = _getReserves(); // gas savings\n        require(_amount0Out < _reserve0 && _amount1Out < _reserve1, \"VolatilePair: INSUFFICIENT_LIQUIDITY\");\n\n        uint256 _balance0;\n        uint256 _balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(_to != _token0 && _to != _token1, \"VolatilePair: INVALID_TO\");\n            if (_amount0Out > 0) _safeTransfer(_token0, _to, _amount0Out); // optimistically transfer tokens\n            if (_amount1Out > 0) _safeTransfer(_token1, _to, _amount1Out); // optimistically transfer tokens\n            if (_data.length > 0) IPairCallee(_to).hook(msg.sender, _amount0Out, _amount1Out, _data);\n            (_balance0, _balance1) = _getRealBalanceOf();\n        }\n        uint256 _amount0In = _balance0 > _reserve0 - _amount0Out ? _balance0 - (_reserve0 - _amount0Out) : 0;\n        uint256 _amount1In = _balance1 > _reserve1 - _amount1Out ? _balance1 - (_reserve1 - _amount1Out) : 0;\n        require(_amount0In > 0 || _amount1In > 0, \"VolatilePair: INSUFFICIENT_INPUT_AMOUNT\");\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            uint256 _balance0Adjusted = _balance0.mul(FEE_DENOMINATOR).sub(_amount0In.mul(swapFeeRate));\n            uint256 _balance1Adjusted = _balance1.mul(FEE_DENOMINATOR).sub(_amount1In.mul(swapFeeRate));\n            require(\n                _balance0Adjusted.mul(_balance1Adjusted) >= uint256(_reserve0).mul(_reserve1).mul(FEE_DENOMINATOR**2),\n                \"VolatilePair: K\"\n            );\n\n            //update totalAdminFee and balance\n            (uint256 _swapFee0, uint256 _swapFee1) = _updateAdminFee(_amount0In, _amount1In);\n\n            uint256[] memory _swapFees = new uint256[](2);\n            (_swapFees[0], _swapFees[1]) = (_swapFee0, _swapFee1);\n            emit SwapFee(_tokens(), _swapFees);\n        }\n\n        (_balance0, _balance1) = _getRealBalanceOf();\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n\n        emit Swap(msg.sender, _amount0In, _amount1In, _amount0Out, _amount1Out, _to);\n    }\n\n    /**\n     * @dev Skim the excess tokens from the contract and send them to the specified address\n     * @param _to The address to send the excess tokens to\n     */\n    function skim(address _to) external override lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        (uint256 _balance0, uint256 _balance1) = _getRealBalanceOf();\n        _safeTransfer(_token0, _to, _balance0.sub(reserve0)); // Transfer the excess token0 balance to the specified address\n        _safeTransfer(_token1, _to, _balance1.sub(reserve1)); // Transfer the excess token1 balance to the specified address\n    }\n\n    /**\n     * @dev Update reserves to match balances\n     */\n    function sync() external override lock {\n        (uint256 _balance0, uint256 _balance1) = _getRealBalanceOf();\n        _update(_balance0, _balance1, reserve0, reserve1);\n    }\n\n    /**\n     * @dev Claim admin fees\n     * @return _adminFees An array of admin fees\n     */\n    function claimFees() external override returns (uint256[] memory _adminFees) {\n        address _manager = IPairFactory(factory).manager();\n        _adminFees = new uint256[](2);\n\n        (_adminFees[0], _adminFees[1]) = (totalAdminFee0, totalAdminFee1);\n        (totalAdminFee0, totalAdminFee1) = (0, 0);\n\n        _safeTransfer(token0, _manager, _adminFees[0]);\n        _safeTransfer(token1, _manager, _adminFees[1]);\n        emit ClaimFees(token0, token1, _adminFees[0], _adminFees[1]);\n    }\n\n    /**\n     * @dev Set swap fee rate\n     * @param _swapFeeRate The new swap fee rate\n     */\n    function setSwapFeeRate(uint256 _swapFeeRate) external onlyManager {\n        require(_swapFeeRate <= MAX_SWAP_FEE, \"VolatilePair: SwapFee is greater than the maximum value\");\n        uint256 _old = swapFeeRate;\n        swapFeeRate = _swapFeeRate;\n        emit SetSwapFeeRate(_old, _swapFeeRate);\n    }\n\n    /**\n     * @dev Set admin fee rate\n     * @param _adminFeeRate The new admin fee rate\n     */\n    function setAdminFeeRate(uint256 _adminFeeRate) external onlyManager {\n        require(_adminFeeRate <= MAX_ADMIN_FEE, \"VolatilePair: AdminFee is greater than the maximum value\");\n        uint256 _old = adminFeeRate;\n        adminFeeRate = _adminFeeRate;\n        emit SetAdminFeeRate(_old, _adminFeeRate);\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}