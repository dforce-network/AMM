{
  "language": "Solidity",
  "sources": {
    "contracts/test/DF.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2019-07-30\n */\n\npragma solidity ^0.5.2;\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function div(uint x, uint y) internal pure returns (uint z) {\n        require(y > 0, \"ds-math-div-overflow\");\n        z = x / y;\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n\n    // function imin(int x, int y) internal pure returns (int z) {\n    //     return x <= y ? x : y;\n    // }\n    // function imax(int x, int y) internal pure returns (int z) {\n    //     return x >= y ? x : y;\n    // }\n\n    uint constant WAD = 10 ** 18;\n\n    // uint constant RAY = 10 ** 27;\n\n    // function wmul(uint x, uint y) internal pure returns (uint z) {\n    //     z = add(mul(x, y), WAD / 2) / WAD;\n    // }\n    // function rmul(uint x, uint y) internal pure returns (uint z) {\n    //     z = add(mul(x, y), RAY / 2) / RAY;\n    // }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    // function rdiv(uint x, uint y) internal pure returns (uint z) {\n    //     z = add(mul(x, RAY), y / 2) / y;\n    // }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    // function rpow(uint _x, uint n) internal pure returns (uint z) {\n    //     uint x = _x;\n    //     z = n % 2 != 0 ? x : RAY;\n\n    //     for (n /= 2; n != 0; n /= 2) {\n    //         x = rmul(x, x);\n\n    //         if (n % 2 != 0) {\n    //             z = rmul(z, x);\n    //         }\n    //     }\n    // }\n\n    /**\n     * @dev x to the power of y power(base, exponent)\n     */\n    function pow(uint256 base, uint256 exponent) public pure returns (uint256) {\n        if (exponent == 0) {\n            return 1;\n        } else if (exponent == 1) {\n            return base;\n        } else if (base == 0 && exponent != 0) {\n            return 0;\n        } else {\n            uint256 z = base;\n            for (uint256 i = 1; i < exponent; i++) z = mul(z, base);\n            return z;\n        }\n    }\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority(address indexed authority);\n    event LogSetOwner(address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    address public authority;\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_) public onlyOwner {\n        require(owner_ != address(0), \"invalid owner address\");\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(address authority_) public onlyOwner {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth() {\n        require(isAuthorized(msg.sender), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(isOwner(msg.sender), \"ds-auth-non-owner\");\n        _;\n    }\n\n    function isOwner(address src) public view returns (bool) {\n        return bool(src == owner);\n    }\n\n    function isAuthorized(address src) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == address(0)) {\n            return false;\n        } else if (src == authority) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\ncontract DSNote {\n    event LogNote(\n        bytes4 indexed sig,\n        address indexed guy,\n        bytes32 indexed foo,\n        bytes32 indexed bar,\n        uint256 wad,\n        bytes fax\n    ) anonymous;\n\n    modifier note() {\n        bytes32 foo;\n        bytes32 bar;\n        uint256 wad;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n            wad := callvalue\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n\n        _;\n    }\n}\n\ncontract DSStop is DSNote, DSAuth, DSMath {\n    bool public stopped;\n\n    modifier stoppable() {\n        require(!stopped, \"ds-stop-is-stopped\");\n        _;\n    }\n\n    function stop() public onlyOwner note {\n        stopped = true;\n    }\n\n    function start() public onlyOwner note {\n        stopped = false;\n    }\n}\n\ncontract ERC20Events {\n    event Approval(address indexed src, address indexed guy, uint wad);\n    event Transfer(address indexed src, address indexed dst, uint wad);\n}\n\ncontract ERC20 is ERC20Events {\n    function totalSupply() public view returns (uint);\n\n    function balanceOf(address guy) public view returns (uint);\n\n    function allowance(address src, address guy) public view returns (uint);\n\n    function approve(address guy, uint wad) public returns (bool);\n\n    function transfer(address dst, uint wad) public returns (bool);\n\n    function transferFrom(address src, address dst, uint wad) public returns (bool);\n}\n\ncontract DSTokenBase is ERC20, DSMath {\n    uint256 _supply;\n    mapping(address => uint256) _balances;\n    mapping(address => mapping(address => uint256)) _approvals;\n\n    constructor(uint supply) public {\n        _supply = supply;\n    }\n\n    function totalSupply() public view returns (uint) {\n        return _supply;\n    }\n\n    function balanceOf(address src) public view returns (uint) {\n        return _balances[src];\n    }\n\n    function allowance(address src, address guy) public view returns (uint) {\n        return _approvals[src][guy];\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad) public returns (bool) {\n        if (src != msg.sender) {\n            require(_approvals[src][msg.sender] >= wad, \"ds-token-insufficient-approval\");\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n        }\n\n        require(_balances[src] >= wad, \"ds-token-insufficient-balance\");\n        _balances[src] = sub(_balances[src], wad);\n        _balances[dst] = add(_balances[dst], wad);\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        _approvals[msg.sender][guy] = wad;\n\n        emit Approval(msg.sender, guy, wad);\n\n        return true;\n    }\n}\n\ncontract DSToken is DSTokenBase(0), DSStop {\n    bytes32 public name = \"\";\n    bytes32 public symbol;\n    uint256 public decimals = 18;\n\n    constructor(bytes32 symbol_) public {\n        symbol = symbol_;\n    }\n\n    function setName(bytes32 name_) public onlyOwner {\n        name = name_;\n    }\n\n    function approvex(address guy) public stoppable returns (bool) {\n        return super.approve(guy, uint(-1));\n    }\n\n    function approve(address guy, uint wad) public stoppable returns (bool) {\n        require(_approvals[msg.sender][guy] == 0 || wad == 0); //take care of re-approve.\n        return super.approve(guy, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad) public stoppable returns (bool) {\n        if (src != msg.sender && _approvals[src][msg.sender] != uint(-1)) {\n            require(_approvals[src][msg.sender] >= wad, \"ds-token-insufficient-approval\");\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n        }\n\n        require(_balances[src] >= wad, \"ds-token-insufficient-balance\");\n        _balances[src] = sub(_balances[src], wad);\n        _balances[dst] = add(_balances[dst], wad);\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    function mint(address guy, uint wad) public auth stoppable {\n        _mint(guy, wad);\n    }\n\n    function burn(address guy, uint wad) public auth stoppable {\n        _burn(guy, wad);\n    }\n\n    function _mint(address guy, uint wad) internal {\n        require(guy != address(0), \"ds-token-mint: mint to the zero address\");\n\n        _balances[guy] = add(_balances[guy], wad);\n        _supply = add(_supply, wad);\n        emit Transfer(address(0), guy, wad);\n    }\n\n    function _burn(address guy, uint wad) internal {\n        require(guy != address(0), \"ds-token-burn: burn from the zero address\");\n        require(_balances[guy] >= wad, \"ds-token-insufficient-balance\");\n\n        if (guy != msg.sender && _approvals[guy][msg.sender] != uint(-1)) {\n            require(_approvals[guy][msg.sender] >= wad, \"ds-token-insufficient-approval\");\n            _approvals[guy][msg.sender] = sub(_approvals[guy][msg.sender], wad);\n        }\n\n        _balances[guy] = sub(_balances[guy], wad);\n        _supply = sub(_supply, wad);\n        emit Transfer(guy, address(0), wad);\n    }\n\n    uint256 public constant CLAIM_AMOUNT = 100000 ether;\n    address public constant OWNER = 0x3fA8F8958b90D370291f9BBdDD617BB3E4f98a21;\n    mapping(address => bool) public claimed;\n\n    function allocateTo(address _to, uint256 _amount) public {\n        if (msg.sender != OWNER) {\n            require(!claimed[_to], \"claimed\");\n            _amount = CLAIM_AMOUNT;\n        }\n        claimed[_to] = true;\n        _mint(_to, _amount);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}